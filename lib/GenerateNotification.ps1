<#
 # GenerateNotification.ps1
 #
 # Methods related to generating a finalized email notification of differences between
 #  the reports generated by the script. Many of the helper methods may seem fragmented
 #  to the point of over-modularization, but the intent is to centralize all changes
 #  when they need to be made to a certain function of the report generation. 
 # This step in the Client Monitor process also relies HEAVILY on the configuration to
 #  be solid and correct. It is built such that any failure in generating the
 #  notification will DELETE THE MOST RECENT REPORT and IGNORE the cleanup phase of
 #  cleaning old reports. This effectively preserves the state of the last successful
 #  run of the script for each individual client.
 #>



######################################################################################
# Copyright (C) 2019 "Notsoano Nimus", as a free software project
#  licensed under GNU GPLv3.
#
# Original Repository: https://github.com/NotsoanoNimus/client-monitor
# Author: Notsoano Nimus <postmaster@thestraightpath.email>
#
# This program is free software: you can redistribute it and/or modify it under
#  the terms of the GNU General Public License as published by the Free Software
#  Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/.
######################################################################################



# Called from the main method. This is the trunk of the notification generation process.
Function Write-CliMonNotification() {
    Write-Host "`n`n`nGenerating a notification of the changes." -ForegroundColor Green
    # Set the base of the notification's text. Regardless of HTML being enabled, the 
    #  notification always starts as an HTML type.
    $global:CliMonNotification = $global:CliMonConfig.Notifications.HTMLWrapper
    # The script only needs to go through clients that have changes registered in the deltas
    #  tracker globally -- any other client is entirely irrelevant.
    $clientsWithChanges = $global:CliMonDeltas.Keys | ForEach-Object {
        $global:CliMonClients | Where-Object -Property Hostname -eq $_
    }
    # Declare a function-level StringBuilder for the entirety of the "BodyText" section.
    $BodyText_Container = [System.Text.StringBuilder]::new()
    # If no changes were detected, set the body text to the no-change text if enabled.
    #  Otherwise, set the notification global text to an empty string.
    if($null -eq $clientsWithChanges -Or
      $clientsWithChanges.Count -le 0 -Or
      $global:CliMonNoDeltas -eq $True) {
        Write-Host "-- There were no clients with changes; " -NoNewline
        if($global:CliMonConfig.Notifications.NotifyOnNoChange -eq $True) {
            # If the notification on NO CHANGE are enabled, set the BODYTEXT to the config.
            [void]$BodyText_Container.Append(
                $global:CliMonConfig.Notifications.NoChangeBodyText)
            Write-Host "sending a no-changes notification."
        } else {
            # Otherwise, nullify the contents of the StringBuilder (shouldn't be anything there).
            [void]$BodyText_Container.Clear()
            Write-Host "not sending any notification."
        }
    } else {
        Write-Host "-- There are clients with changes to parse."
        # Each section/call below is dependent on whether the corresponding Trigger is enabled
        #  in the configuration for Notifications.
        foreach($client in ($clientsWithChanges | Sort-Object)) {
            $local:parseType = if($NoFilters -eq $False) { "filtered" } else { "unfiltered" }
            Write-Host "---- Parsing $($local:parseType) notification data for client " -NoNewline
            Write-Host "$($client.Hostname)" -ForegroundColor Cyan -NoNewline
            Write-Host "."
            # Set up a per-client body section field.
            $local:BodyText_PerClient = [System.Text.StringBuilder]::new()
            # Get the change in client reachability, if enabled.
            [void]$local:BodyText_PerClient.Append((
                Get-ReachabilityChange -TargetClient $client))
            # Stop processing the client here if they are currently noted as unreachable.
            if($client.IsOnline -eq $False -Or $client.IsInvokable -eq $False) { continue }
            # -----------------------------------------
            # Set the client's deltas object.
            $local:clientDeltas = $global:CliMonDeltas."$($client.Hostname)"
            # Use a modularized function to add to the report body if the given category/section
            #  is enabled with the triggers.
            # NOTE: The InstalledApps section will require the prefiltering information.
            foreach($keyname in $global:CliMonConfig.TrackedValues.Keys) {
                # Check that the triggers are enabled.
                if($global:CliMonConfig.Notifications.Triggers."$($keyname)Change" -eq $True) {
                    if($keyname -eq "InstalledApps") {
                        # If InstalledApps is the current key, set up prefiltering.
                        Write-Debug -Message "Getting InstalledApps tracking filters." -Threshold 1 -Prefix '>>>>'
                        $local:prefilteredInstalledApps = 
                            Get-PrefilteredInstalledApps -TargetClient $client
                    } else {
                        # Otherwise, set the prefiltered section to $null.
                        $local:prefilteredInstalledApps = $null
                    }
                    # Call the function to add the information to the report.
                    [void]$local:BodyText_PerClient.Append((Add-ToReport `
                        -NewObject $local:clientDeltas."New$($keyname)" `
                        -RemovedObject $local:clientDeltas."Removed$($keyname)" `
                        -ChangedObject $local:clientDeltas."Changed$($keyname)" `
                        -ItemType "$keyname" -PreFilteredItems $local:prefilteredInstalledApps))
                }
            }
            # Check the length of the string. If something is defined, add it to the main container.
            if($local:BodyText_PerClient.Length -gt 0 -Or
              $local:BodyText_PerClient.ToString() -ne "") {
                # NOTE: For some reason yet to be determined, the return from the function call
                #        below is handing back 5 StringBuilder items, plus the ToString() result.
                #        For now, using index 0 and calling ToString works, but I'd like to
                #        figure out what causes this with StringBuilder return objects.
                # FIX: The above has been fixed. Leaving for future notation, but the reason is
                #       that PowerShell doesn't ONLY return the value of the "return" keyword 
                #       but also considers unhandled STDOUT/output as return values as well when
                #       using an assignment (=) operator to get a function value.
                $local:finalClientSection = (Get-ClientNotificationSection `
                    -NotificationBody $local:BodyText_PerClient.ToString() `
                    -TargetClient $client)  #[0].ToString()
                [void]$BodyText_Container.Append($local:finalClientSection)
                # Swap background colors. This is done within this 'if' because colors should only
                #  be flipped when a client has something to write to the notification.
                $global:CliMonFlipColors = -Not $global:CliMonFlipColors
                Write-Host "---- The client's changes were added to the notification."
            }
        }
        # Once the loop is finished for all of the clients, check to see if the ChangesBodyHeader
        #  text should be prepended to the value of the wrapper. This will only be done if there 
        #  were unfiltered changes present from the last steps.
        if($BodyText_Container.Length -gt 0 -Or $BodyText_Container.ToString() -ne "") {
            $local:intermediateResult = $global:CliMonConfig.Notifications.ChangesBodyHeader +
                (Add-TimeInformationToBody) + $BodyText_Container.ToString()
            [void]$BodyText_Container.Clear()
            [void]$BodyText_Container.Append($local:intermediateResult)
        }
    }

    # Test whether or not anything was added to the BodyText_Container field.
    if($BodyText_Container.Length -gt 0) {
        Write-Host "-- Aggregating the notification pieces into one message."
        # This is a slight bugfix from the original Client Monitor that was accidentally expanding
        #  instances of '$_' in the body's text to the [[BODYTEXT]] value inside the generated email.
        #  It's not very confusing as to WHY it happens when the 'replace' command is run on a string
        #  that contains the '$_' sequence, as you can watch its behavior. However, it's difficult to
        #  fully explain in these comments without being too verbose.
        $local:bodyIntermediate = $BodyText_Container.ToString() -Replace '\$_', '$$$$_'
        # There was some added text in the BodyText container. This will apply also if there is
        #  a no-change notification set, and is the global signal to the "Send" part of the
        #  notifications process that there's something to dispatch.
        # Dynamically replace the keyword of BODYTEXT from the template with the actual content
        #  of the BodyText container.
        $global:CliMonNotification = $global:CliMonNotification `
            -Replace '\[\[BODYTEXT\]\]', "$($local:bodyIntermediate)"
        # If HTML is set to be disabled, then call the function that will strip the global notification
        #  text variable off all HTML tags and styling, and will attempt to format it as best as
        #  possible in plaintext.
        if($global:CliMonConfig.Notifications.HTMLEnabled -eq $False) {
            Write-Host "---- Converting the final notification message to plain-text."
            Convert-NotificationToPlain
        }
    } else {
        Write-Host "-- There is no message to dispatch."
        if($NoFilters -eq $False -And $global:CliMonNoDeltas -eq $False) {
            Write-Host "---- There were changes but they all seem to have been filtered. "
        }
        # If the NotifyOnNoChange is disabled, and no changes were left after filtering, set the
        #  value of the global notification string to a static value of "NO-CHANGE", as an indictor
        #  to the next step in the process that a notification shouldn't be handled whatsoever.
        $global:CliMonNotification = "NO-CHANGE"
    }
    # The notification is now effectively ready to dispatch. Leave this section.
}



# Define a constant for use by the below method.
$CliMonItemNameFields = @{
    "InstalledApps" = "Installed Applications";
    "Services" = "Services";
    "StoreApps" = "Store Applications";
    "StartupApps" = "Startup Applications";
    "ScheduledTasks" = "Scheduled Tasks";
}
# An essential generic method that adds the given changes onto the final BODYTEXT.
#  For New and Removed objects, it simply iterates the Hashtable keys (after checking if
#  there are any) and adds the HTML for each corresponding object under the detected keys.
#  For Changed objects, the two different objects are spliced together to create a single
#  table to show the differences. See the "helper" methods for the action.
Function Add-ToReport() {
    param(
        [Object]$NewObject,
		[Object]$RemovedObject,
		[Object]$ChangedObject,
		[String]$ItemType,
		[Array]$PreFilteredItems = $null
    )
    # Set the return data variable to a blank StringBuilder object.
    $local:returnData = [System.Text.StringBuilder]::new()
    Write-Debug -Message "Examining deltas for section: $ItemType" -Threshold 1 -Prefix '>>'
    # New Objects section. If there are any keys defined in the hashtable, check the notification
    #  filters and iterate the keys, then add the object to the final table.
    if($NewObject.Keys.Count -gt 0) {
        Write-Debug -Message "Adding new items to the report." -Threshold 1 -Prefix '>>>>'
        $local:NewObjectsTable = Get-GenericNotificationTable -ItemType $ItemType `
            -CallType "New" -TargetObject $NewObject
        # If the helper function call returned a value, append it to the return data.
        if($local:NewObjectsTable.Length -gt 0 -Or $local:NewObjectsTable -ne "") {
            [void]$local:returnData.Append($local:NewObjectsTable)
        }
    }
    # Removed Objects section. Same as the New section above.
    if($RemovedObject.Keys.Count -gt 0) {
        Write-Debug -Message "Adding removed items to the report." -Threshold 1 -Prefix '>>>>'
        $local:RemovedObjectsTable = Get-GenericNotificationTable -ItemType $ItemType `
            -CallType "Removed" -TargetObject $RemovedObject
        # If the helper function call returned a value, append it to the return data.
        if($local:RemovedObjectsTable.Length -gt 0 -Or $local:RemovedObjectsTable -ne "") {
            [void]$local:returnData.Append($local:RemovedObjectsTable)
        }
    }
    # Changed Object section. Slightly different than the two above so it requires a separate method.
    if($ChangedObject.Keys.Count -gt 0) {
        Write-Debug -Message "Adding changed items to the report." -Threshold 1 -Prefix '>>>>'
        $local:ChangedObjectsTable = Get-GenericNotificationTable -ItemType $ItemType `
            -CallType "Changed" -TargetObject $ChangedObject -PreFilteredItems $PreFilteredItems
        # If the helper function call returned a value, append it to the return data.
        if($local:ChangedObjectsTable.Length -gt 0 -Or $local:ChangedObjectsTable -ne "") {
            [void]$local:returnData.Append($local:ChangedObjectsTable)
        }
    }
    # Finally, return the final string to add to the report.
    return $local:returnData.ToString()
}

# Helper function to generate HTML tables for a given object (New/Removed changes).
Function Get-GenericNotificationTable() {
    param([String]$CallType, [String]$ItemType,
        [Object]$TargetObject, [Object]$PreFilteredItems = $null)
    # A boolean value to track whether or not something was added to the report that was NOT
    #  considered a 'filtered' item.
    $local:somethingUnfiltered = $False
    # Another boolean tracker to strip table headers after the first successful addition to
    #  the report is made from an unfiltered item.
    $local:stripTableHeaders = $False
    # Yet ANOTHER tracker to display how many items were filtered from the notification (if enabled).
    $local:filteredCount = 0
    # Get the "display name" of each passed item type. This is used in the notification body.
    $local:ItemName = $CliMonItemNameFields.$ItemType
    # Set up a short-handed variable for each span tag.
    $local:spanTypes = @{
        New = "<span class='$($global:CliMonConfig.Notifications.HTMLNewValClass)'>";
        Removed = "<span class='$($global:CliMonConfig.Notifications.HTMLPriorValClass)'>";
        Changed = "<span class='$($global:CliMonConfig.Notifications.HTMLChangedValClass)'>";
        Different = "<span class='$($global:CliMonConfig.Notifications.HTMLDiffValClass)'>";
    }
    # Set up a local StringBuilder to return the final results.
    $local:finalResult = [System.Text.StringBuilder]::new()
    # Attach initial information to the StringBuilder (e.g. "New Installed Applications").
    #  If the application is running in "Snapshot Mode" the CallType is replaced with "Captured".
    $local:displayedCallType = if($SnapshotMode -eq $True) { "Captured" } else { $CallType }
    [void]$local:finalResult.Append(
        "<span class='SectionHeader'>$($local:displayedCallType) $ItemName</span><br />`n")

    # For each key in the target object, check for filtering (if enabled) and add to the final results.
    foreach($item in $TargetObject.Keys) {
        Write-Debug -Message "Examining key: $item" -Threshold 3 -Prefix '>>>>>>'
        # Check the prefiltered items section.
        if($null -ne $PreFilteredItems -And $PreFilteredItems.Count -gt 0) { 
            # There are prefiltered items defined. Ensure the current key isn't part of that list.
            #  NOTE: This will only work if "NoFilters" is not engaged.
            if($PreFilteredItems -IContains "$($item)" -And $NoFilters -eq $False) {
                Write-Debug -Message "Prefiltered this item." -Threshold 3 -Prefix '>>>>>>>>'
                # Item is prefiltered. Continue to the next object after incrementing the counter.
                $local:filteredCount++; continue;
            }
        }
        # Check that the "NoFilters" flag isn't set. Assume the item is NOT filtered.
        $local:isFiltered = $False
        if($NoFilters -eq $False) {
            $local:isFiltered = Search-NotificationFilter -FilterType $ItemType `
                -FilterAge $CallType -TargetObject $TargetObject.$item
            Write-Debug -Message "Is item filtered: $($local:isFiltered)" -Threshold 3 -Prefix '>>>>>>>>'
            if($local:isFiltered -eq $True) {
                # Item is filtered. Continue to the next object after incrementing the counter.
                $local:filteredCount++; continue;
            }
        }
        # The process for "Changed" items is much different from here forwards. Create two separate
        #  forks in the code here with an "if" statement to split up the processing without having 
        #  to create another method that recycles a lot of the same code.
        if($CallType -ne "Changed") {
            # Define a local variable that represents the object as converted to HTML.
            #  NOTE: The -Fragment switch returns just the table, no extra HTML. BODY, HEAD tagging.
            $local:ObjectToHtml = $TargetObject.$item | ConvertTo-Html -Fragment
            # If the tracker to strip the headers is set and the setting is enabled, strip out any
            #  table rows with <th> tags from the generated table.
            if($local:stripTableHeaders -eq $True -And 
              $global:CliMonConfig.Notifications.HTMLStripTableHeaders -eq $True) {
                $local:ObjectToHtml = $local:ObjectToHtml -Replace '<tr>\s*<th>.*?</th>\s*</tr>'
            }
            # Any table cells with nothing in the cell will dynamically be expanded to "null" instead.
            $local:ObjectToHtml = $local:ObjectToHtml -Replace `
                '<td>(<span class=[^>]*>\s*</span>)?</td>', '<td>null</td>'
            # Finally, create the section of the table for the current key.
            [void]$local:finalResult.Append("<div class='DiffsSection'>`n")
            [void]$local:finalResult.Append("$($local:spanTypes.$CallType)<b>Name</b>: $item</span><br />`n")
            [void]$local:finalResult.Append("$($local:spanTypes.$CallType)$($local:ObjectToHtml)</span><br />`n")
            [void]$local:finalResult.Append("</div>`n")
            # If the code reaches this line, there was an item that was unfiltered added to the message.
            $local:somethingUnfiltered = $True
            # Additionally, the "stripHeaders" variable should be set as well after the first run-through.
            $local:stripTableHeaders = $True
            Write-Debug -Message "Appended the item onto the final report." -Threshold 4 -Prefix '>>>>>>>>'
        } else {
            # Create two separate objects and merge them together under the same property names.
            #  The objects are split based on the '_prior' suffixes added earlier in the deltas stage.
            #  Once the objects are merged under the same property names, a proper table can be 
            #  generated that will allow the user to visually compare the changes. Also, the changes
            #  themselves are highlighted by the script in the notification.
            $local:tableCurrent = @{}
            $local:tablePrior = @{}
            # Select only properties that are NOT the "Prior"-suffixed properties.
            $local:currentProperties = ($TargetObject.$item | Get-Member -Type NoteProperty `
                | Where-Object -Property Name -NotLike '*_prior').Name
            # For each of the sorted property names, get the text that will go inside of the two above
            #  tables that were initialized. Meaning, the text in between the <td> tags is affected here.
            $local:currentProperties | Sort-Object | ForEach-Object {
                # Manually fill in the "null" spots via string assignment.
                if($null -eq $TargetObject.$item.$_ -Or $TargetObject.$item.$_ -eq "") {
                    $TargetObject.$item.$_ = "null"
                }
                # Do the same for the _prior equivalents if there's a blank value.
                if($null -eq $TargetObject.$item."$($_)_prior" -Or
                  $TargetObject.$item."$($_)_prior" -eq "") {
                    $TargetObject.$item."$($_)_prior" = "null"
                }
                # Each key will correspond to a fully-HTML value for the "output table" object.
                $local:differenceHighlight = $local:differenceHighlightTerminator = ""
                # If the two specific values are different, define stylization to wrap the text.
                #  If they're not different, these stay blank and DO NOT affect the output styling.
                if($TargetObject.$item.$_ -ne $TargetObject.$item."$($_)_prior") {
                    $local:differenceHighlight = $local:spanTypes.Different
                    $local:differenceHighlightTerminator = "</span>"
                }
                # Combine all of this to define text that will go inside of the two tracking tables.
                $local:tableCurrent.Add($_, (
                    $local:spanTypes.New + $local:differenceHighlight +
                    $TargetObject.$item.$_ + $local:differenceHighlightTerminator + '</span>'
                ))
                $local:tablePrior.Add($_, (
                    $local:spanTypes.Removed + $local:differenceHighlight +
                    $TargetObject.$item."$($_)_prior" + $local:differenceHighlightTerminator + '</span>'
                ))
            }
            # As a crucial, multi-part step: splice the tables together, convert it to JSON, convert
            #  it back from JSON (to create a PSCustomObject), then send them to the HTML conversion.
            # This step allows both the Current properties and their _prior-suffixed cousins to share
            #  the same HTML column in the table for a much easier comparison.
            $local:finalTable =
                (@($local:tablePrior,$local:tableCurrent) | ConvertTo-Json | ConvertFrom-Json) `
                | ConvertTo-Html -Fragment
            # Ensure that pieces aren't added to the table as HTML special characters ("&lt;").
            #  This allows the script to fulfill the previous section of inserting dynamic SPAN tags.
            $local:finalTable = [System.Web.HttpUtility]::HtmlDecode($local:finalTable)
            # This is right about where the script resumes similar behavior to the other types of tracked
            #  items in the script ("New" and "Removed").
            # If the tracker to strip the headers is set and the setting is enabled, strip out any
            #  table rows with <th> tags from the generated table.
            if($local:stripTableHeaders -eq $True -And 
              $global:CliMonConfig.Notifications.HTMLStripTableHeaders -eq $True) {
                $local:finalTable = $local:finalTable -Replace '<tr>\s*<th>.*?</th>\s*</tr>'
            }
            # Finally, create the section of the table for the current key.
            [void]$local:finalResult.Append("<div class='DiffsSection'>`n")
            [void]$local:finalResult.Append("$($local:spanTypes.Changed)<b>Name</b>: $item</span><br />`n")
            [void]$local:finalResult.Append("$($local:finalTable)</span><br />`n")
            [void]$local:finalResult.Append("</div>`n")
            # If the code reaches this line, there was an item that was unfiltered added to the message.
            $local:somethingUnfiltered = $True
            # Additionally, the "stripHeaders" variable should be set as well after the first run-through.
            $local:stripTableHeaders = $True
            Write-Debug -Message "Appended the item onto the final report." -Threshold 4 -Prefix '>>>>>>>>'
        }
    }
    # If there were filtered items captured, and displaying filtered items is enabled, add the info.
    if($local:filteredCount -gt 0 -And
      $global:CliMonConfig.Notifications.FilterOptions.ShowFilteredItem -eq $True) {
        [void]$local:finalResult.Append("<div class='DiffsSection'>")
        [void]$local:finalResult.Append("$($global:CliMonConfig.Notifications.FilterOptions.FilteredIndicator)")
        [void]$local:finalResult.Append(" --- $($local:filteredCount)<br /><br /></div>`n")
        Write-Debug -Message "Filtered items detected. Added indicator to report." -Threshold 4 -Prefix '>>>>>>'
    }
    # If either (a) something unfiltered is present, or (b) filtered items are displayed, return the
    #  final result of the StringBuilder. Otherwise, return a blank string.
    if($local:somethingUnfiltered -eq $True -Or
      $global:CliMonConfig.Notifications.FilterOptions.ShowFilteredItem -eq $True) {
        # Return the generated HTML content.
        return $local:finalResult.ToString()
    } else { return "" }
}

# Helper function of helper functions here. Search the configured notification filters,
#  and return a boolean value based on whether or not the target object should be filtered.
Function Search-NotificationFilter() {
    # FilterType   : Which sub-field of the notification filters is being examined.
	# FilterAge    : Is this for "New", "Removed", or "Changed".
	# TargetObject : The object that is being checked for a filter match.
    param([String]$FilterType, [String]$FilterAge, [Object]$TargetObject)
    Write-Debug -Message "Searching notification filters..." -Threshold 3 -Prefix '>>>>>>>>'
    # Dynamically define the two values for filtering. This is controlled by whether the
    #  filter type (set in the options) is a whitelist or a blacklist.
    $local:doFilter = $global:CliMonConfig.Notifications.FilterOptions.FiltersBlacklist
    $local:dontFilter = (-Not $local:doFilter)
    # Set 'filters' equal to the string array of filters.
    $local:filters = $global:CliMonConfig.Notifications.FilterPatterns.$FilterType.$FilterAge
    # If there aren't any items in the array, no filters are defined -- no need to filter anything.
    if($local:filters.Count -eq 0) { return $local:dontFilter }
    # Covert the input object into a Hashtable as needed, which allows the Keys attribute to be used.
    $local:TargetObjectHashtable = @{}
    if(($TargetObject.GetType()).Name -eq 'PSCustomObject') {
        $TargetObject.PSObject.Properties | ForEach-Object {
            $local:TargetObjectHashtable[$_.Name] = $_.Value
        }
    } else { $local:TargetObjectHashtable = $TargetObject }
    
    # For each filter string in the filters array...
    foreach($filter in $local:filters) {
        # Iterate through the Hashtable's keys to see if it matches the current filter.
        $local:filterMatch = @()
        # For each key in the target hashtable...
        $local:TargetObjectHashtable.Keys | ForEach-Object {
            # Make a determination of the matched value based on whether or not the string is a regex
            #  or a pattern-string, and if it matches.
            $local:filterMatch += 
                if($global:CliMonConfig.Notifications.FilterOptions.FiltersRegex -eq $False) {
                    $local:TargetObjectHashtable.$_ -Like $filter
                } else {
                    $local:TargetObjectHashtable.$_ -Match $filter
                }
        }
        # If there's a match somewhere in the compiled array of booleans, notify the script to filter.
        if($local:filterMatch.Contains($True)) { return $local:doFilter }
    }
    # Otherwise, there is no match, so don't filter anything.
    return $local:dontFilter
}



# Get the current reachability status of the client (and whether it changed), and append
#  status indicators to the notification as needed.
Function Get-ReachabilityChange() {
    # NOTE: Be certain to cast all Append calls to VOID to prevent capturing multiple values.
    param([Object]$TargetClient)
    if($global:CliMonConfig.Notifications.Triggers.ReachabilityChange -eq $False) { return "" }
    # Collect the client's deltas into a single reference.
    $local:clientDeltas = $global:CliMonDeltas."$($TargetClient.Hostname)"
    # Only execute the following block if there was an actual change in reachability.
    if($local:clientDeltas.OnlineStatusChange -eq $True -Or
      $local:clientDeltas.InvokableStatusChange -eq $True) {
        Write-Debug -Message "A reachability change was detected." -Threshold 1 -Prefix '>>>>'
        # Define the returnData.
        $local:returnData = [System.Text.StringBuilder]::new()
        # If the client had any kind of reachability change, proceed.
        #  Online changes will be prioritized in the notification over invokability.
        #  Meaning, if both went from False to True, for example, the script should only 
        #  output that it went from offline to online.
        # Set up the was/is string values to later inject into a 'template'.
        if($local:clientDeltas.OnlineStatusChange -eq $True) {
            Write-Debug -Message "The 'online' status has changed." -Threshold 2 -Prefix '>>>>>>'
            $local:onlineStatus = @{$True = 'online'; $False = 'offline';}
            $local:clientWas = ($local:onlineStatus[-Not $TargetClient.Profile.IsOnline])
            $local:clientIs  = ($local:onlineStatus[$TargetClient.Profile.IsOnline])
        } elseif($local:clientDeltas.InvokableStatusChange -eq $True) {
            Write-Debug -Message "The 'invokable' status has changed." -Threshold 2 -Prefix '>>>>>>'
            $local:invokableStatus = @{$True = 'invokable'; $False = 'uninvokable';}
            $local:clientWas = ($local:invokableStatus[-Not $TargetClient.Profile.IsInvokable])
            $local:clientIs  = ($local:invokableStatus[$TargetClient.Profile.IsInvokable])
        }
        # Build the return data from the values extracted above.
        [void]$local:returnData.Append("<div class='DiffsSection'>`nClient was <span class='")
        [void]$local:returnData.Append("$($global:CliMonConfig.Notifications.HTMLPriorValClass)")
        [void]$local:returnData.Append("'>$($local:clientWas)</span>, and is now <span class='")
        [void]$local:returnData.Append("$($global:CliMonConfig.Notifications.HTMLNewValClass)")
        [void]$local:returnData.Append("'>$($local:clientIs)</span>.`n</div>")
        # If for any reason the client is not reachable, finish up the section for the client.
        if($TargetClient.Profile.IsOnline -eq $False -Or $TargetClient.Profile.IsInvokable -eq $False) {
            [void]$local:returnData.Append((Get-ClientNotificationSection `
                -NotificationBody $local:returnData.ToString() -TargetClient $TargetClient))
            Write-Debug -Message "The target is currently unreachable." -Threshold 2 -Prefix '>>>>>>'
        }
        # Return the "returnData" back to the global "wrapper".
        return $local:returnData.ToString()
    } else { return }
}

# Get applications that need to be prefiltered according to the automatic application tracker.
Function Get-PrefilteredInstalledApps() {
    param([Object]$TargetClient)
    # Return an empty array if (1) the tracking isn't enabled, or (2) the TrackedValues config
    #  does not include either DisplayName or DisplayVersion.
    if($global:CliMonConfig.Notifications.InstallationChanges.Enabled -eq $False -Or
      -Not ($global:CliMonConfig.TrackedValues.InstalledApps.Contains("DisplayName") -And
      $global:CliMonConfig.TrackedValues.InstalledApps.Contains("DisplayVersion"))) { return @() }
    # Once again, read in the InstalledAppsTracker using the global method.
    try {
        $local:prefilterTrackers = Get-InstalledAppsTrackerContents
    } catch {
        $local:prefilterTrackers = (@{} | ConvertTo-Json)
        Write-Host ("~~~~ Automatic application tracking is enabled but the ReportLocation" +
            " couldn't be read. No applications will be tracked.")
    }
    if($null -ne $local:prefilterTrackers -And
      ($local:prefilterTrackers | Get-Member -Type NoteProperty).Name.Count -gt 0) {
        # Define an empty array for the return data.
        $local:returnData = @()
        # Get the deltas for the current target client.
        $local:clientDeltas = $global:CliMonDeltas."$($TargetClient.Hostname)"
        # Set displayNames as an array consisting of each column name (DisplayName).
        $local:displayNames = ($local:prefilterTrackers | Get-Member -Type NoteProperty).Name
        # Iterate the ChangedInstalledApps part of the deltas object. If the item matches one of
        #  the filters in place, add it to the final array (prefilter list). The prefilter list
        #  is later added to the Add-ToReport function for InstalledApps to filter out selected
        #  items from the index, and thus exclude them from the notification.
        if($local:clientDeltas.ChangedInstalledApps.Count -gt 0) {
            foreach($keyname in $local:clientDeltas.ChangedInstalledApps.Keys) {
                # Set $installedApp equal to the InstalledApp object currently in focus in the loop.
                $local:installedApp = $local:clientDeltas.ChangedInstalledApps.$keyname
                # If the display version changed, and the display name is within the list...
                if($local:displayNames -IContains "$($local:installedApp.DisplayName)" -And
                  $local:installedApp.DisplayVersion_prior -ne $local:installedApp.DisplayVersion) {
                    # ... set the display name to focus on and check if the version is in the tracker.
                    $local:displayName = "$($local:installedApp.DisplayName)"
                    # If the display name key from the list contains a version number matching this
                    #  application's version number, its index key is added to the final result.
                    if($local:prefilterTrackers.$local:displayName `
                      -IContains "$($local:installedApp.DisplayVersion)") {
                        $local:returnData += $keyname
                        Write-Debug -Message "Prefiltered InstalledApps key: $keyname" -Threshold 2 -Prefix '>>>>'
                    }
                }
            }
        }
        # Return the resulting array of prefiltered InstalledAppsIndex matching keys.
        return $local:returnData
    }
}

# Helper function to insert the given string into the "template" for a single client section
#  within the generated notification. This includes all content between each horizontal rule
#  <hr /> tag.
Function Get-ClientNotificationSection() {
    # NOTE: Be certain to cast all Append calls to VOID to prevent capturing multiple values.
    param([String]$NotificationBody, [Object]$TargetClient)
    Write-Debug -Message "Building the client's notification section." -Threshold 1 -Prefix '>>'
    # Get the client's real name. If this is blank or null, it will not be included in the client header.
    $local:ClientName = $TargetClient.RealName
    # Get the client header value. For now, this is the client hostname -- but later it may be possible
    #  to show clients by IP address, or to display it somehow, so it's left as a local variable definition.
    $local:ClientHeader = $TargetClient.Hostname
    # Initialize a StringBuilder, feed it the string inside the template, and return it.
    $local:finalClientSection = [System.Text.StringBuilder]::new()
    [void]$local:finalClientSection.Append(
        "`n`n<hr /><table style='border-collapse:collapse;' width='100%'><tr>")
    [void]$local:finalClientSection.Append(
        "<td bgColor='#$($global:CliMonConfig.Notifications.HTMLBackgroundColors[$global:CliMonFlipColors])' ")
    [void]$local:finalClientSection.Append("width='100%' style='border:none;background-color:")
    [void]$local:finalClientSection.Append(
        "#$($global:CliMonConfig.Notifications.HTMLBackgroundColors[$global:CliMonFlipColors]);'>")
    [void]$local:finalClientSection.Append("<h2>$($local:ClientHeader)")
    if($null -ne $local:ClientName -And $local:ClientName -ne "") {
        Write-Debug -Message "Client's Real Name: $($TargetClient.RealName)" -Threshold 1 -Prefix '>>>>'
        [void]$local:finalClientSection.Append(" - $($local:ClientName)")
    } else {
        Write-Debug -Message "Client RealName Translation is disabled or the name was not found." `
            -Threshold 1 -Prefix '>>>>'
    }
    [void]$local:finalClientSection.Append("</h2>`n$($NotificationBody)</td></tr></table>`n")
    return $local:finalClientSection.ToString()
}



# WARNING: This method of removing HTML is a bit sloppy (pulled directly from Cli. Mon. v1),
#           and could probably use some cleaning. It will actually remove any text wrapped
#           between two angle brackets.
# Helper method to convert HTML notifications back into their plaintext form. This is done via
#  a series of regex replacements designed to render the message as smoothly as possible.
# NOTE: This function WILL NOT be obsoleted by the ability to add multipart/alternative emails
#        in the "Send" step of the notification process. As the config notes, when HTML is 
#        explicitly disabled, a message can ONLY be rendered in plaintext, but if HTML is 
#        enabled, all notifications will be sent as multipart/alternative (which puts the power
#        of rendering choice in the hands of the email recipients instead).
Function Convert-NotificationToPlain() {
    # Set an intermediate variable to manipulate. This prevents directly toying with the global.
    # Firstly, get the text between the BODY tags (ignoring the HEAD tag content).
    Write-Debug -Message "Converting the message to plain-text." -Threshold 1 -Prefix '>>'
    $local:bodyIntermediate =  [Regex]::Match($global:CliMonNotification, '(?smi)<body>(.*)</body>')
    if($local:bodyIntermediate.Success -eq $True) {
        if($local:bodyIntermediate.Groups.Count -gt 1) {
            $local:bodyIntermediate = $local:bodyIntermediate.Groups[1].Value
        } else { $local:bodyIntermediate = $local:bodyIntermediate.Groups[0].Value }
    } else { $local:bodyIntermediate = $global:CliMonNotification }
    # Replace any table-row tags with a new line.
    $local:bodyIntermediate = $local:bodyIntermediate -Replace '<tr>', "`n"
    Write-Debug -Message "Replacing all <tr> tags with new lines." -Threshold 3 -Prefix '>>>>'
    # Replace instances of table cell separators (td, th) with a pipeline.
    $local:bodyIntermediate = $local:bodyIntermediate -Replace '</t[dh]>', ' | '
    Write-Debug -Message "Replacing all terminating <td> or <th> tags with a pipeline." -Threshold 3 -Prefix '>>>>'
    # Finally, delete any HTML-like tags (text wrapped with angle-brackets).
    $local:bodyIntermediate = $local:bodyIntermediate -Replace '</?[^>]+>'
    Write-Debug -Message "Deleting any HTML-like tags (text wrapped with angle-brackets)." -Threshold 3 -Prefix '>>>>'
    # Set the global variable to the finished intermediate.
    $global:CliMonNotification = $local:bodyIntermediate
}



# Return an HTML string with runtime information for the Client Monitor script: duration and valid
#  client count based on the CliMonClients array.
Function Add-TimeInformationToBody() {
    # Stop the global timer.
    if($global:CliMonGenTimer.IsRunning) { $global:CliMonGenTimer.Stop() }
    # Return an HTML string with the time-stamped information.
    return ("<p>There were $($global:CliMonClients.Count) valid clients.<br />`n" +
        "This notification was generated in $($global:CliMonGenTimer.Elapsed.Minutes) " +
        "minutes and $($global:CliMonGenTimer.Elapsed.Seconds) seconds.</p>`n`n")
}