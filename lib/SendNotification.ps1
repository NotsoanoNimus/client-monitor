<#
 # SendNotification.ps1
 #
 # Methods related to sending the generated notification to the target party(ies)
 #  as specified in the configuration. If for any reason there is a failure to
 #  dispatch the notification, the reports generated by the current run of the
 #  script will be deleted.
 #>



######################################################################################
# Copyright (C) 2019 "Notsoano Nimus", as a free software project
#  licensed under GNU GPLv3.
#
# Original Repository: https://github.com/NotsoanoNimus/client-monitor
# Author: Notsoano Nimus <postmaster@thestraightpath.email>
#
# This program is free software: you can redistribute it and/or modify it under
#  the terms of the GNU General Public License as published by the Free Software
#  Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/.
######################################################################################



# Define a CliMonNotification class.
#  This will help with making the dispatch process easier to manage in the lines
#  of code that are actually doing the processing. It is only used once but it is
#  helpful because of the methods being attached to it.
class CliMonNotification {
    [String]$SmtpError = ""
    [System.Net.Mail.SmtpClient]$SmtpClient = $null
    [System.Net.Mail.MailMessage]$EmailObject = $null
    [String]$NotificationAsAttachmentPath = "cli-mon-notification"

    CliMonNotification(
        [System.Net.Mail.MailAddress]$FromAddressItem,
        [System.Net.Mail.MailAddress]$RecipientAddressItem,
        [String]$NotificationBody,
        [Boolean]$IsHtml,
        [Boolean]$IsBodyAttachment,
        [String]$ReportsDir = $null,
        [String]$AlternateBodyText
    ) {
        # Set the From/To fields.
        $this.EmailObject = [System.Net.Mail.MailMessage]::new($FromAddressItem, $RecipientAddressItem)
        # Set the message encoding.
        $this.EmailObject.BodyEncoding = [System.Text.Encoding]::UTF8
        # Set the transfer encoding to Base64.
        $this.EmailObject.BodyTransferEncoding = [System.Net.Mime.TransferEncoding]::Base64
        # Shameless self-plug :)
        $this.EmailObject.Headers.Add("X-Client-Monitor", "https://github.com/NotsoanoNimus/client-monitor")
        # If the AsAttachment flag was set, the notification will be saved to a file and added onto the
        #  collection of attachments in the email. The body text will then consist of the alternate text
        #  defined in the Client Monitor configuration.
        if($IsBodyAttachment -eq $True -And $null -ne $ReportsDir) {
            $local:storageInfo =
                if($IsHtml -eq $True) {
                    @{ContentType = "text/html"; Extension = "html" }
                } else {
                    @{ContentType = "text/plain"; Extension = "txt" }
                }
            $local:currentTime = (Get-Date -UFormat %Y-%m-%d-%H_%M).ToString()
            $this.NotificationAsAttachmentPath =
                "$($ReportsDir)\Notification-$($local:currentTime).$($local:storageInfo.Extension)"
            # Write the contents of the notification body to the storage location.
            Write-Output $NotificationBody | Out-File $this.NotificationAsAttachmentPath -Force
            # Add the file as an attachment to the email.
            $this.AddAttachment($this.NotificationAsAttachmentPath, `
                "Summary-$($local:currentTime).$($local:storageInfo.Extension)", $local:storageInfo.ContentType)
            # Set the body equal to the configuration's alternate text definition.
            $this.EmailObject.Body = $AlternateBodyText
        } else {
            # Set the body of the notification equal to the collected contents.
            $this.EmailObject.Body = $NotificationBody
        }
    }

    # Initialize this object's SMTP client object. This is REQUIRED.
    [Void]StartSmtpClient([String]$RelayServer, [int]$RelayPort,
      [Boolean]$UseSsl, [PSCredential]$SmtpCredential) {
        $this.SmtpClient = [System.Net.Mail.SmtpClient]::new($RelayServer, $RelayPort)
        $this.SmtpClient.EnableSsl = $UseSsl
        if($null -ne $SmtpCredential) { $this.SmtpClient.Credentials = $SmtpCredential }
    }

    # Set other miscellaneous email object information.
    [Void]SetEmailInfo([String]$EmailSubject, [String]$BccAddress) {
        $this.EmailObject.Subject = $EmailSubject
        $BccAddress.Split(",") | ForEach-Object {
            if($null -ne $_ -And $_ -ne "") { $this.EmailObject.Bcc.Add($_) }
        }
    }

    # Attempt to send the MailMessage with the SmtpClient.
    [Boolean]SendNotification() {
        try {
            $local:smtpSendResult = $this.SmtpClient.Send($this.EmailObject)
            return $?
        } catch {
            $this.SmtpError = $_
            return $False
        }
    }

    # Add the file path as an attachment to the email, using the specified encoding.
    [Boolean]AddAttachment([String]$PathToFile, [String]$AttachmentName, [String]$ContentType) {
        # Attempt to open a file-stream on the given filename. If this fails, return a False.
        try {
            $local:fileStream = [System.IO.File]::OpenRead($PathToFile)
        } catch { return $False }
        # Create the attachment and add it to the list of attachments on the email.
        $local:tempAttachment = [System.Net.Mail.Attachment]::new($local:fileStream, $AttachmentName)
        $local:tempAttachment.ContentDisposition.Inline = $False
        $local:tempAttachment.ContentDisposition.DispositionType = $ContentType
        $local:tempAttachment.ContentDisposition.FileName = $AttachmentName
        $local:tempAttachment.TransferEncoding = [System.Net.Mime.TransferEncoding]::Base64
        $this.EmailObject.Attachments.Add($local:tempAttachment)
        return $True
    }
}



# Called from the main method. This function attempts to dispatch the generated
#  notification based on the parameters specified in the configuration.
Function Send-CliMonNotification() {
    # If the notification message matches the universal no-notification-change string,
    #  promptly exit this function call, as there's nothing to send.
    if($global:CliMonNotification -eq "NO-CHANGE") {
        Write-Host "-- Notifications on no change are disabled, and there were no changes detected."
        return
    }
    Write-Host "`n`n`nDispatching the generated notification." -ForegroundColor Green
    # Create the CliMonNotification object based on the AsAttachment parameter and the final
    #  notification text.
    # NOTE: Although HTMLEnabled is passed here, it's only used to determine the MIME type and
    #        filename extension of the attachment if AsAttachment is engaged. The IsBodyHtml flag
    #        is set just a bit further down than the constructor.
    Write-Debug -Message "Creating the CliMonNotification instance." -Threshold 1 -Prefix '>>'
    $local:finalNotification = [CliMonNotification]::new(
        $global:CliMonConfig.Notifications.Source,
        $global:CliMonConfig.Notifications.Recipient,
        $global:CliMonNotification,
        $global:CliMonConfig.Notifications.HTMLEnabled,
        $AsAttachment,
        $global:CliMonConfig.ReportsDirectory,
        $global:CliMonConfig.Notifications.AlternateBodyText
    )
    Write-Debug -Message "Initializing the SMTP client object." -Threshold 2 -Prefix '>>>>'
    # Initialize the SMTP client in preparation for sending the email.
    $local:finalNotification.StartSmtpClient(
        $global:CliMonConfig.Notifications.Smtp.Server,
        $global:CliMonConfig.Notifications.Smtp.ServerPort,
        $global:CliMonConfig.Notifications.Smtp.UseSsl,
        $global:CliMonConfig.Notifications.Smtp.Credential
    )
    Write-Debug -Message "Populating additional email message parameters (BCC, Subject, etc)." `
        -Threshold 2 -Prefix '>>>>'
    # Set up additional email information (subject, BCC, SSL, and credentials).
    $local:finalNotification.SetEmailInfo(
        $global:CliMonConfig.Notifications.Subject,
        $BCC
    )
    Write-Debug -Message "Determining whether the message is HTML or plain-text." `
        -Threshold 3 -Prefix '>>>>>>'
    # Set the IsBodyHtml flag... This will also depend on whether the AsAttachment flag is set.
    $local:finalNotification.EmailObject.IsBodyHtml =
        if($AsAttachment -eq $True) {
            $global:CliMonConfig.Notifications.AlternateBodyTextIsHtml
        } else {
            $global:CliMonConfig.Notifications.HTMLEnabled
        }
    # Add the final attachments to the email. Check for the parameter flags, and whether or not the
    #  configuration specifies that the document should be included to notifications as an attachment.
    if($global:CliMonConfig.FlatReportCsv.AsAttachment -eq $True -And $FlatReportCsv -eq $True) {
        Write-Debug -Message "Adding Flat Report CSV attachment: $($global:CliMonFlatReportCsvName)" `
            -Threshold 2 -Prefix '>>>>'
        $local:finalNotification.AddAttachment(
            $global:CliMonFlatReportCsvName,
            (Split-Path $global:CliMonFlatReportCsvName -Leaf),
            "application/octet-stream"
        )
    }
    if($global:CliMonConfig.DeltasReport.AsAttachment -eq $True -And $DeltasReport -eq $True) {
        Write-Debug -Message "Adding Deltas Report attachment: $($global:CliMonDeltasReportName)" `
            -Threshold 2 -Prefix '>>>>'
        $local:finalNotification.AddAttachment(
            $global:CliMonDeltasReportName,
            (Split-Path $global:CliMonDeltasReportName -Leaf),
            "text/plain"
        )
    }
    Write-Debug -Message "Attempting to send the notification." -Threshold 1 -Prefix '>>'
    # Send the email. The result of the process will be used to determine whether or not sending
    #  the notification has failed in any way.
    $global:CliMonEmailFailure = -Not ($local:finalNotification.SendNotification())
    if($local:finalNotification.SmtpError -ne "") {
        $global:CliMonEmailErrorText = $local:finalNotification.SmtpError
    }
}