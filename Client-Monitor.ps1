<#

.SYNOPSIS
Gather, aggregate, and report information from client machines on the domain.
Intended to be run administratively.
.DESCRIPTION
This script will harvest data from client machines on the network using WinRM,
 then compare the differences from the prior report to the most recent one.
Feed the script a text file with the client IPs or hostnames (doesn't matter which) separated line-by-line.
If no file is given, the script will attempt to collect hostnames from the MSAD directory dynamically.
Many variables and settings are "hard-coded" into the script under the "Tweaks" section.
.PARAMETER ClientsList
Optional. The path to a line-delimited file of IPs/hostnames to gather information about.
.PARAMETER DeltasReport
Optional. If included as a switch to the script, a DELTAS text file will be generated in the reports directory.
This will only happen if deltas were actually detected.
.PARAMETER NoNotifications
Optional. If included as a switch to the script, the script will NOT send email notifications at all.
.EXAMPLE
$0 -ClientsList "C:\some_directory\target_clients.txt" -NoNotifications

#>


# Gather parameters called with the application, and set the initial state as needed.
param(
 	[string]$ClientsList = "use-AD-list",
 	[switch]$DeltasReport = $False,
 	[switch]$NoNotifications = $False
)
# Forcibly ignore any errors generated by the script, and do not write them to the CLI.
#$ErrorActionPreference = 'SilentlyContinue'



##################################################
#                     TWEAKS                     #
##################################################
#### Add more initial conditions to the script. Prevents needing many command-line parameters.


# The internal domain suffix of the given/extracted hostnames.
$DomainSuffix = '.thestraightpath.local'
$DomainSuffixRegex = ($DomainSuffix -Replace '\.', '\.') + '$'

# AD username filter; which users to collect when running the Get-ADComputer command (if not supplying a list).
#    Ex: $DomainUserFilter = "(Name -Like 'HOSPITAL-DESKTOP-*') -Or (Name -Like 'FACILITIES-*')"
$DomainUserFilter = "(Name -Like 'wkstn*')"

# The folder in which to store reports for comparison 
$ReportsDirectory = "$ENV:USERPROFILE"

<# How many hours to keep 'reports' in the above directory. After the given hours below,
    reports will be deleted from the directory as the script runs through it.
 #>
$MaxReportRetentionHours = 24

# Where to deliver notifications (which email address).
$NotificationsAddress = 'postmaster@thestraightpath.email'
# The address used as a 'source' on email notifications.
$NotificationsSource = 'Client Monitor <client-monitor@thestraightpath.email>'
# Email notification subject line.
$NotificationsSubject = "Summary of User Environment Changes ($DomainUserFiler)"
# Which mail server to dispatch the notification to/through, and the target relay port.
$NotificationsServer = 'relay.internaldomain.withoutauthentication.com'
$NotificationsServerPort = 25
 
# Generate a notification even when there aren't any changes? Disabled by default.
#  This is more useful for just knowing when the script is running and monitoring if it's actually doing its job.
$NotificationOnNoChange = $True
# A preformatted template for notifications when there is no change to any clients.
$NotificationsBodyOnNoChange = @"
<h1 class='NoChangeHeader'>No Client Changes</h1>`n
<p class='SummaryText'>There were no client changes detected on the network for client machines.</p>
"@

# By default, all notifications are sent as HTML.
$NotificationsAsHTML = $True
# "Advanced" settings for the HTML notifications. These are just class names for certain objects used in the HTML notifs.
$NotificationsHTMLNewValClass = 'NewText'
$NotificationsHTMLPriorValClass = 'PriorText'
# HTML templating for the BODY field of notification emails.
#  [[BODYTEXT]] is replaced dynamically with the generated notification.
$NotificationsHTMLWrapper = @"
<html>
<head>
<style>
	body { word-wrap: break-word; font-size: 12px; }
	table, th, td { border: 1px solid black; }
	th { background-color: #CCCCCC; }
	hr { padding: 0; margin: 10px auto; border: none; }
	p { font-size: 12px; color: black; }
	h1, h2 { padding: 0; margin: 5px 0; }
	h1 { color: #222222; }
	h2 { color: #560D06; }
	.NoChangeHeader { color: #FF2222; padding: 0; margin: 0; }
	.SummaryText { font-size: 16px; color: black; }
	.$NotificationsHTMLPriorValClass { color: #AA2222; font-size: 14px; }
	.$NotificationsHTMLNewValClass { color: #2222AA; font-size: 14px; }
	.SectionHeader { font-size: 20px; font-weight: bold; text-decoration: underline; }
	div.DiffsSection { margin-left: 30px; }
</style>
</head>
<body>
[[BODYTEXT]]
</body>
</html>
"@

<# The events or triggers used for notifications to be dispatched to the notifications address.
 #    This section effectively turns them on/off. Names are descriptive enough for the purpose.
 #    These are all enabled by default.
 #>
$NotificationsTriggers = @{
	ReachabilityChange = $True
	InstalledAppsChange = $True
	ServicesChange = $True
	StoreAppsChange = $True
	StartupAppsChange = $True
	ScheduledTasksChange = $True
}



###################################################
#                    FUNCTIONS                    #
###################################################


# Output information about issues encountered in the script, based on the passed code.
Function Output-Error() {
	param( [Parameter(Mandatory=$true)][int]$errorCode )
	
	$errorInfo = switch($errorCode) {
		1 { 'The path provided for the clientsList parameter does not exist.' }
		2 { 'Could not populate a list of client IP addresses to poll.' }
		3 { "Could not find the given ReportsDirectory: $ReportsDirectory" }
		default { 'Unknown issue.' }
	}
	
	Write-Host "ERROR" -ForegroundColor Red -NoNewLine; Write-Host ": $errorInfo"
	exit $errorCode
}


# Resolve hostnames to the appropriate IP address and return it.
Function Parse-Hostnames() {
	param( [Parameter(Mandatory=$true)][string]$line )
	
	# Strip off double-dashes from hostnames that may be prefixed by one (ex. \\WKSTN107)
	$line = $line -Replace '\\'
	# Use the System DNS library to resolve the hostname properly, then fetch the IP property.
	$address = [System.Net.Dns]::GetHostAddresses("$line").IPAddressToString
	# If the amount of returned IPs is greater than 1, this usually implies a link-local IPv6 was returned.
	#   We don't want that, so instead fetch the first IPv4 address in the array.
	if($address -Is [System.Array] -And $address.length -gt 1) {
		$addressOrig = $address
		foreach($ip in $address) { if($ip -Match "^[0-9\.]+$") {$address = $ip; break} }
		# Forcibly nullify the address field if a matching IPv4 address wasn't found.
		#   This prevents the script from iterating through v6 addresses only and just keeping the address variable the same.
		if($address -eq $addressOrig) { $address = $null }
	}
	
	return $address
}


# Send an email notification to the target address.
#    This wrapper function is only useful because it "injects" the given body into the HTML wrapper (when HTML is enabled).
Function Send-Email() {
	param(
		[Parameter(Mandatory=$True)][string]$RELAYSERVER,
		[Parameter(Mandatory=$True)][int]$RELAYPORT,
		[Parameter(Mandatory=$True)][string]$FROM,
		[Parameter(Mandatory=$True)][string]$TO,
		[Parameter(Mandatory=$True)][string]$SUBJECT,
		[Parameter(Mandatory=$True)][string]$BODY
	)
	
	# Wrap the message body with the HTML template, if NotificationsAsHTML is set to True.
	if($NotificationsAsHTML -eq $True) {
		$BODY = $NotificationsHTMLWrapper -Replace '\[\[BODYTEXT\]\]', "$BODY"
	} else {
		# WARNING!!!!!!!!!
		# This is a sloppy way to remove HTML, as it will destroy all text wrapped in angle brackets.
		#   Perhaps find a cleaner way to go about this, as it prevents plaintext emails from containing these <> pairs.
		$BODY = $BODY -Replace '<tr>', "`n"
		$BODY = $BODY -Replace '(</td>|</th>)', ' | '
		$BODY = $BODY -Replace '<.*?>'
	}
	
	# Dispatch the email to the target server.
	Send-MailMessage -From $FROM -To $TO -Subject $SUBJECT -Body $BODY -SmtpServer $RELAYSERVER `
		-Port $RELAYPORT -BodyAsHtml:$NotificationsAsHTML
	
	# Return the success status of sending the message.
	return $?
}


# Write the report object as a JSON to the target output file.
Function Write-Report() {
	param( [System.Object]$outputJSON = @{} )
	
	$dateTag = Get-Date -UFormat %Y-%m-%d-%H_%M
	$targetFile = $ReportsDirectory + "\Report-$($outputJSON.Hostname)-$dateTag.txt"
	
	# Write the output as a JSON object to the report file (targetFile).
	Write-Output $outputJSON | ConvertTo-JSON -Depth 3 | Out-File -FilePath $targetFile
}


# Given a client hostname, clean reports according to the retention policy.
Function Clean-Reports() {
	param( [string]$clientHostname )
	Write-Host "-- Cleaning reports according to the script retention policy ($MaxReportRetentionHours Hours)."
	$TodaysDate = ((Get-Date -UFormat %Y-%m-%d-%H_%M).toString())
	foreach($report in (Get-ChildItem -Path "$ReportsDirectory\Report-$clientHostname*").Name) {
	$report -Match '-(\d{4}-\d{2}-\d{2}-\d{2}_\d{2}).txt$' | Out-Null
		if((Get-Date-Delta-Hours "$TodaysDate" "$($matches[1])") -ge $MaxReportRetentionHours) {
			Remove-Item -Confirm:$False -Force -Path "$ReportsDirectory\Report-$clientHostname-$($matches[1]).txt"
		}
	}
}


# Gather a report from a report file, return it as a HashTable.
Function Pull-Report() {
	param( [System.String]$hostname, [System.String]$dateString )
	if(Test-Path ($ReportsDirectory + "\Report-$hostname-$dateString.txt")) {
		return (Get-Content ($ReportsDirectory + "\Report-$hostname-$dateString.txt") | ConvertFrom-Json)
	} else { return $null }
}


# Compare two dates and return the difference in dates.
#    Since the dates are coming from filenames (which can't have a ':' character), replace '_' with ':'.
Function Get-Date-Delta-Hours() {
	param( [string]$dateOne, [string]$dateTwo )
	$dateOne = $dateOne -Replace '_', ':'
	$dateTwo = $dateTwo -Replace '_', ':'
	return ((Get-Date "$dateOne") - (Get-Date "$dateTwo")).TotalHours
}


# Template function to modularize comparing and generating deltas.
Function Compare-Deltas() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjChanged = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjNew = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjRemoved = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$Todays = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$Priors = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$TodaysIndex = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$PriorsIndex = @{},
		[Parameter(Mandatory=$True)][System.Array]$CompareProperties = @()
	)
	foreach($item in $TodaysIndex) {
		$isDifferent = $False
		# Get the applications from the hashtable, so it can be compared to the prior report.
		$todayObject = $Todays.$item
		$priorObject = $Priors.$item
		# If the object isn't found in the last report, assume it's a new application.
		if($priorObject -eq $null -Or $priorObject -eq @{}) { continue }
		# Compare DisplayName, DisplayVersion, Publisher, and InstallDate between the two report objects.
		$diffs = $CompareProperties | % { $todayObject.$_ -ne $priorObject.$_ }
		if($diffs.Contains($True)) { $isDifferent = $True }
		# Check if there was a difference caught
		if($isDifferent -eq $True) {
			$CompareProperties | ForEach-Object {
				$todayObject | Add-Member -Name "$($_)_prior" -Value $priorObject.$_ -Type NoteProperty
			}
			$DeltasObjChanged.Add("$item", $todayObject)
		}
	}
	# Compare the indices of PSChildName fields to see if an application was added/removed.
	$indexDiffs = Compare-Object $TodaysIndex $PriorsIndex
	foreach($difference in $indexDiffs) {
		$app = $difference.InputObject
		if($difference.SideIndicator -eq "<=") {
			# The item was added.
			$DeltasObjNew.Add("$app", $Todays.$app)
		} elseif($difference.SideIndicator -eq "=>") {
			# The item was removed.
			$DeltasObjRemoved.Add("$app", $Priors.$app)
		}
	}
}


# Template function to modularize the repetitive task of adding pieces to the email notification.
Function Add-To-Report() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$NewObject = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$RemovedObject = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$ChangedObject = @{},
		[Parameter(Mandatory=$True)][string]$ItemName
	)
	$NOTIFSXN = ""
	$spanNewItem = "<span class='$NotificationsHTMLNewValClass'>"
	$spanPriorItem = "<span class='$NotificationsHTMLPriorValClass'>"
	if($NewObject.Keys.Count -gt 0) {
		$NOTIFSXN += "<span class='SectionHeader'>New $ItemName</span><br />`n"
		foreach($new in $NewObject.Keys) {
			$fillVar = $NewObject.$new | ConvertTo-HTML -Fragment
			$NOTIFSXN += "<div class='DiffsSection'>`n"
			$NOTIFSXN += "$spanNewItem<b>Name</b>: $new</span><br />`n"
			$NOTIFSXN += "$spanNewItem$($fillVar)</span><br />`n"
			$NOTIFSXN += "</div>`n"
		}
	}
	if($RemovedObject.Keys.Count -gt 0) {
		$NOTIFSXN += "<span class='SectionHeader'>Removed $ItemName</span><br />`n"
		foreach($removed in $RemovedObject.Keys) {
			$fillVar = $RemovedObject.$removed | ConvertTo-HTML -Fragment
			$NOTIFSXN += "<div class='DiffsSection'>`n"
			$NOTIFSXN += "$spanPriorItem<b>Name</b>: $removed</span><br />`n"
			$NOTIFSXN += "$spanPriorItem$($fillVar)</span><br />`n"
			$NOTIFSXN += "</div>`n"
		}
	}
	if($ChangedObject.Keys.Count -gt 0) {
		$NOTIFSXN += "<span class='SectionHeader'>Changed $ItemName</span><br />`n"
		foreach($changed in $ChangedObject.Keys) {
			$NOTIFSXN += "<div class='DiffsSection'>`n"
			$NOTIFSXN += "<span style='color:black;font-size:14px;'><b>Name</b>: $changed</span><br />`n"
			# Create two separate objects and merge them together under the same property names.
			#    The objects are split based on the '_prior' suffixes added in the deltas phase of the script.
			$tableNews = @{}; $tablePriors = @{}
			($ChangedObject.$changed | Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike *_prior).Name `
				| Sort-Object | ForEach-Object {
				$tableNewsWrapper = "$spanNewItem" + $ChangedObject.$changed.$_ + "</span>"
				$tableNews.Add($_,$tableNewsWrapper)
				$tablePriorsWrapper = "$spanPriorItem" + $ChangedObject.$changed."$($_)_prior" + "</span>"
				$tablePriors.Add($_, $tablePriorsWrapper)
			}
			# Send the array to the HTML function to output both items under the same headers.
			$tableOut = (@($tablePriors,$tableNews) | ConvertTo-Json | ConvertFrom-Json) | ConvertTo-Html -Fragment
			# Ensure that pieces aren't added to the table as HTML special chars ("&lt;"). Allows for formatting w/ SPAN.
			$finalTable = [System.Web.HttpUtility]::HtmlDecode($tableOut)
			$NOTIFSXN += "$finalTable<br />`n"
			$NOTIFSXN += "</div>`n"
		}
	}
	# Send the finished string back.
	return $NOTIFSXN
}


# Interpret compounding flags using a logical AND. Used for report generation.
Function Interpret-Flags() {
	param(
		[PSCustomObject]$FlagSet = @{}, [int]$GivenValue = 0
	)
	$flagsInfo = ""
	# For each "codeXX" key, strip off the "code" prefix and do a logical AND against the integer to see if that bit is set.
	#    If the bit is set, append the corresponding "codeXX" value from the object onto the return string.
	$FlagSet.Keys | ForEach-Object {
		$code = $_ -Replace "code"
		$isMatch = $GivenValue -BAND $code
		if($isMatch -ne 0) { $flagsInfo += $FlagSet["code$($code)"] + " " }
	}
	return $flagsInfo
}



##################################################
#                      MAIN                      #
##################################################


# Ensure that the ReportsDirectory exists.
if(($ReportsDirectory -eq "") -Or (-Not(Test-Path "$ReportsDirectory"))) { Output-Error(3) }

# Initialize an empty array for the client address/hostname pool.
$clientAddresses = [System.Collections.ArrayList]@()

# Check to see whether a clientsList file was provided to the script.
if($clientsList -eq "use-AD-list") {
	foreach($line in Get-ADComputer -Filter $DomainUserFilter | Select-Object -Property Name) {
		# May want to verify it's not an IP here but the Get-ADComputer
		#    command doesn't seem to return raw IPs in the "Name" property.
		$hostname = $line.Name
		$address = Parse-Hostnames($hostname)
		# Sanity check, ensuring it's not a duplicate and that it exists.
		if($address -eq $null -Or $clientAddresses.Contains($address)) { continue }
		# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
		if(-Not($hostname -Match $DomainSuffixRegex)) { $hostname = $hostname + $DomainSuffix }
		# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
		$localObject = @{IP = ''; Hostname = ''}
		$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
		$clientAddresses += $localObject
	}
} else {
	# Make sure the clientsList file exists. If not, exit.
	if(-NOT(Test-Path $ClientsList)) { Output-Error(1) }

	# Parse each line in the clientsList file.
	foreach($line in Get-Content $ClientsList) {
		# Check to see whether the line matches a hostname or an IPv4 address.
		if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$' -Or $line -Match '\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}\b') {
			$address=$addressOrig=$hostname = $null
			# If it's a hostname, resolve it to an IPv4 address. Otherwise, just capture the IP.
			if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$') {
				$address = Parse-Hostnames($line)
				$hostname = $line -Replace '\\'
			} else {
				$address = $line
				# Get the hostname from the IP, or at least attempt to.Res
				$hostname = [System.Net.Dns]::Resolve([string]$address).HostName
			}
			# If a valid address couldn't be captured, or if the clientAddresses array already contains it,
			#    consider the entry invalid and continue to the next one.
			if($address -eq $null -Or $clientAddresses.Contains($address)) { continue }
			# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
			if((-Not($hostname -Match $DomainSuffixRegex)) -And (-Not($hostname -Match '^LOCALHOST\.?'))) {
				$hostname = $hostname + $DomainSuffix
			}
			# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
			$localObject = @{IP = ''; Hostname = ''}
			$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
			$clientAddresses += $localObject
		}
	}
}




# Check whether or not $clientAddresses has been properly populated. If not, exit.
if($clientAddresses -eq $null -Or $clientAddresses.length -eq 0) { Output-Error(2) }

# Define a base object to hold delta's between yesterday and today.
$deltas = @{}

# Iterate through each client and generate the report.
foreach($client in $clientAddresses) {
	# Aesthetix.
	Write-Host "`n`n"
	
	# Build a base for the newest report object to be generated.
	$FullReport = [ordered]@{
		IP = "$($client.IP)"; Hostname = "$($client.Hostname)"
		IsOnline = $False; Invokable = $False
	}
	# Template an object to track any changes from the most recent report to the newest one.
	$deltasObject = [ordered]@{
		OnlineStatusChange = $False; InvokableChange = $False
		NewServices = @{}; RemovedServices = @{};	ChangedServices = @{}
		NewInstalledApps = @{}; RemovedInstalledApps = @{}; ChangedInstalledApps = @{}
		NewStoreApps = @{}; RemovedStoreApps = @{}; ChangedStoreApps = @{}
		NewStartupApps = @{}; RemovedStartupApps = @{}; ChangedStartupApps = @{}
		NewScheduledTasks = @{}; RemovedScheduledTasks = @{}; ChangedScheduledTasks = @{}
	}
	# Create a "dummy" (reference) object for the null array.
	$deltasObjectDummy = $deltasObject | Select-Object *
	
	# Write the current client to the terminal/host for tracking/debugging.
	Write-Host "Hostname: " -NoNewLine
	Write-Host "$($client.Hostname)" -ForegroundColor Cyan
	Write-Host "IP: " -NoNewLine
	Write-Host "$($client.IP)" -ForegroundColor Cyan
	
	Write-Host "-- Pulling prior report."
	# Collect the top of the list for most recent files/reports matching the given hostname.
	#    If an object isn't returned from the query below, assume there is no "prior" report and act accordingly.
	$LastReportMade = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
		| Sort-Object LastWriteTime | Select-Object -Last 1)
	if($LastReportMade.Length -le 0) {
		Write-Host "**** No prior report found. Setting the comparison object to the default reference."
		$MostRecentReport = $FullReport
	} else {
		$LastReportMade = $LastReportMade[0].Name
		# Bring the previous report and the recent report into the script.
		$DateofLastReport = [Regex]::Matches($LastReportMade, '\d{4}-\d{2}-\d{2}-\d{2}_\d{2}')[0].Value
		$MostRecentReport = Pull-Report "$($client.Hostname)" "$DateofLastReport"
	}
	
	
	# Create a parameters object for Invoke.
	$invokeParams = @{}
	# Is the tested client the local host? If not, set the ComputerName parameter to the client hostname.
	if(-Not($client.Hostname -Match '^LOCALHOST\.?')) {
		$invokeParams.Add("ComputerName", "$($client.Hostname)")
	}
	
	Write-Host "-- Running connectivity tests for WinRM and ICMP."
	
	# Run a basic ICMP ping test against the target to see if it's online. Add it to the report.
	Test-Connection "$($client.Hostname)" -Count 1 | Out-Null
	$FullReport.IsOnline = $?
	
	# Check if the target is invokable at all, i.e. can we run WinRM commands on it?
	Invoke-Command @invokeParams -ScriptBlock { Get-Culture } | Out-Null
	$FullReport.Invokable = $?
	
	# Compare invokability and availability to the last report, as long as this ISN'T the first report.
	if((($FullReport.Invokable -ne $MostRecentReport.Invokable) -Or
			($FullReport.IsOnline -ne $MostRecentReport.IsOnline)) -And
			(-Not($LastReportMade.Length -le 0))) {
			$deltasObject.OnlineStatusChange = ($FullReport.IsOnline -ne $MostRecentReport.IsOnline)
			$deltasObject.InvokableChange = ($FullReport.Invokable -ne $MostRecentReport.Invokable)
			$deltas.Add("$($client.Hostname)", $deltasObject)	
		}
	
	# The target host cannot be invoked. Note this, generate the report, clean old reports, and skip.
	if ($FullReport.Invokable -eq $False) {
		Write-Host "**** WinRM is not active on the target."
		Write-Report($FullReport)
		Clean-Reports "$($client.Hostname)"
		continue
	}
	
	
	<# Harvest an object full of data from the client.
	 #   PSParentPath is using the registry key where we've found the entry, so it shouldn't ever be null.
	 #   PSChildName is the registry key's name. So if there is not any other info, at least get the key name.
	 #>
	 
	Write-Host "-- Collecting information about the target machine."
	
	
	# -----------------------------------------
	# Collect installed applications at multiple layers.
	$reportInstalledApps = Invoke-Command @invokeParams -ScriptBlock {
		$installedAppsObject = @{}
		# Installed applications on the local machine.
		$HKLM = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
		$HKCU = Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
		$WOW6432 = Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*
		foreach($app in $HKLM) {
			$installedAppsObject.Add("$($app.PSChildName)_HKLM", `
				($HKLM | Where-Object -Property PSChildName -eq "$($app.PSChildName)" `
					| Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation `
					| ConvertTo-Json | ConvertFrom-Json))
		}
		# Same as above but only apps installed for the "current user".
		foreach($app in $HKCU) {
			$installedAppsObject.Add("$($app.PSChildName)_HKCU", `
				($HKCU | Where-Object -Property PSChildName -eq "$($app.PSChildName)" `
					| Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation `
					| ConvertTo-Json | ConvertFrom-Json))
		}
		# 32-to-64-bit installed applications.
		foreach($app in $WOW6432) {
			$installedAppsObject.Add("$($app.PSChildName)_6432Node", `
				($WOW6432	| Where-Object -Property PSChildName -eq "$($app.PSChildName)" `
					| Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, InstallLocation `
					| ConvertTo-Json | ConvertFrom-Json))
		}
		return $installedAppsObject
	}
	# Index the PSChildName fields from each fetched application as a key index.
	$installedAppsIndex = Invoke-Command @invokeParams -ScriptBlock {
		#$installedAppsArray = [System.Collections.ArrayList]@()
		$installedAppsArray = [System.Collections.ArrayList]@()
		(Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*) `
			| ForEach-Object { $installedAppsArray += "$($_.PSChildName)_HKLM" }
		(Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*) `
			| ForEach-Object { $installedAppsArray += "$($_.PSChildName)_HKCU" }
		(Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*) `
			| ForEach-Object { $installedAppsArray += "$($_.PSChildName)_6432Node" }
		return $installedAppsArray
	}
	# FIX (used in all indexing): PowerShell liked to return object references in the array instead of STRINGS.
	#    So the generated JSON was spitting out objects unexpectedly for any REMOTE workstation. This cheap, hacky
	#    typecast below should fix it and isn't too costly.
	$installedAppsIndexFIX = @(); $installedAppsIndexFIX += $installedAppsIndex | ForEach-Object { [string]$_ }
	# Add them to the report.
	$FullReport.Add("InstalledAppsIndex", $installedAppsIndexFIX)
	$FullReport.Add("InstalledApps", $reportInstalledApps)
	
		
	# -----------------------------------------
	# Harvest Windows Store-based applications.
	$reportStoreApps = Invoke-Command @invokeParams -ScriptBlock {
		$storeAppsObject = @{}
		$appsList = Get-AppxPackage
		foreach($app in $appsList) {
			$storeAppsObject.Add("$($app.Name)_$($app.Architecture)", `
				($appsList | Where-Object -Property Name -eq "$($app.Name)" `
					| Where-Object -Property Architecture -eq "$($app.Architecture)" `
					| Select-Object InstallLocation, Status, PublisherId | ConvertTo-Json | ConvertFrom-Json))
		}
		return $storeAppsObject
	}
	# Get an index of store apps based on the format NAME_ARCHITECTURE (e.g. Microsoft.Net.4.0_x86)
	$storeAppsIndex = Invoke-Command @invokeParams -ScriptBlock {
		$storeAppsArray = [System.Collections.ArrayList]@()
		Get-AppxPackage | ForEach-Object { $storeAppsIndex += "$($_.Name)_$($_.Architecture)" }
		return $storeAppsArray
	}
	$storeAppsIndexFIX = @(); $storeAppsIndexFIX += $sotreAppsIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("StoreAppsIndex", $storeAppsIndexFIX)
	$FullReport.Add("StoreApps", $reportStoreApps)
	
	
	# -----------------------------------------
	# Harvest startup applications.
	$reportStartupApps = Invoke-Command @invokeParams -ScriptBlock {
		$startupAppsObject = @{}
		$w32StartupCmd = Get-CimInstance Win32_StartupCommand
		foreach($startupapp in $w32StartupCmd) {
			$startupAppsObject.Add("$($startupapp.Name)_$($startupapp.User)", `
				($w32StartupCmd | Where-Object -Property Name -eq "$($startupapp.Name)" `
					| Where-Object -Property User -eq "$($startupapp.User)" `
					| Select-Object Command, Location, User | ConvertTo-Json | ConvertFrom-Json))
		}
		return $startupAppsObject
	}
	# Index StartupApps by the "Name" key.
	$startupAppsIndex = Invoke-Command @invokeParams -ScriptBlock {
		$startupAppsArray = [System.Collections.ArrayList]@()
		Get-CimInstance Win32_StartupCommand | ForEach-Object { $startupAppsArray += "$($_.Name)_$($_.User)" }
		return $startupAppsArray
	}
	$startupAppsIndexFIX = @(); $startupAppsIndexFIX += $startupAppsIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("StartupAppsIndex", $startupAppsIndexFIX)
	$FullReport.Add("StartupApps", $reportStartupApps)
		
	
	# -----------------------------------------
	# Get a list of services (all of them).
	$reportServices = Invoke-Command @invokeParams -ScriptBlock {
		$svcObject = @{}
		$svcs = Get-Service
		foreach($service in $svcs) {
			$svcObject.Add("$($service.DisplayName)_$($service.Name)", `
				($svcs | Where-Object -Property DisplayName -eq "$($service.DisplayName)" `
					| Where-Object -Property Name -eq "$($service.Name)" `
					| Select-Object DisplayName, ServiceName, ServiceType, StartType, Status | ConvertTo-Json | ConvertFrom-Json))
		}
		return $svcObject
	}
	# Get an index of all "DisplayName_Name" unique keys.
	$servicesIndex = Invoke-Command @invokeParams -ScriptBlock {
		$svcNameArray = [System.Collections.ArrayList]@()
		Get-Service | ForEach-Object { $svcNameArray += "$($_.DisplayName)_$($_.Name)" }
		return $svcNameArray
	}
	$servicesIndexFIX = @(); $servicesIndexFIX += $servicesIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("ServicesIndex", $servicesIndexFIX)
	$FullReport.Add("Services", $reportServices)
	
	
	# -----------------------------------------
	# Get scheduled tasks and jobs.
	$reportTasks = Invoke-Command @invokeParams -ScriptBlock {
		$taskObject = @{}
		$taskList = Get-ScheduledTask
		foreach($task in $taskList) {
			$taskObject.Add("$($task.URI)", `
				($taskList | Where-Object -Property URI -eq "$($task.URI)" `
					| Select-Object TaskName, Author, SecurityDescriptor, TaskPath | ConvertTo-Json | ConvertFrom-Json))
		}
		return $taskObject
	}
	# Get an index of all "TaskName" keys.
	$scheduledTasksIndex = Invoke-Command @invokeParams -ScriptBlock {
		$taskURIArray = [System.Collections.ArrayList]@()
		Get-ScheduledTask | ForEach-Object { $taskURIArray += "$($_.URI)" }
		return $taskURIArray
	}
	$scheduledTasksIndexFIX = @(); $scheduledTasksIndexFIX += $scheduledTasksIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("ScheduledTasksIndex", $scheduledTasksIndexFIX)
	$FullReport.Add("ScheduledTasks", $reportTasks)
	
	
	# -----------------------------------------
	# Generate the final report file with all of the information.
	Write-Report($FullReport)
	
	
	#####################################################################
	# COMPARISON SECTION.
	# All comparisons will use the most recent report as the reference object, comparing AGAINST the prior report.
	Write-Host "-- Comparing the differences between the generated report and the prior report."
	# Stop here if the file is the first in the line of reports.
	if($LastReportMade.Length -le 1) {
		Write-Host "**** Client does not have a prior report to provide a comparison to the new report. Skipping comparisons..."
		continue
	}
	# HashTable -> JSON -> HashTable, so that it matches the conversion that the $MostRecentReport variable went through.
	$FullReportIntermediate = $FullReport | ConvertTo-Json -Depth 3
	$TodaysReport = $FullReportIntermediate | ConvertFrom-Json
	
	# -----------------------------------------
	# Compare Services.
	Compare-Deltas `
		-CompareProperties @("DisplayName", "ServiceName", "ServiceType", "StartType", "Status") `
		-DeltasObjChanged $deltasObject.ChangedServices `
		-DeltasObjNew $deltasObject.NewServices `
		-DeltasObjRemoved $deltasObject.RemovedServices `
		-Todays $TodaysReport.Services -TodaysIndex $TodaysReport.ServicesIndex `
		-Priors $MostRecentReport.Services -PriorsIndex $MostRecentReport.ServicesIndex
	
	# -----------------------------------------
	# Compare ScheduledTasks.
	Compare-Deltas `
		-CompareProperties @("TaskName", "TaskPath", "Author", "SecurityDescriptor") `
		-DeltasObjChanged $deltasObject.ChangedScheduledTasks `
		-DeltasObjNew $deltasObject.NewScheduledTasks `
		-DeltasObjRemoved $deltasObject.RemovedScheduledTasks `
		-Todays $TodaysReport.ScheduledTasks -TodaysIndex $TodaysReport.ScheduledTasksIndex `
		-Priors $MostRecentReport.ScheduledTasks -PriorsIndex $MostRecentReport.ScheduledTasksIndex
	
	# -----------------------------------------
	# Compare StoreApps.
	Compare-Deltas `
		-CompareProperties @("InstallLocation", "Status", "PublisherId") `
		-DeltasObjChanged $deltasObject.ChangedStoreApps `
		-DeltasObjNew $deltasObject.NewStoreApps `
		-DeltasObjRemoved $deltasObject.RemovedStoreApps `
		-Todays $TodaysReport.StoreApps -TodaysIndex $TodaysReport.StoreAppsIndex `
		-Priors $MostRecentReport.StoreApps -PriorsIndex $MostRecentReport.StoreAppsIndex
	
	# -----------------------------------------
	# Compare StartupApps.
	Compare-Deltas `
		-CompareProperties @("Command", "Location", "User") `
		-DeltasObjChanged $deltasObject.ChangedStartupApps `
		-DeltasObjNew $deltasObject.NewStartupApps `
		-DeltasObjRemoved $deltasObject.RemovedStartupApps `
		-Todays $TodaysReport.StartupApps -TodaysIndex $TodaysReport.StartupAppsIndex `
		-Priors $MostRecentReport.StartupApps -PriorsIndex $MostRecentReport.StartupAppsIndex
	
	# -----------------------------------------
	# Compare InstalledApps.
	Compare-Deltas `
		-CompareProperties @("DisplayName", "DisplayVersion", "Publisher", "InstallDate", "InstallLocation") `
		-DeltasObjChanged $deltasObject.ChangedInstalledApps `
		-DeltasObjNew $deltasObject.NewInstalledApps `
		-DeltasObjRemoved $deltasObject.RemovedInstalledApps `
		-Todays $TodaysReport.InstalledApps -TodaysIndex $TodaysReport.InstalledAppsIndex `
		-Priors $MostRecentReport.InstalledApps -PriorsIndex $MostRecentReport.InstalledAppsIndex
		
	
	# Compare the AMOUNT of keys in each item within the deltasObject against its blank "dummy" variable.
	# If the amount of keys differs in any way that means some changes were added and the deltas must be noted.
	#  NOTE: Don't want to compare "OnlineStatusChange" and "InvokableChange" since these aren't object containers.
	$deltasOnDeltasOnDeltas = $deltasObjectDummy.Keys | Foreach-Object {
		if($_ -eq "OnlineStatusChange" -Or $_ -eq "InvokableChange") { $True }
		else { $deltasObjectDummy[$_].Count -eq $deltasObject[$_].Count }
	}
	# If a change was detected, add the $deltasObject onto the primary $deltas variable with the
	#    client hostname to track each change.
	if(
		($deltasOnDeltasOnDeltas.Contains($False)) -Or
		($deltasObject.InvokableChange -eq $True) -Or
		($deltasObject.OnlineStatusChange -eq $True)
	) { $deltas.Add("$($client.Hostname)", $deltasObject) | Out-Null }
	
	
	#####################################################################
	# CLEANUP SECTION.
	# Clean up the script and reports according to the retention policy.
	Clean-Reports "$($client.Hostname)"
}




####################################################################################
# NOTIFICATION GENERATION
# Use the notification format that's easily replaceable (see Tweaks section).

# Firstly, check if the $deltas object contains any keys from the operations above.
#    If not, don't bother generating a notification unless specified in the configuration.
if($deltas.Count -gt 0 -And $NoNotifications -eq $False) {
	$NOTIFBODY = "<h1>Summary of Environment Changes</h1>`n`n"
	$NOTIFBODY += "<p class='SummaryText'>There were changes detected on the network for the following clients. "
	$NOTIFBODY += "Anything in <span class='$NotificationsHTMLPriorValClass'>red</span> is a removed property, "
	$NOTIFBODY += "and anything in <span class='$NotificationsHTMLNewValClass'>blue</span> has been added.</p>`n`n"
	# Now process the information from the deltas and generate a notification if needed.
	foreach($client in $deltas.Keys) {
		# Set the $clientDeltas object equal to the per-client changes so they can be iterated.
		$clientDeltas = $deltas.$client
		# Inject the hostname of the client into the email digest.
		$NOTIFBODY += "`n`n<hr /><h2>$client</h2>`n"
		
		<# First thing to do is check that the Invokable or Online statuses have changed, because if they have,
		 #    the rest of the object won't matter to parse.
		 #    This is noteworthy because it prevents a host from coming back online after an "outage" and having ALL
		 #    of its Services, Apps, etc. being registered as "new" in notifications.
		 # NOTE: A drawback to this is a host coming back online after an outage and having NEW apps on it since the last
		 #        test while the target was online previously.
		 #>
		if((($clientDeltas.OnlineStatusChange -eq $True) -Or ($clientDeltas.InvokableChange -eq $True)) -And
			($NotificationsTriggers.ReachabilityChange -eq $True)) {
			# Read the newly-generated report back in just for this, to get the previous online & invokable statuses.
			$TodaysReport = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
				| Sort-Object LastWriteTime | Select-Object -Last 1)[0].Name
			$TodaysReport = Get-Content "$ReportsDirectory\$TodaysReport" | ConvertFrom-Json
			if($clientDeltas.OnlineStatusChange -eq $True) {
				$newStatus = -Not $TodaysReport.IsOnline
				$NOTIFBODY += "<span class='SectionHeader'>Client Online</span><br />`n<div class='DiffsSection'>`n"
				$NOTIFBODY += "<span class='$NotificationsHTMLPriorValClass'>$($TodaysReport.IsOnline)</span><br />`n"
				$NOTIFBODY += "<span class='$NotificationsHTMLNewValClass'>$newStatus</span><br />`n"
			} elseif ($clientDeltas.InvokableChange -eq $True) {
				$newStatus = -Not $TodaysReport.Invokable
				$NOTIFBODY += "<span class='SectionHeader'>Invokable</span><br />`n<div class='DiffsSection'>`n"
				$NOTIFBODY += "<span class='$NotificationsHTMLPriorValClass'>$($TodaysReport.Invokable)</span><br />`n"
				$NOTIFBODY += "<span class='$NotificationsHTMLNewValClass'>$newStatus</span><br />`n"
			}
			$NOTIFBODY += "</div>"
			# Move to the next client. This is all we need from the current one.
			continue
		}
		
		# Now that the reachability flags are reviewed, the rest should be easy variable-matching and iterating keys.
		# This process is repeated almost identically for each object and can probably be modularized later to trim fat.
		#  --> Get counts of keys in each delta field.
		#  ----> Count > 0 ? add-to-report : ignore
		# "New" and "Removed" apps don't need a "comparison" section.
		
		# -----------------------------------------
		# INSTALLED APPLICATIONS
		if($NotificationsTriggers.InstalledAppsChange -eq $True) {
			$NOTIFBODY += Add-To-Report `
				-NewObject $clientDeltas.NewInstalledApps -RemovedObject $clientDeltas.RemovedInstalledApps `
				-ChangedObject $clientDeltas.ChangedInstalledApps -ItemName "Installed Applications"
		}
	
	# -----------------------------------------
		# SERVICES
		$STATUS_CODES = @{
			code1="STOPPED"; code2="START-PENDING"; code3="STOP-PENDING"
			code4="RUNNING"; code5="CONTINUE"; code6="PAUSE-PENDING"; code7="PAUSED"
			code=""
		}
		$START_TYPES = @{
			code0="BOOT"; code1="SYSTEM"; code2="AUTOMATIC"
			code3="MANUAL"; code4="DISABLED"
			code=""
		}
		# These are FLAGS (multiple values that can be compounded).
		$SERVICE_TYPES = @{
			code1="KERNEL-DRIVER"; code2="FS-DRIVER"; code4="HW-DRIVER"
			code8="FS-STARTUP-DRIVER"; code16="NORMAL"; code32="SHARED"; code256="INTERACTIVE"
			code=""
		}
		if($NotificationsTriggers.ServicesChange -eq $True) {
			# Change numeric codes to their equivalent status.
			$clientDeltas.ChangedServices.Keys | ForEach-Object {
				$statuscode = $clientDeltas.ChangedServices.$_.Status
				$startcode = $clientDeltas.ChangedServices.$_.StartType
				$svccode = $clientDeltas.ChangedServices.$_.ServiceType
				$clientDeltas.ChangedServices.$_.Status = $STATUS_CODES["code$($statuscode)"]
				$clientDeltas.ChangedServices.$_.StartType = $START_TYPES["code$($startcode)"]
				$clientDeltas.ChangedServices.$_.ServiceType = `
					(Interpret-Flags -FlagSet $SERVICE_TYPES -GivenValue $svccode).TrimEnd()
				$statuscode = $clientDeltas.ChangedServices.$_.Status_prior
				$startcode = $clientDeltas.ChangedServices.$_.StartType_prior
				$svccode = $clientDeltas.ChangedServices.$_.ServiceType_prior
				$clientDeltas.ChangedServices.$_.Status_prior = $STATUS_CODES["code$($statuscode)"]
				$clientDeltas.ChangedServices.$_.StartType_prior = $START_TYPES["code$($startcode)"]
				$clientDeltas.ChangedServices.$_.ServiceType_prior = `
					(Interpret-Flags -FlagSet $SERVICE_TYPES -GivenValue $svccode).TrimEnd()
			}
			$NOTIFBODY += Add-To-Report `
				-NewObject $clientDeltas.NewServices -RemovedObject $clientDeltas.RemovedServices `
				-ChangedObject $clientDeltas.ChangedServices -ItemName "Services"
		}
		
		# -----------------------------------------
		# STORE APPS
		$SA_STATUS_CODES = @{
			code0="OK"; code1="LICENSE-ISSUE"; code2="MODIFIED"; code4="TAMPERED"
			code8="DISABLED"; code16="PACKAGE-OFFLINE"; code32="DEPLOYMENT"
			code64="DEPENDENCY-ISSUE"; code128="DATA-OFFLINE"; code256="PARTIALLY-STAGED"
			code512="NOT-AVAILABLE"; code1024="SERVICING"; code2048="NEED-REMEDIATION"
			code=""
		}
		if($NotificationsTriggers.StoreAppsChange -eq $True) {
			$clientDeltas.ChangedStoreApps.Keys | ForEach-Object {
				$clientDeltas.ChangedStoreApps.$_.Status = `
					(Interpret-Flags -FlagSet $SA_STATUS_CODES -GivenValue $statuscode).TrimEnd()
				$statuscode = $clientDeltas.ChangedStoreApps.$_.Status_prior
				$clientDeltas.ChangedStoreApps.$_.Status_prior = `
					(Interpret-Flags -FlagSet $SA_STATUS_CODES -GivenValue $statuscode).TrimEnd()
			}
			$NOTIFBODY += Add-To-Report `
				-NewObject $clientDeltas.NewStoreApps -RemovedObject $clientDeltas.RemovedStoreApps `
				-ChangedObject $clientDeltas.ChangedStoreApps -ItemName "Store Apps"
		}
		
		# -----------------------------------------
		# STARTUP APPS
		if($NotificationsTriggers.StartupAppsChange -eq $True) {
			$NOTIFBODY += Add-To-Report `
				-NewObject $clientDeltas.NewStartupApps -RemovedObject $clientDeltas.RemovedStartupApps `
				-ChangedObject $clientDeltas.ChangedStartupApps -ItemName "Startup Apps"
		}
		
		# -----------------------------------------
		# SCHEDULED TASKS APPS
		if($NotificationsTriggers.ScheduledTasksChange -eq $True) {
			$NOTIFBODY += Add-To-Report `
				-NewObject $clientDeltas.NewScheduledTasks -RemovedObject $clientDeltas.RemovedScheduledTasks `
				-ChangedObject $clientDeltas.ChangedScheduledTasks -ItemName "Scheduled Tasks"
		}
	}
	# Send the compiled notification to the target address using the SMTP info provided at the top of the script.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NOTIFBODY
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to $NotificationsAddress has failed!"
	}
} elseif($NotificationOnNoChange -eq $True -And $NoNotifications -eq $False) {
	# Send an email (if enabled) to notify that no changes were detected.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NotificationsBodyOnNoChange
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to $NotificationsAddress has failed!"
	}
}




####################################################################################
# FINAL CLEANUP & MISC TASKS

# Generate a text file to track differences. This is optional based on whether the parameter to do so is given.
if($DeltasReport -eq $True -And $deltas.Count -gt 0) {
	$currentTime = (Get-Date -UFormat %Y-%m-%d-%H_%M).toString()
	Write-Output $deltas | ConvertTo-Json -Depth 3 | Out-File "$ReportsDirectory\DELTAS-$currentTime.txt"
} elseif($DeltasReport -eq $False -And $deltas.Count -le 0) {
	Write-Host "No changes were detected across the targeted clients."
}

# Notification that the script is finished.
Write-Host "`n`n*****" -NoNewLine
Write-Host " JOB COMPLETE " -NoNewLine -ForegroundColor Green
Write-Host "*****"

# Return $deltas in case the person running the script would like to manipulate the given differences.
return $deltas