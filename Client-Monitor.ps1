<#

.SYNOPSIS
Gather, aggregate, and report information from client machines on the domain.
Intended to be run administratively.
.DESCRIPTION
This script will harvest data from client machines on the network using WinRM,
 then compare the differences from the prior report to the most recent one.
Feed the script a text file with the client IPs or hostnames (doesn't matter which) separated line-by-line.
If no file is given, the script will attempt to collect hostnames from the MSAD directory dynamically.
Many variables and settings are "hard-coded" into the script under the "Tweaks" section.
.PARAMETER ClientsList
Optional. The path to a line-delimited file of IPs/hostnames to gather information about.
.PARAMETER DeltasReport
Optional. If included as a switch to the script, a DELTAS text file will be generated in the reports directory.
This will only happen if deltas were actually detected.
.PARAMETER NoNotifications
Optional. If included as a switch to the script, the script will NOT send email notifications at all.
.PARAMETER BCC
Optional. If included, will BCC the target address(es) in the generated notifications.
.PARAMETER NoMini
Optional. If included, the reports generated by the script will NOT be compress/mini-fied, so they become more readable.
Note: Delta reports are NEVER mini-fied.
.PARAMETER SmtpCredential
Optional. In order to use this, a PowerShell credentials object should be passed to the script.
Please refer to the README on the GitHub repo for more information on using this parameter.
.EXAMPLE
$0 -ClientsList ".\target_clients.txt" -BCC "Test Name <tname@test.com>, Second Recip <srecip@testing.com>"

#>


# Gather parameters called with the application, and set the initial state as needed.
param(
 	[string]$ClientsList = "use-AD-list",
 	[switch]$DeltasReport = $False,
 	[switch]$NoNotifications = $False,
 	[string]$BCC = "",
 	[switch]$NoMini = $False
 	[switch]$NoMini = $False,
 	[PSCredential]$SmtpCredential = $null
)
# Forcibly ignore any errors generated by the script, and do not write them to the CLI.
#$ErrorActionPreference = 'SilentlyContinue'
$NoMiniSet = (-Not $NoMini)



##################################################
#                     TWEAKS                     #
##################################################
#### Add more initial conditions to the script. Prevents needing many command-line parameters.


# The internal domain suffix of the given/extracted hostnames.
$DomainSuffix = '.thestraightpath.local'
$DomainSuffixRegex = ($DomainSuffix -Replace '\.', '\.') + '$'

# AD username filter; which users to collect when running the Get-ADComputer command (if not supplying a list).
#    Ex: $DomainUserFilter = "(Name -Like 'HOSPITAL-DESKTOP-*') -Or (Name -Like 'FACILITIES-*')"
$DomainUserFilter = "(Name -Like 'wkstn*')"

# The folder in which to store reports for comparison 
$ReportsDirectory = "$ENV:USERPROFILE"

<# How many hours to keep 'reports' in the above directory. After the given hours below,
    reports will be deleted from the directory as the script runs through it.
 #>
$MaxReportRetentionHours = 24

# Where to deliver notifications (which email address).
$NotificationsAddress = 'postmaster@thestraightpath.email'
# The address used as a 'source' on email notifications.
$NotificationsSource = 'Client Monitor <client-monitor@thestraightpath.email>'
# Email notification subject line.
$NotificationsSubject = "Summary of User Environment Changes"
# Which mail server to dispatch the notification to/through, and the target relay port.
$NotificationsServer = 'relay.internaldomain.withoutauthentication.com'
$NotificationsServerPort = 25
 
# Generate a notification even when there aren't any changes? Disabled by default.
#  This is more useful for just knowing when the script is running and monitoring if it's actually doing its job.
$NotificationOnNoChange = $True
# A preformatted template for notifications when there is no change to any clients.
$NotificationsBodyOnNoChange = @"
<h1 class='NoChangeHeader'>No Client Changes</h1>`n
<p class='SummaryText'><b><u>QUERY</u></b>: '$DomainUserFilter'</p>`n
<p class='SummaryText'>There were no changes to display for the client machines.<br />`n
Either the items that <i>did</i> change were filtered, or nothing has changed at all.</p>
"@

# By default, all notifications are sent as HTML.
$NotificationsAsHTML = $True
# "Advanced" settings for the HTML notifications. These are just class names for certain objects used in the HTML notifs.
#    They're important to define, less important to change.
$NotificationsHTMLNewValClass = 'NewText'
$NotificationsHTMLPriorValClass = 'PriorText'
$NotificationsHTMLDiffValClass = 'DifferentText'
# HTML templating for the BODY field of notification emails.
#  [[BODYTEXT]] is replaced dynamically with the generated notification.
$NotificationsHTMLWrapper = @"
<html>
<head>
<style>
	body { word-wrap: break-word; font-size: 12px; }
	table { width: 100%; overflow-x: auto; }
	table, th, td { border: 1px solid black; }
	th, td { text-align: left; padding: 10px; }
	th { background-color: #CCCCCC; }
	tr:hover, td:hover { background-color: #EDEDED; }
	hr { padding: 0; margin: 10px auto; border: none; }
	p { font-size: 12px; color: black; }
	h1, h2 { padding: 0; margin: 5px 0; }
	h1 { color: #222222; }
	h2 { color: #560D06; }
	.NoChangeHeader { color: #FF2222; padding: 0; margin: 0; }
	.SummaryText { font-size: 16px; color: black; }
	.$NotificationsHTMLPriorValClass { color: #AA2222; font-size: 14px; }
	.$NotificationsHTMLNewValClass { color: #2222AA; font-size: 14px; }
	.$NotificationsHTMLDiffValClass { font-weight: bold; font-style: italic; }
	.SectionHeader { font-size: 20px; font-weight: bold; text-decoration: underline; }
	div.DiffsSection { margin-left: 20px; }
</style>
</head>
<body>
[[BODYTEXT]]
</body>
</html>
"@

# The header/upper section used in notifications that will have some changes noted for clients.
#    The actual Body text is appended to this value later, forming the [[BODYTEXT]] for the HTML wrapper.
$NotificationsChangesBodyHeader = "<h1>Summary of Environment Changes</h1>`n`n"
$NotificationsChangesBodyHeader += "<p class='SummaryText'><b><u>QUERY</u></b>: '$DomainUserFilter'</p>`n"
$NotificationsChangesBodyHeader += "<p class='SummaryText'>There were changes detected on the network for the following clients. "
$NotificationsChangesBodyHeader += "Anything in <span class='$NotificationsHTMLPriorValClass'>red</span> is a removed property, "
$NotificationsChangesBodyHeader += "and anything in <span class='$NotificationsHTMLNewValClass'>blue</span> has been added.</p>`n`n"


<# Tracked values across each given category. These values are used in the "Select-Object" method on the queries
 #    for each item in the set returned per category, and also in the later comparisons.
 # NOTE: Do not include "special" fields used in the script below. Off-limits field include:
 #    STOREAPPS : PackageUserInformation
 #>
$TrackedValues = @{
	InstalledApps = @("DisplayName", "DisplayVersion", "Publisher", "InstallDate", "InstallLocation")
	Services = @("DisplayName", "ServiceName", "ServiceType", "StartType", "Status")
	StoreApps = @("Name", "Architecture", "InstallLocation", "Status", "PublisherId", "PackageFullName")
	StartupApps = @("Command", "Location", "User")
	ScheduledTasks = @("TaskName", "TaskPath", "Author", "SecurityDescriptor")
}


<# The events or triggers used for notifications to be dispatched to the notifications address.
 #    This section effectively turns them on/off. Names are descriptive enough for the purpose.
 #    These are all enabled by default.
 #>
$NotificationsTriggers = @{
	ReachabilityChange = $True
	InstalledAppsChange = $True
	ServicesChange = $True
	StoreAppsChange = $True
	StartupAppsChange = $True
	ScheduledTasksChange = $True
}

# Is the filter a blacklist? If so, anything added to the object in the target sections is selectively FILTERED OUT.
#    Conversely, if set to False (acting as a whitelist) then only the given values/patterns will be allowed.
$NotificationsFiltersBlacklist = $True
# Whether or not to show the text of the below tweak in the generated notification, when an item is filtered out. Default off.
$NotificationsShowFilteredItem = $False
# Set the mode for filtering to regex. This will cause the strings entered below to be run against the -Match operator
#    rather than the -Like operator. Do not change this setting unless you'd like to use regex filtering instead.
$NotificationFiltersRegex = $False
# A string (HTML formatting optional) to insert when an item is filtered from a notification, if the above value is $True.
$NotificationsFilteredIndicator =  "<div class='DiffsSection'><b>[FilteredItem]</b><br /><br /></div>`n"
<# Define strings (wildcards supported) which should be white/black-listed for allowance into notifications.
 #    The strings are ARRAYS of patterns. For example: @("win*","*micro*") will filter anything starting with "win" and
 #    anything containing the substring "micro".
 # NOTE: These filters apply to ALL data fields in the category and should be used with caution.
 #    If a service changes from "Group Policy Service" to "Microsoft GPO Svc" for example, and there's a "micro*" filter,
 #    you won't know about the change.
 #>
$NotificationsFilters = @{
	InstalledApps = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	Services = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	StoreApps = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	StartupApps = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	ScheduledTasks = @{
		New = @()
		Removed = @()
		Changed = @()
	}
}


# Enable/Disable filename tracking on the system. This allows for greater control over environment monitoring.
$FilenameTracking = $True
# How many files to show in the "most recent" view in the notification/report.
$TrackedFilenameViewLimit = 4
# Define which places on the target machine's disk should be checked. Predefined values should be self-explanatory.
$TrackedFilenameLocations = @{
	UserProfiles = $True  # Uses all directories in the Users folder, typically "C:\Users", and iterates on a per-uses basis.
	SystemFiles = $False  # NOT RECOMMENDED! Uses %SYSTEMROOT%, i.e. "C:\Windows" in most cases.
	ProgramData = $False  # NOT RECOMMENDED! Uses %ProgramData%, i.e. "C:\ProgramData" in most cases.
}
# Custom directories to check for certain filename patterns. Key/Value pairs are [DIRECTORY]=[RECURSE?] respectively.
#    So setting "C:\Windows" = $True would order the script to RECURSIVELY check "C:\Windows" for the filename patterns.
#     ^ that's not a good idea to do, so I've set recursion to $False below.
$TrackedFilenameLocationsCustom = @{
#	"C:\Windows\System32" = $False
#	"C:\fakeplace" = $True
}
<# The filename patterns (regex) to track across all of the above directories. Note that these regexes allow you full control
 #    and are NOT restricted to just filename extension. So take care with this, as entering '.exe' for example will pick up
 #    the filename 'processexecute.txt' because the regex isn't specifying the ^ or $ characters and isn't escaping the .
 # ALSO: The threshold at which the delta will be included in the report. For example, a threshold of 10 means 
 #    that if 10 MORE files than the last check are detected, then it should be rolled into the notification for changes.
 #
 # So the format here is ---> [REGEX] = [THRESHOLD]
 #>
$TrackedFilenamePatterns = @{
	'\.exe$' = 2
	'\.bat$' = 2
	'\.enc(rypt(ed)?)?' = 10
	'\.txt$' = 5
	'\.ini$' = 2
}



###################################################
#                    FUNCTIONS                    #
###################################################


# Output information about issues encountered in the script, based on the passed code, and exit with the given code.
Function Output-Error() {
	param( [Parameter(Mandatory=$true)][int]$errorCode )
	$errorInfo = switch($errorCode) {
		1 { 'The path provided for the clientsList parameter does not exist.' }
		2 { 'Could not populate a list of client IP addresses to poll.' }
		3 { "Could not find the given ReportsDirectory: $ReportsDirectory" }
		4 { 'Could not get a list of workstations using Get-ADComputer. Please supply a ClientsList to the script if needed.' }
		default { 'Unknown issue.' }
	}
	Write-Host "ERROR" -ForegroundColor Red -NoNewLine; Write-Host ": $errorInfo"
	exit $errorCode
}


# Resolve hostnames to the appropriate IP address and return it.
Function Parse-Hostnames() {
	param( [Parameter(Mandatory=$true)][string]$line )
	# Strip off double-dashes from hostnames that may be prefixed by one (ex. \\WKSTN107)
	$line = $line -Replace '\\'
	# Use the System DNS library to resolve the hostname properly, then fetch the IP property.
	$address = [System.Net.Dns]::GetHostAddresses("$line").IPAddressToString
	# If the amount of returned IPs is greater than 1, this usually implies a link-local IPv6 was returned.
	#   We don't want that, so instead fetch the first IPv4 address in the array.
	if($address -Is [System.Array] -And $address.length -gt 1) {
		$addressOrig = $address
		foreach($ip in $address) { if($ip -Match "^[0-9\.]+$") {$address = $ip; break} }
		# Forcibly nullify the address field if a matching IPv4 address wasn't found.
		#   This prevents the script from iterating through v6 addresses only and just keeping the address variable the same.
		if($address -eq $addressOrig) { $address = $null }
	}
	return $address
}


# Send an email notification to the target address.
#    This wrapper function is only useful because it "injects" the given body into the HTML wrapper (when HTML is enabled).
Function Send-Email() {
	param(
		[Parameter(Mandatory=$True)][string]$RELAYSERVER,
		[Parameter(Mandatory=$True)][int]$RELAYPORT,
		[Parameter(Mandatory=$True)][string]$FROM,
		[Parameter(Mandatory=$True)][string]$TO,
		[Parameter(Mandatory=$True)][string]$SUBJECT,
		[Parameter(Mandatory=$True)][string]$BODY
	)
	# Wrap the message body with the HTML template, if NotificationsAsHTML is set to True.
	if($NotificationsAsHTML -eq $True) {
		$BODY = $NotificationsHTMLWrapper -Replace '\[\[BODYTEXT\]\]', "$BODY"
	} else {
		# WARNING!!!!!!!!!
		# This is a sloppy way to remove HTML, as it will destroy all text wrapped in angle brackets.
		#   Perhaps find a cleaner way to go about this, as it prevents plaintext emails from containing these <> pairs.
		$BODY = $BODY -Replace '<tr>', "`n"
		$BODY = $BODY -Replace '(</td>|</th>)', ' | '
		$BODY = $BODY -Replace '<.*?>'
	}
	# Define a dynamic parameter object to pass to Send-MailMessage.
	$emailParams = @{
		From = $FROM; To = $TO; Subject = $SUBJECT; Body = $BODY; SmtpServer = $RELAYSERVER; Port = $RELAYPORT
	}
	
	# If there's a BCC argument to the script, split the string into an array of recipients along the comma characters.
	if($BCC -ne "") { $BCC = $BCC.Split(",").Trim(); $emailParams.Add("Bcc", $BCC) }
		
	if($NotificationsRelayWithCredential -eq $True) {
		# Relay with auth is on, is a valid SmtpCredential object provided?
		if($SmtpCredential -eq $null -Or $SmtpCredential -IsNot [PSCredential]) {
			Write-Host "~~~~ Relay with Authentication is enabled, but no valid Credentials object was detected!"
			Write-Host "~~~~~~ Please use the -SmtpCredential parameter with a valid Credentials object (using Get-Credential)."
			Write-Host "~~~~~~ Attempting relay WITHOUT authentication anyway..."
		} else {
			# Otherwise, add it to the email parameters.
			$emailParams.Add("Credential", $SmtpCredential)
		}
	}
	
	# Dispatch the email to the target server.
	Send-MailMessage @emailParams -BodyAsHtml:$NotificationsAsHTML -UseSsl:$NotificationsRelayWithSSL
	# Return the success status of sending the message.
	return $?
}


# Write the report object as a JSON to the target output file.
Function Write-Report() {
	param( [System.Object]$outputJSON = @{} )
	
	# Today's date, format of YYYY-MM-DD-HH_MM
	$dateTag = Get-Date -UFormat %Y-%m-%d-%H_%M
	$targetFile = $ReportsDirectory + "\Report-$($outputJSON.Hostname)-$dateTag.txt"
	
	# Write the output as a JSON object to the report file (targetFile).
	Write-Output $outputJSON | ConvertTo-JSON -Depth 3 -Compress:$NoMiniSet | Out-File -FilePath $targetFile
}


# Given a client hostname, clean reports according to the retention policy.
Function Clean-Reports() {
	param( [string]$clientHostname )
	Write-Host "-- Cleaning reports according to the script retention policy ($MaxReportRetentionHours Hours)."
	$TodaysDate = ((Get-Date -UFormat %Y-%m-%d-%H_%M).toString())
	# For each report filename containing the hostname, get the date on the filename and compare to the retention policy.
	foreach($report in (Get-ChildItem -Path "$ReportsDirectory\Report-$clientHostname*").Name) {
	$report -Match '-(\d{4}-\d{2}-\d{2}-\d{2}_\d{2}).txt$' | Out-Null
		if((Get-Date-Delta-Hours "$TodaysDate" "$($matches[1])") -ge $MaxReportRetentionHours) {
			Remove-Item -Confirm:$False -Force -Path "$ReportsDirectory\Report-$clientHostname-$($matches[1]).txt"
		}
	}
}


# Gather a report from a report file, return it as a HashTable.
Function Pull-Report() {
	param( [System.String]$hostname, [System.String]$dateString )
	if(Test-Path ($ReportsDirectory + "\Report-$hostname-$dateString.txt")) {
		return (Get-Content ($ReportsDirectory + "\Report-$hostname-$dateString.txt") | ConvertFrom-Json)
	} else { return $null }
}


# Compare two dates and return the difference in dates.
#    Since the dates are coming from filenames (which can't have a ':' character), replace '_' with ':'.
Function Get-Date-Delta-Hours() {
	param( [string]$dateOne, [string]$dateTwo )
	$dateOne = $dateOne -Replace '_', ':'
	$dateTwo = $dateTwo -Replace '_', ':'
	return ((Get-Date "$dateOne") - (Get-Date "$dateTwo")).TotalHours
}


# Template function to modularize comparing and generating deltas.
Function Compare-Deltas() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjChanged = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjNew = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjRemoved = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$Todays = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$Priors = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$TodaysIndex = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$PriorsIndex = @{},
		[Parameter(Mandatory=$True)][System.Array]$CompareProperties = @()
	)
	foreach($item in $TodaysIndex) {
		# Get the applications from the hashtable, so it can be compared to the prior report.
		$todayObject = $Todays.$item
		$priorObject = $Priors.$item
		# If the object isn't found in the last report, assume it's a new application.
		if($priorObject -eq $null -Or $priorObject -eq @{}) { continue }
		# Compare properties between the two report objects and return it as an array of True/False.
		$diffs = $CompareProperties | ForEach-Object { $todayObject.$_ -ne $priorObject.$_ }
		# If a "True" was found, there was a difference detected.
		if($diffs.Contains($True)) {
			# For each property name to compare, add on the _prior variable with the value of the "Prior" object.
			$CompareProperties | ForEach-Object {
				$todayObject | Add-Member -Name "$($_)_prior" -Value $priorObject.$_ -Type NoteProperty
			}
			# Add it to the object pointer for the deltasObject variable.
			$DeltasObjChanged.Add("$item", $todayObject)
		}
	}
	# Compare the indices of fields to see if an application was added/removed.
	$indexDiffs = Compare-Object $TodaysIndex $PriorsIndex
	foreach($difference in $indexDiffs) {
		$diff = $difference.InputObject
		if($difference.SideIndicator -eq "<=") {
			# The item was added.
			$DeltasObjNew.Add("$diff", $Todays.$diff)
		} elseif($difference.SideIndicator -eq "=>") {
			# The item was removed.
			$DeltasObjRemoved.Add("$diff", $Priors.$diff)
		}
	}
}


# Check the NotificationsFilter variable against the given object to see if it should be filtered out of the notification.
#    If the return value is False, do NOT filter the item (meaning there was no match).
Function Check-Notification-Filter() {
	# FilterType : Which sub-field of "$NotificationsFilters" is being examined?
	# FilterAge  : Is this for "New", "Removed", or "Changed"?
	# ItemValue  : The object that is being checked for a filter match.
	param(
		[Parameter(Mandatory=$True)][string]$FilterType = "",
		[Parameter(Mandatory=$True)][string]$FilterAge = "",
		[Parameter(Mandatory=$True)][PSCustomObject]$ItemValue = @{}
	)
	# Dynamically define the two values for filtering. This is controlled by whether the filtering is white/black-list.
	$DoFilter = $NotificationsFiltersBlacklist
	$DontFilter = (-Not $NotificationsFiltersBlacklist)
	# Set $filters equal to the string array of filter names.
	$filters = $NotificationsFilters.$FilterType.$FilterAge
	# If there aren't any items in the array, no filters are defined, so don't filter anything.
	if($filters.Count -eq 0) { return $DontFilter }
	# Convert the input object into a Hashtable as needed. This allows us to properly use the "Keys" property below.
	$ItemValueHT = @{}
	if(($ItemValue.GetType()).Name -eq 'PSCustomObject') {
		$ItemValue.PSObject.Properties | ForEach-Object { $ItemValueHT[$_.Name] = $_.Value }
	} else { $ItemValueHT = $ItemValue }
	# For each filter string in the array, ...
	foreach($filter in $filters) {
		# Iterate through the ItemValueHT object's keys to see if it matches the current filter.
		$filterMatch = @()
		if($NotificationFiltersRegex -eq $False) {
			$ItemValueHT.Keys | ForEach-Object { $filterMatch += ($ItemValueHT.$_ -Like $filter) }
		} else { $ItemValueHT.Keys | ForEach-Object { $filterMatch += ($ItemValueHT.$_ -Match $filter) } }
		# If there's a match, immediately notify the script to filter.
		if($filterMatch.Contains($True)) { return $DoFilter }
	}
	# Otherwise, there is no match, so don't filter anything.
	return $DontFilter
}


<# Template function to modularize the repetitive task of adding pieces to the email notification.
 #  For New and Removed objects, it simply iterates the Hashtable keys (after checking if there even are any)
 #    and adds the HTML for each corresponding object under the detected keys.
 #  For Changed objects, the two different objects are spliced together to create a single table to show differences.
 #>
Function Add-To-Report() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$NewObject = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$RemovedObject = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$ChangedObject = @{},
		[Parameter(Mandatory=$True)][string]$ItemName,
		[Parameter(Mandatory=$True)][string]$ItemType
	)
	# Declare initial local variables.
	# NOTIFSXN later gets extended by underscored/suffixed variables as the script builds the notification.
	$NOTIFSXN = ""
	$spanNewItem = "<span class='$NotificationsHTMLNewValClass'>"
	$spanPriorItem = "<span class='$NotificationsHTMLPriorValClass'>"
	$spanDifferentItem = "<span class='$NotificationsHTMLDiffValClass'>"
	# New Objects section. If the amount of hashtable keys is >0, check notification filters and
	#    then iterate the keys and add the object to the table.
	if($NewObject.Keys.Count -gt 0) {
		$NOTIFSXN_New = "<span class='SectionHeader'>New $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		foreach($new in $NewObject.Keys) {
			# For each key in the new item, check the value of the field against the values in the notification filters.
			$isFiltered = Check-Notification-Filter -FilterType $ItemType -FilterAge "New" -ItemValue $NewObject.$new
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				if($NotificationsShowFilteredItem -eq $True) { $NOTIFSXN_New += $NotificationsFilteredIndicator }
				continue
			}
			$fillVar = $NewObject.$new | ConvertTo-HTML -Fragment
			# Any td tags with nothing in between should be manually filled in with a "null" piece of text, to avoid empty spots.
			$fillVar = $fillVar -Replace '<td>(<span class=.*?></span>)?</td>', '<td>null</td>'
			$NOTIFSXN_New += "<div class='DiffsSection'>`n"
			$NOTIFSXN_New += "$spanNewItem<b>Name</b>: $new</span><br />`n"
			$NOTIFSXN_New += "$spanNewItem$($fillVar)</span><br />`n"
			$NOTIFSXN_New += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_New }
	}
	# Removed Objects section. Same process as the "New Objects" section.
	if($RemovedObject.Keys.Count -gt 0) {
		$NOTIFSXN_Removed = "<span class='SectionHeader'>Removed $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		foreach($removed in $RemovedObject.Keys) {
			# For each key in the removed item, check the value of the field against the values in the notification filters.
			$isFiltered = Check-Notification-Filter -FilterType $ItemType -FilterAge "Removed" -ItemValue $RemovedObject.$removed
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				if($NotificationsShowFilteredItem -eq $True) { $NOTIFSXN_Removed += $NotificationsFilteredIndicator }
				continue
			}
			$fillVar = $RemovedObject.$removed | ConvertTo-HTML -Fragment
			# Any td tags with nothing in between should be manually filled in with a "null" piece of text, to avoid empty spots.
			$fillVar = $fillVar -Replace '<td>(<span class=.*?></span>)?</td>', '<td>null</td>'
			$NOTIFSXN_Removed += "<div class='DiffsSection'>`n"
			$NOTIFSXN_Removed += "$spanPriorItem<b>Name</b>: $removed</span><br />`n"
			$NOTIFSXN_Removed += "$spanPriorItem$($fillVar)</span><br />`n"
			$NOTIFSXN_Removed += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_Removed }
	}
	# Changed Objects section.
	if($ChangedObject.Keys.Count -gt 0) {
		$NOTIFSXN_Changed = "<span class='SectionHeader'>Changed $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		foreach($changed in $ChangedObject.Keys) {
			# ------------- CHECK BOTH OBJECTS WITH FILTERS ---------------
			# For each key in the changed item, check the value of the field against the values in the notification filters.
			$isFiltered = Check-Notification-Filter -FilterType $ItemType -FilterAge "Changed" -ItemValue $ChangedObject.$changed
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				if($NotificationsShowFilteredItem -eq $True) { $NOTIFSXN_Changed += $NotificationsFilteredIndicator }
				continue
			}
			# --------------------------------------------------------------
			# Create two separate objects and merge them together under the same property names.
			#    The objects are split based on the '_prior' suffixes added in the deltas phase of the script.
			$tableNews = @{}; $tablePriors = @{}
			($ChangedObject.$changed | Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike *_prior).Name `
				| Sort-Object | ForEach-Object {
					# Manually fill in the "null" spots via string assignment here. This must be different than the above "Replace"
					#    method because the color highlight (prior vs. new) would be great to have instead of plain text.
					if($ChangedObject.$changed.$_ -eq $null -Or $ChangedObject.$changed.$_ -eq "") {
						$ChangedObject.$changed.$_ = "null"
					}
					if($ChangedObject.$changed."$($_)_prior" -eq $null -Or $ChangedObject.$changed."$($_)_prior" -eq "") {
						$ChangedObject.$changed."$($_)_prior" = "null"
					}
				# Each key will correspond to a fully-HTML value for the "output table" object.
				$diffHighlight=$diffHighlightTerm = ""
				# If the two specific values are different, define a stylization class and wrap the text with it.
				if($ChangedObject.$changed.$_ -ne $ChangedObject.$changed."$($_)_prior") {
					$diffHighlight = $spanDifferentItem; $diffHighlightTerm = "</span>"
				}
				# In short, if the "diff" spans are filled out, the object will be highlighted to show it contains one of the deltas.
				$tableNewsWrapper = "$spanNewItem" + "$diffHighlight" + `
					$ChangedObject.$changed.$_ + "$diffHighlightTerm" + "</span>"
				$tableNews.Add($_,$tableNewsWrapper)
				$tablePriorsWrapper = "$spanPriorItem" + "$diffHighlight" + `
					$ChangedObject.$changed."$($_)_prior" + "$diffHighlightTerm" + "</span>"
				$tablePriors.Add($_, $tablePriorsWrapper)
			}
			# Send the spliced array to the HTML function to output both items under the same headers.
			$tableOut = (@($tablePriors,$tableNews) | ConvertTo-Json | ConvertFrom-Json) | ConvertTo-Html -Fragment
			# Ensure that pieces aren't added to the table as HTML special chars ("&lt;"). Allows for formatting w/ SPAN.
			$finalTable = [System.Web.HttpUtility]::HtmlDecode($tableOut)
			# Add it to the string and close the div tag as appropriate.
			$NOTIFSXN_Changed += "<div class='DiffsSection'>`n"
			$NOTIFSXN_Changed += "<span style='color:black;font-size:14px;'><b>Name</b>: $changed</span><br />`n"
			$NOTIFSXN_Changed += "$finalTable<br />`n"
			$NOTIFSXN_Changed += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_Changed }
	}
	# Send the finished string back.
	return $NOTIFSXN
}


# Interpret compounding flags using a logical AND. Used for report generation.
Function Interpret-Flags() {
	param( [PSCustomObject]$FlagSet = @{}, $GivenValue, [switch]$Binary )
	# If GivenValue is null, avoid any kind of NPE and just return null.
	if($GivenValue -eq $null) { return $null }
	# If the passed argument for "GivenValue" isn't numeric, then leave with "GivenValue" as the return.
	if($GivenValue.GetType().Name -ne "Int32") { return $GivenValue }
	# If the Binary switch is NOT used, just return the single value from the FLAGSET variable.
	if($Binary -ne $True) { return $FlagSet["code$($GivenValue)"] }
	# Can't do a bitwise AND against a 0, so just automatically default to the flagset's 0 code.
	if($GivenValue -eq 0) { return $FlagSet["code0"] }
	# Initialize the return variable.
	$flagsInfo = ""
	# For each "codeXX" key, strip off the "code" prefix and do a logical AND against the integer to see if that bit is set.
	#    If the bit is set, append the corresponding "codeXX" value from the object onto the return string.
	$FlagSet.Keys | ForEach-Object {
		# Strip the "code" piece from the key.
		$code = $_ -Replace "code"
		# Do a bitwise AND on the givenvalue and the code from the key ID.
		$isMatch = $GivenValue -BAND $code
		# If it matches (ergo the flag is set), append the piece/verb from the flagset onto the return variable.
		if($isMatch -ne 0) { $flagsInfo += $FlagSet["code$($code)"] + " " }
	}
	return $flagsInfo
}



##################################################
#                      MAIN                      #
##################################################


# Ensure that the ReportsDirectory exists.
if(($ReportsDirectory -eq "") -Or (-Not(Test-Path "$ReportsDirectory"))) { Output-Error(3) }

# Initialize an empty array for the client address/hostname pool.
$clientAddresses = [System.Collections.ArrayList]@()

# Check to see whether a clientsList file was provided to the script.
if($clientsList -eq "use-AD-list") {
	$clientNames = Get-ADComputer -Filter $DomainUserFilter | Select-Object -Property Name
	if($? -eq $False) { Output-Error(4)  }
	foreach($line in $clientNames) {
		# May want to verify it's not an IP here but the Get-ADComputer
		#    command doesn't seem to return raw IPs in the "Name" property.
		$hostname = $line.Name
		$address = Parse-Hostnames($hostname)
		# Sanity check, ensuring it's not a duplicate and that it exists.
		if($address -eq $null -Or $clientAddresses.Contains($address)) { continue }
		# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
		if(-Not($hostname -Match $DomainSuffixRegex)) { $hostname = $hostname + $DomainSuffix }
		# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
		$localObject = @{IP = ''; Hostname = ''}
		$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
		$clientAddresses += $localObject
	}
} else {
	# Make sure the clientsList file exists. If not, exit.
	if(-Not(Test-Path $ClientsList)) { Output-Error(1) }
	# Parse each line in the clientsList file.
	foreach($line in Get-Content $ClientsList) {
		# Check to see whether the line matches a hostname or an IPv4 address.
		if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$' -Or $line -Match '\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}\b') {
			$address=$addressOrig=$hostname = $null
			# If it's a hostname, resolve it to an IPv4 address. Otherwise, just capture the IP.
			if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$') {
				$address = Parse-Hostnames($line)
				$hostname = $line -Replace '\\'
			} else {
				$address = $line
				# Get the hostname from the IP, or at least attempt to.Res
				$hostname = [System.Net.Dns]::Resolve([string]$address).HostName
			}
			# If a valid address couldn't be captured, or if the clientAddresses array already contains it,
			#    consider the entry invalid and continue to the next one.
			if($address -eq $null -Or $clientAddresses.Contains($address)) { continue }
			# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
			if((-Not($hostname -Match $DomainSuffixRegex)) -And (-Not($hostname -Match '^LOCALHOST\.?'))) {
				$hostname = $hostname + $DomainSuffix
			}
			# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
			$localObject = @{IP = ''; Hostname = ''}
			$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
			$clientAddresses += $localObject
		}
	}
}




# Check whether or not $clientAddresses has been properly populated. If not, exit.
if($clientAddresses -eq $null -Or $clientAddresses.length -eq 0) { Output-Error(2) }

# Define a base object to hold deltas between yesterday and today.
$deltas = @{}

# Iterate through each client and generate the report.
foreach($client in $clientAddresses) {
	# Aesthetix.
	Write-Host "`n`n"
	# Build a base for the newest report object to be generated.
	$FullReport = [ordered]@{
		IP = "$($client.IP)"; Hostname = "$($client.Hostname)"
		IsOnline = $False; Invokable = $False
	}
	# Template an object to track any changes from the most recent report to the newest one.
	$deltasObject = [ordered]@{
		OnlineStatusChange = $False; InvokableChange = $False
		NewServices = @{}; RemovedServices = @{};	ChangedServices = @{}
		NewInstalledApps = @{}; RemovedInstalledApps = @{}; ChangedInstalledApps = @{}
		NewStoreApps = @{}; RemovedStoreApps = @{}; ChangedStoreApps = @{}
		NewStartupApps = @{}; RemovedStartupApps = @{}; ChangedStartupApps = @{}
		NewScheduledTasks = @{}; RemovedScheduledTasks = @{}; ChangedScheduledTasks = @{}
		FilenameViolations = @{};
	}
	# Create a "dummy" (reference) object for the null array.
	$deltasObjectDummy = $deltasObject | Select-Object *
	
	# Write the current client to the terminal/host for tracking/debugging.
	Write-Host "Hostname: " -NoNewLine
	Write-Host "$($client.Hostname)" -ForegroundColor Cyan
	Write-Host "IP: " -NoNewLine
	Write-Host "$($client.IP)" -ForegroundColor Cyan
	
	Write-Host "-- Pulling prior report."
	# Collect the top of the list for most recent files/reports matching the given hostname.
	#    If an object isn't returned from the query below, assume there is no "prior" report and act accordingly.
	$LastReportMade = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
		| Sort-Object LastWriteTime | Select-Object -Last 1)
	if($LastReportMade.Length -le 0) {
		Write-Host "** No prior report found. Setting the comparison object to the default reference."
		$MostRecentReport = $FullReport
	} else {
		$LastReportMade = $LastReportMade[0].Name
		# Bring the previous report and the recent report into the script.
		$DateofLastReport = [Regex]::Matches($LastReportMade, '\d{4}-\d{2}-\d{2}-\d{2}_\d{2}')[0].Value
		$MostRecentReport = Pull-Report "$($client.Hostname)" "$DateofLastReport"
	}
	
	
	# Create a parameters object for Invoke.
	$invokeParams = @{}
	# Is the tested client the local host? If not, set the ComputerName parameter to the client hostname.
	if(-Not($client.Hostname -Match '^LOCALHOST\.?')) {
		$invokeParams.Add("ComputerName", "$($client.Hostname)")
	}
	
	Write-Host "-- Running connectivity tests for WinRM and ICMP."
	
	# Run a basic ICMP ping test against the target to see if it's online. Add it to the report.
	Test-Connection "$($client.Hostname)" -Count 1 | Out-Null
	$FullReport.IsOnline = $?
	
	# Check if the target is invokable at all, i.e. can we run WinRM commands on it?
	Invoke-Command @invokeParams -ScriptBlock { Get-Culture } | Out-Null
	$FullReport.Invokable = $?
	
	# Compare invokability and availability to the last report, as long as this ISN'T the first report.
	if((($FullReport.Invokable -ne $MostRecentReport.Invokable) -Or
			($FullReport.IsOnline -ne $MostRecentReport.IsOnline)) -And
			(-Not($LastReportMade.Length -le 0))) {
			$deltasObject.OnlineStatusChange = ($FullReport.IsOnline -ne $MostRecentReport.IsOnline)
			$deltasObject.InvokableChange = ($FullReport.Invokable -ne $MostRecentReport.Invokable)
			$deltas.Add("$($client.Hostname)", $deltasObject)	
		}
	
	# The target host cannot be invoked. Note this, generate the report, clean old reports, and skip.
	if ($FullReport.Invokable -eq $False) {
		Write-Host "**** WinRM is not active on the target."
		Write-Report($FullReport)
		Clean-Reports "$($client.Hostname)"
		continue
	}
	
	
	<# Harvest an object full of data from the client.
	 #   PSParentPath is using the registry key where we've found the entry, so it shouldn't ever be null.
	 #   PSChildName is the registry key's name. So if there is not any other info, at least get the key name.
	 #>
	 
	Write-Host "-- Collecting information about the target machine and building a report."
	
	####### TODO: PIECES OF THIS SECTION CAN BE MODULARIZED INTO A GENERIC FUNCTION #######
	# -----------------------------------------
	# Iterate through the filename trackers, if enabled.
	if($FilenameTracking -eq $True) {
		Write-Host "---- Tracking filenames across the below directories or places:"
		$TrackedFiles = @{}
		
		# Check user directories, if enabled.
		if($TrackedFilenameLocations.UserProfiles -eq $True) {
			Write-Host "------ User Profiles"
			$UserProfileCounts = @{}
			$ProfileContents = Invoke-Command @invokeParams -ScriptBlock {
				# Get a list of the user profiles on the target machine.
				# !!!! WARNING: This script makes an assumption that user profiles are located under C:\Users !
				$UserProfiles = (Get-ChildItem -Path 'C:\Users' `
					| Where-Object -Property Attributes -Like '*Directory*').FullName
				# Get the actual contents of all the directories and send the full path + filename back out.
				$UserProfiles | ForEach-Object { Get-ChildItem -Path $_ -Recurse | Sort-Object LastWriteTime }
			}
			# Iterate through the profile list.
			foreach($prof in $UserProfiles) {
				$PerProfileCount = @{}
				# Go through each pattern being checked, and get a count for the amount of matching filenames.
				foreach($pattern in $TrackedFilenamePatterns.Keys) {
					$matchedfiles = $ProfileContents | Where-Object -Property FullName -Like "$($prof)\*" `
						| Where-Object -Property Name -Match $pattern
					$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
					$filecount = $actualnames.Count
					if($filecount -eq $null) { $filecount = 0 }
					# Add the count onto the per-profile object, as well as the associated filenames for info later.
					$PerProfileCount.Add($pattern, $filecount)
					$PerProfileCount.Add("FILES_$($pattern)", $actualnames)
				}
				# Add the per-profile object to this wrapper.
				$UserProfileCounts.Add($prof, $PerProfileCount)
			}
			# Add the totals under the "UserProfileCounts" field.
			$TrackedFiles.Add("UserProfilesCounts", $UserProfileCounts)
		} else { $TrackedFiles.Add("UserProfilesCounts", @{}) }
		
		# This section should be used with caution, as it may cause a delay in script processing per client.
		if($TrackedFilenameLocations.SystemFiles -eq $True) {
			Write-Host "------ The %SYSTEMROOT% directory (typically 'C:\Windows')"
			Write-Host "~~~~~~ WARNING: This could add a potentially-large delay in per-client processing."
			# Recursively get all files in the %SYSTEMROOT% location, from the remote client.
			$SystemDirContents = Invoke-Command @invokeParams -ScriptBlock {
				Get-ChildItem -Path $ENV:SYSTEMROOT -Recurse
			}
			$FoundPatterns = @{}
			foreach($pattern in $TrackedFilenamePatterns.Keys) {
				if($SystemDirContents -eq $null) { continue }
				$matchedfiles = ($SystemDirContents | Where-Object -Property Name -Match $pattern)
				$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
				$filecount = $actualnames.Count
				if($filecount -eq $null) { $filecount = 0 }
				$FoundPatterns.Add($pattern, $filecount)
				$FoundPatterns.Add("FILES_$($pattern)", $actualnames)
			}
			# Create an intermediate object to give this the same nesting as the "user" and "custom" fields.
			$IntermediateObject = @{}; $IntermediateObject.Add("SystemFiles", $FoundPatterns)
			$TrackedFiles.Add("SystemFilesCounts", $IntermediateObject)
		} else { $TrackedFiles.Add("SystemFilesCounts", @{}) }
		
		# This section should be used with caution, as it may cause a delay in script processing per client.
		if($TrackedFilenameLocations.ProgramData -eq $True) {
			Write-Host "------ The %ProgramData% directory (typically 'C:\ProgramData')"
			Write-Host "~~~~~~ WARNING: This could add a potentially-large delay in per-client processing."
			# Recursively get all files in the %ProgramData% location, from the remote client.
			$ProgramDataContents = Invoke-Command @invokeParams -ScriptBlock {
				Get-ChildItem -Path $ENV:ProgramData -Recurse
			}
			$FoundPatterns = @{}
			# See below section (custom directories) is commented and effectively doing the same thing.
			foreach($pattern in $TrackedFilenamePatterns.Keys) {
				if($ProgramDataContents -eq $null) { continue }
				$matchedfiles = ($ProgramDataContents | Where-Object -Property Name -Match $pattern)
				$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
				$filecount = $actualnames.Count
				if($filecount -eq $null) { $filecount = 0 }
				$FoundPatterns.Add($pattern, $filecount)
				$FoundPatterns.Add("FILES_$($pattern)", $actualnames)
			}
			# Again, create an intermediate object to give this the same nesting as the "user" and "custom" fields.
			$IntermediateObject = @{}; $IntermediateObject.Add("ProgramFiles", $FoundPatterns)
			$TrackedFiles.Add("ProgramFilesCounts", $IntermediateObject)
		} else { $TrackedFiles.Add("ProgramFilesCounts", @{}) }
		
		# Are there any custom directories? If so, iterate the object.
		if($TrackedFilenameLocationsCustom.Keys.Count -gt 0) {
			Write-Host "------ Custom Directories:"
			$CustomDirTrackers = @{}
			foreach($customlocation in $TrackedFilenameLocationsCustom.Keys) {
				Write-Host "-------- " -NoNewLine; Write-Host "'$($customlocation)'" -ForegroundColor Magenta
				# Get the contents of the custom directory. If it doesn't exist, return a null.
				$CustomDirContents = Invoke-Command @invokeParams -ScriptBlock {
					if(-Not(Test-Path $args[1])) { return $null }
					Get-ChildItem -Path $args[1] -Recurse:$args[0] | Sort-Object LastWriteTime
				} -ArgumentList $TrackedFilenameLocationsCustom.$customlocation,$customlocation
				$PerLocationCount = @{}
				foreach($pattern in $TrackedFilenamePatterns.Keys) {
					# if the contents returned = null, just get out.
					if($CustomDirContents -eq $null) { continue }
					# Get files matching the current pattern.
					$matchedfiles = ($CustomDirContents | Where-Object -Property Name -Match $pattern)
					# Get the full name (with the path prepended).
					$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
					# Count the amount of full pathnames/filenames present.
					$filecount = $actualnames.Count
					# If for whatever reason the "Count" property returns a null, default to 0.
					if($filecount -eq $null) { $filecount = 0 }
					# Add the pieces to the per-location object (indexing everything for the CURRENT custom location).
					$PerLocationCount.Add($pattern, $filecount)
					$PerLocationCount.Add("FILES_$($pattern)", $actualnames)
				}
				# Add the per-location object onto the main tracker.
				$CustomDirTrackers.Add($customlocation, $PerLocationCount)
			}
			# Add the main tracker for custom directories to the meta/super object.
			$TrackedFiles.Add("CustomLocationsCounts", $CustomDirTrackers)
		} else { $TrackedFiles.Add("CustomLocationsCounts", @{}) }
		
		# Add the meta/super object to the report, and also index the extensions/expressions used.
		$FullReport.Add("FilenameTrackers", $TrackedFiles)
		$TrackedFilenamePatternsAsArray = @(); $TrackedFilenamePatterns.Keys `
			| ForEach-Object { $TrackedFilenamePatternsAsArray += $_ }
		$FullReport.Add("FilenameTrackersPatterns", $TrackedFilenamePatternsAsArray)
		<# FullReport is adding this structure:
		 # "FilenameTrackers" : {
		 #    UserProfilesCounts    : {  <user1>:{patterns-found}, <user2>:{patterns-found}, ..., <userN>:{patterns-found}  }
		 #    CustomLocationsCounts : {  <loc1>:{patterns-found}, <loc2>:{patterns-found}, ..., <locN>:{patterns-found}  }
		 #    ProgramFilesCounts    : {  "ProgramFiles":{patterns-found}  }
		 #    SystemFilesCounts     : {  "SystemFiles":{patterns-found}  }
		 # }
		 #    ... where "patterns-found" uses the pattern from the $TrackedFilenamePatterns variable as the key
		 #        and the count as the value. There is also a "FILES_[pattern]" key for the actual full filenames found.
		 #>
	}
	
	
	# -----------------------------------------
	# Collect installed applications at multiple layers.
	Write-Host "---- Gathering installed applications..."
	$installedAppsObject = Invoke-Command @invokeParams -ScriptBlock {
		$installedApps = @()
		# Local Machine applications.
		$installedApps += Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
		# Current User applications.
		$installedApps += Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
		# 64-to-32-bit applications.
		$installedApps += Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*
		# Send back the aggregated object.
		return $installedApps
	}
	# Define the two objects to insert into the main report hashtable.
	$reportInstalledApps = @{}; $installedAppsIndex = @()
	foreach($app in $installedAppsObject) {
		# Append a suffix onto each index to ensure uniqueness, based on which part of the registry the key lives in.
		$keysuffix = "_"
		if($app.PSPath -Match 'Wow6432Node') { $keysuffix += '6432Node' }
		elseif($app.PSPath -Match '::HKEY_CURRENT') { $keysuffix += 'HKCU' }
		elseif($app.PSPath -Match '::HKEY_LOCAL') { $keysuffix += 'HKLM' }
		else { $keysuffix += '?' }
		$keyname = "$($app.PSChildName)" + $keysuffix
		# Add the keyname onto the index.
		$installedAppsIndex += $keyname
		# Create the key in the hashtable.
		$reportInstalledApps.Add($keyname, ($installedAppsObject | Where-Object -Property PSPath -eq "$($app.PSPath)" `
			| Select-Object $TrackedValues.InstalledApps))
	}
	# Add the items to the new report.
	$FullReport.Add("InstalledAppsIndex", $installedAppsIndex)
	$FullReport.Add("InstalledApps", $reportInstalledApps)
	
		
	# -----------------------------------------
	# Harvest Windows Store-based applications.
	Write-Host "---- Gathering store applications..."
	$priorELVL = $ErrorActionPreference; $ErrorActionPreference = 'SilentlyContinue'   # shhhh...
	# Get the store apps a single time and run all computations on the LOCAL side! (fix to Issue #1 on GitHub).
	$storeAppsList = Invoke-Command @invokeParams -ScriptBlock { Get-AppxPackage -AllUsers }
	# If there was an issue getting the list, write it out and move on.
	if($storeAppsList.Count -eq 0) {
		Write-Host "~~~~ Store apps couldn't be captured for this client. Please verify administrative permissions."
	}; $ErrorActionPreference = $priorELVL
	$reportStoreApps = @{}
	# Iterate the list of store apps.
	foreach($app in $storeAppsList) {
		$keyname = "$($app.InstallLocation)_$($app.PackageFullName)"
		$i = 0  #Keep track of the "layer"
		for(; $i -lt 4; $i++) {
			# Allow up to 4 nested key names, each successive duplicate being suffixed by an extra underscore.
			if($reportStoreApps.ContainsKey($keyname)) { $keyname += "_" }
		}
		# Get all the fields from the StoreApps trackers that are needed to build the report.
		$storeAppsInfo = ($storeAppsList | Where-Object -Property InstallLocation -eq "$($app.InstallLocation)" `
			| Select-Object $TrackedValues.StoreApps)
		# Additionally, ALWAYS track the PackageUserInformation to find out who has which apps, and their statuses.
		$perUserAppStatus = ($storeAppsList | Where-Object -Property InstallLocation -eq "$($app.InstallLocation)" `
			| Select-Object PackageUserInformation) | ForEach-Object {
				[System.String]::Join("; ", @("App Status:", [string]@(("$($_.PackageUserInformation)" `
					| Select-String -Pattern '\[[\\\w]+\]\s*\:\s+\w+' -AllMatches).Matches.Value) | Out-String))
			}
		# Add the PackageUserInformation property (with extracted names/statuses) into the final object.
		$storeAppsInfo | Add-Member -Name PackageUserInformation -Type NoteProperty -Value "$($perUserAppStatus)"
		$reportStoreApps.Add($keyname, $storeAppsInfo)
	}
	# Get an index of store apps based on the InstallLocation.
	$storeAppsIndex = [System.Collections.ArrayList]@()
	$storeAppsList | ForEach-Object {
		$keyname = "$($_.InstallLocation)"
		for($i = 0; $i -lt 4; $i++) { if($storeAppsIndex.Contains($keyname)) { $keyname += "_" } }
		$storeAppsIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("StoreAppsIndex", $storeAppsIndex)
	$FullReport.Add("StoreApps", $reportStoreApps)
	
	
	# -----------------------------------------
	# Harvest startup applications.
	Write-Host "---- Gathering startup applications..."
	# Get Startup apps using the below command. This will catch everything except 6432 Nodes in the registry.
	$w32StartupCmd = Invoke-Command @invokeParams -ScriptBlock { Get-CimInstance Win32_StartupCommand }
	# Define the two objects to insert into the main report hashtable.
	$reportStartupApps = @{}; $startupAppsIndex = @()
	foreach($startupapp in $w32StartupCmd) {
		$keyname = "$($startupapp.Name)_$($startupapp.User)"
		$reportStartupApps.Add($keyname, `
			($w32StartupCmd | Where-Object -Property Name -eq "$($startupapp.Name)" `
				| Where-Object -Property User -eq "$($startupapp.User)" `
				| Select-Object $TrackedValues.StartupApps))
		$startupAppsIndex += $keyname
	}
	# Get Startup apps from the location mentioned above.
	$6432NodeItems = Invoke-Command @invokeParams -ScriptBlock {
		(Get-ItemProperty HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run) `
			| Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike PS*
	}
	# Add each one onto the startup apps that are registered for the client.
	foreach($item in $6432NodeItems) {
		$keyname = "$($item.Name)_6432-NODE"
		$addedInformation = @{}
		foreach($value in $TrackedValues.StartupApps) {
			if($value -eq "Command") {
				$addedInformation.Add($value, "$($item.Definition -Replace 'string ')")
			} elseif($value -eq "Location") {
				$addedInformation.Add($value, "64-to-32_Registry_Node")
			} elseif($value -eq "User") {
				$addedInformation.Add($value, "6432-NODE")
			} else { $addedInformation.Add($value, "") }
		}
		$reportStartupApps.Add($keyname, $addedInformation)
		$startupAppsIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("StartupAppsIndex", $startupAppsIndex)
	$FullReport.Add("StartupApps", $reportStartupApps)
		
	
	# -----------------------------------------
	# Get a list of services (all of them).
	Write-Host "---- Gathering services..."
	$svcs = Invoke-Command @invokeParams -ScriptBlock { Get-Service }
	$reportServices = @{}; $servicesIndex = @()
	foreach($service in $svcs) {
		$keyname = "$($service.DisplayName)_$($service.Name)"
		$reportServices.Add($keyname, `
			($svcs | Where-Object -Property DisplayName -eq "$($service.DisplayName)" `
				| Where-Object -Property Name -eq "$($service.Name)" `
				| Select-Object $TrackedValues.Services))
		$servicesIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("ServicesIndex", $servicesIndex)
	$FullReport.Add("Services", $reportServices)
	
	
	# -----------------------------------------
	# Get scheduled tasks and jobs.
	Write-Host "---- Gathering scheduled tasks..."
	$taskList = Invoke-Command @invokeParams -ScriptBlock { Get-ScheduledTask }
	$reportTasks = @{}; $scheduledTasksIndex = @() 
	foreach($task in $taskList) {
		$keyname = "$($task.URI)"
		$reportTasks.Add($keyname, `
			($taskList | Where-Object -Property URI -eq "$($task.URI)" `
				| Select-Object $TrackedValues.ScheduledTasks))
		$scheduledTasksIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("ScheduledTasksIndex", $scheduledTasksIndex)
	$FullReport.Add("ScheduledTasks", $reportTasks)
	
	
	# -----------------------------------------
	# Generate the final report file with all of the information.
	Write-Host "---- Finalizing generated report."
	Write-Report($FullReport)
	
	
	
	#####################################################################
	# COMPARISON SECTION.
	# All comparisons will use the most recent report as the reference object, comparing AGAINST the prior report.
	Write-Host "-- Comparing the differences between the generated report and the prior report."
	# Stop here if the file is the first in the line of reports.
	if($LastReportMade.Length -le 1) {
		Write-Host "** Client does not have a prior report to provide a comparison to the new report. Skipping comparisons..."
		continue
	}
	# HashTable -> JSON -> PSCustomObject, so that it matches the import that the $MostRecentReport variable went through.
	$FullReportIntermediate = $FullReport | ConvertTo-Json -Depth 3
	$TodaysReport = $FullReportIntermediate | ConvertFrom-Json
	
	
	# -----------------------------------------
	# Filename Tracking.
	if($FilenameTracking -eq $True) {
		$todayfilenames = $TodaysReport.FilenameTrackers  # Make the code a bit more readable/manageable.
		$priorfilenames = $MostRecentReport.FilenameTrackers
		# Structure of these nested loops:
		#    $category = "outer" nest (like "SystemFilesCounts")
		#    $subcategory = per-user/per-location information (like "C:\Users\TestAccount")
		#    $pattern = the pattern or FILES_ key in the actual table.
		$categoryDeltas = @{}
		foreach($category in ($todayfilenames | Get-Member -Type NoteProperty).Name) {
			$subcategoryDeltas = @{}
			foreach($subcategory in ($todayfilenames.$category | Get-Member -Type NoteProperty).Name) {
				$perpatternDeltas = @{}
				foreach($pattern in $TodaysReport.FilenameTrackersPatterns) {
					# If the previous object is null/empty, this might be a new key, move on as there's no delta to measure.
					if($priorfilenames.$category.$subcategory.$pattern -eq $null -Or
						 $priorfilenames.$category.$subcategory.$pattern -eq @{}) { continue }
					# Get the threshold from the Tweaks section.
					$itemThreshold = $TrackedFilenamePatterns.$pattern
					# If it's set to 0 (or less) or isn't an integer, set it to a very high value (effectively neutering it).
					if($itemThreshold -le 0 -Or $itemThreshold -IsNot 'Int32') { $itemThreshold = 99999 }
					# Get the difference between the amount of files matching the given pattern between reports.
					$filenameCountDelta = ($todayfilenames.$category.$subcategory.$pattern `
						- $priorfilenames.$category.$subcategory.$pattern)
					if($filenameCountDelta -ge $itemThreshold) {
						# The threshold was passed, so add the new count and the previous counts the the changed object.
						#    Also, add the filenames and the threshold value.
						$perpatternDeltas.Add($pattern, $todayfilenames.$category.$subcategory.$pattern)
						$perpatternDeltas.Add("Files_$($pattern)", $todayfilenames.$category.$subcategory."Files_$($pattern)")
						$perpatternDeltas.Add("Threshold_$($pattern)", $itemThreshold)
					}
				}
				# Anything added to the per-pattern keys based on a passed threshold? If so, add the subcat to its object.
				if($perpatternDeltas.Keys.Count -gt 0) {
					$subcategoryDeltas.Add($subcategory, $perpatternDeltas)
				}
			}
			# Anything present in the subcategory items? If so, add the category to its object.
			if($subcategoryDeltas.Keys.Count -gt 0) { $categoryDeltas.Add($category, $subcategoryDeltas) }
		}
		# And now that the FOR loops are complete, take a look at categoryDeltas. If the key count is >0 there are changes.
		if($categoryDeltas.Keys.Count -gt 0) { $deltasObject.FilenameViolations = $categoryDeltas }
	} else { $deltasObject.FilenameViolations = @{} }
	
	
	# -----------------------------------------
	# Compare Services.
	Compare-Deltas `
		-CompareProperties $TrackedValues.Services `
		-DeltasObjChanged $deltasObject.ChangedServices `
		-DeltasObjNew $deltasObject.NewServices `
		-DeltasObjRemoved $deltasObject.RemovedServices `
		-Todays $TodaysReport.Services -TodaysIndex $TodaysReport.ServicesIndex `
		-Priors $MostRecentReport.Services -PriorsIndex $MostRecentReport.ServicesIndex
	
	# -----------------------------------------
	# Compare ScheduledTasks.
	Compare-Deltas `
		-CompareProperties $TrackedValues.ScheduledTasks `
		-DeltasObjChanged $deltasObject.ChangedScheduledTasks `
		-DeltasObjNew $deltasObject.NewScheduledTasks `
		-DeltasObjRemoved $deltasObject.RemovedScheduledTasks `
		-Todays $TodaysReport.ScheduledTasks -TodaysIndex $TodaysReport.ScheduledTasksIndex `
		-Priors $MostRecentReport.ScheduledTasks -PriorsIndex $MostRecentReport.ScheduledTasksIndex
	
	# -----------------------------------------
	# Compare StoreApps.
	# Add on the static (always-checked) tracker for the StoreApps section.
	$storeAppsTrackers = $TrackedValues.StoreApps
	$storeAppsTrackers += "PackageUserInformation"
	Compare-Deltas `
		-CompareProperties $storeAppsTrackers `
		-DeltasObjChanged $deltasObject.ChangedStoreApps `
		-DeltasObjNew $deltasObject.NewStoreApps `
		-DeltasObjRemoved $deltasObject.RemovedStoreApps `
		-Todays $TodaysReport.StoreApps -TodaysIndex $TodaysReport.StoreAppsIndex `
		-Priors $MostRecentReport.StoreApps -PriorsIndex $MostRecentReport.StoreAppsIndex
	
	# -----------------------------------------
	# Compare StartupApps.
	Compare-Deltas `
		-CompareProperties $TrackedValues.StartupApps `
		-DeltasObjChanged $deltasObject.ChangedStartupApps `
		-DeltasObjNew $deltasObject.NewStartupApps `
		-DeltasObjRemoved $deltasObject.RemovedStartupApps `
		-Todays $TodaysReport.StartupApps -TodaysIndex $TodaysReport.StartupAppsIndex `
		-Priors $MostRecentReport.StartupApps -PriorsIndex $MostRecentReport.StartupAppsIndex
	
	# -----------------------------------------
	# Compare InstalledApps.
	Compare-Deltas `
		-CompareProperties $TrackedValues.InstalledApps `
		-DeltasObjChanged $deltasObject.ChangedInstalledApps `
		-DeltasObjNew $deltasObject.NewInstalledApps `
		-DeltasObjRemoved $deltasObject.RemovedInstalledApps `
		-Todays $TodaysReport.InstalledApps -TodaysIndex $TodaysReport.InstalledAppsIndex `
		-Priors $MostRecentReport.InstalledApps -PriorsIndex $MostRecentReport.InstalledAppsIndex
		
	
	# Compare the AMOUNT of keys in each item within the deltasObject against its blank "dummy" variable.
	# If the amount of keys differs in any way that means some changes were added and the deltas must be noted.
	#  NOTE: Don't want to compare "OnlineStatusChange" and "InvokableChange" since these aren't object containers.
	$deltasOnDeltasOnDeltas = $deltasObjectDummy.Keys | ForEach-Object {
		if($_ -eq "OnlineStatusChange" -Or $_ -eq "InvokableChange") { $True }
		else { $deltasObjectDummy[$_].Count -eq $deltasObject[$_].Count }
	}
	# If a change was detected, add the $deltasObject onto the primary $deltas variable with the
	#    client hostname to track each change.
	if(
		($deltasOnDeltasOnDeltas.Contains($False)) -Or
		($deltasObject.InvokableChange -eq $True) -Or
		($deltasObject.OnlineStatusChange -eq $True)
	) { $deltas.Add("$($client.Hostname)", $deltasObject) | Out-Null }
	
	
	#####################################################################
	# CLEANUP SECTION.
	# Clean up the script and reports according to the retention policy.
	Clean-Reports "$($client.Hostname)"
}




####################################################################################
# NOTIFICATION GENERATION
# Use the notification format that's easily replaceable (see Tweaks section).

# Firstly, check if the $deltas object contains any keys from the operations above.
#    If not, don't bother generating a notification unless specified in the configuration.
if($deltas.Count -gt 0 -And $NoNotifications -eq $False) {
	Write-Host "`n`nComparing deltas and generating a notification if applicable." -ForegroundColor White
	# Create an outer wrapper for the loop below, to detect if any info is picked up at all.
	$NOTIFBODY_Wrapper = ""
	# Now process the information from the deltas and generate a notification if needed.
	foreach($client in $deltas.Keys) {
		# Declare a new "tracker" variable/container for all report info returned from the categories.
		#    If this is blank for any reason, the client will ommitted.
		$NOTIFBODY_Rpt = ""
		# Set the $clientDeltas object equal to the per-client changes so they can be iterated.
		$clientDeltas = $deltas.$client
		
		<# First thing to do is check that the Invokable or Online statuses have changed, because if they have,
		 #    the rest of the object won't matter to parse.
		 #    This is noteworthy because it prevents a host from coming back online after an "outage" and having ALL
		 #    of its Services, Apps, etc. being registered as "new" in notifications.
		 # NOTE: A drawback to this is a host coming back online after an outage and having NEW apps on it since the last
		 #        test while the target was online previously.
		 #>
		if((($clientDeltas.OnlineStatusChange -eq $True) -Or ($clientDeltas.InvokableChange -eq $True)) -And
			($NotificationsTriggers.ReachabilityChange -eq $True)) {
			# Read the newly-generated report back in just for this, to get the previous online & invokable statuses.
			$TodaysReport = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
				| Sort-Object LastWriteTime | Select-Object -Last 1)[0].Name
			$TodaysReport = Get-Content "$ReportsDirectory\$TodaysReport" | ConvertFrom-Json
			if($clientDeltas.OnlineStatusChange -eq $True) {
				$newStatus = -Not $TodaysReport.IsOnline
				$NOTIFBODY_Rpt += "<span class='SectionHeader'>Client Online</span><br />`n<div class='DiffsSection'>`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLPriorValClass'>$($TodaysReport.IsOnline)</span><br />`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLNewValClass'>$newStatus</span><br />`n"
			} elseif ($clientDeltas.InvokableChange -eq $True) {
				$newStatus = -Not $TodaysReport.Invokable
				$NOTIFBODY_Rpt += "<span class='SectionHeader'>Invokable</span><br />`n<div class='DiffsSection'>`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLPriorValClass'>$($TodaysReport.Invokable)</span><br />`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLNewValClass'>$newStatus</span><br />`n"
			}
			# One of the two above will always be True, so just close the div tag here.
			$NOTIFBODY_Rpt += "</div>"
			# Move to the next client. This is all we need from the current one.
			$NOTIFBODY += "`n`n<hr /><h2>$client</h2>`n"
			$NOTIFBODY += $NOTIFBODY_Rpt
			continue
		}
		
		
		# -----------------------------------------
		# FILENAME PATTERNS
		if($FilenameTracking -eq $True -And $clientDeltas.FilenameViolations.Count -gt 0) {
			$violations = $clientDeltas.FilenameViolations
			$allTables = ""
			# Structure of these nested loops:
			#    $category = "outer" nest (like "SystemFilesCounts")
			#    $subcategory = per-user/per-location information (like "C:\Users\TestAccount")
			#    $pattern = the pattern or FILES_ key in the actual table.
			foreach($category in $violations.Keys) {
				foreach($subcategory in $violations.$category.Keys) {
					# Set up a variable to patchwerk into the final value to add to the notification.
					$addToReport = $violations.$category.$subcategory
					# Automatically set the "subcategory" field as the Location member.
					$addToReport | Add-Member -Name Location -Value $subcategory -Type NoteProperty
					# For each tracked pattern, check the keys in the object against them (improve later) and clean from there.
					#    This helps to easily generate some tables that correspond dynamically to each entered/tracked pattern.
					foreach($item in $TrackedFilenamePatterns.Keys) {
						$selectedFields = @()
						$violations.$category.$subcategory.Keys | ForEach-Object { if($_ -Like "*$($item)*") { $selectedFields += $_ } }
						$selectedFields += "Location"
						# If "selectedFields" contains more than just "Location" a table should be generated.
						if($selectedFields.Count -gt 1) {
							$intermediateTable = (($addToReport | ConvertTo-Json | ConvertFrom-Json) | Select-Object $selectedFields `
								| ConvertTo-Html -Fragment)
							# Cheaply and hackily replace some of the table-header field names after the fact.
							$intermediateTable = $intermediateTable -Replace ">Files_$([Regex]::Escape($item))</th", ">Most Recent Files</th"
							$intermediateTable = $intermediateTable -Replace ">Threshold_$([Regex]::Escape($item))</th", ">Threshold to Pass</th"
							$intermediateTable = $intermediateTable -Replace ">$([Regex]::Escape($item))</th", ">Occurrences</th"
							# Add it to the tables string and thusly onto the body pipeline.
							$allTables += "<b>Pattern</b>: $($item)<br />`n" + $intermediateTable + "<br />`n"
						}
					}
				}
			}
			# Convert the collection of objects into a custom object, select the needed fields, and output a clean HTML table.
			$fillvar = $allTables #(@($outputArray) | ConvertTo-Json | ConvertFrom-Json) | Select-Object $preservedProperties | ConvertTo-Html -Fragment
			# Add the collected information to the report.
			$NOTIFBODY_Rpt += "<span class='SectionHeader'>Filename Trackers</span><br />`n"
			$NOTIFBODY_Rpt += "<div class='DiffsSection'>`n"
			$NOTIFBODY_Rpt += "$($fillvar)<br />`n"
			$NOTIFBODY_Rpt += "</div>`n"
		}
		
		
		# Now that the reachability flags & filenames are reviewed, the rest should be easy variable-matching and iterating keys.
		#    Use a modularized function to add to the report body if the given category/section is enabled with the triggers.
		
		# -----------------------------------------
		# INSTALLED APPLICATIONS
		if($NotificationsTriggers.InstalledAppsChange -eq $True) {
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewInstalledApps -RemovedObject $clientDeltas.RemovedInstalledApps `
				-ChangedObject $clientDeltas.ChangedInstalledApps -ItemName "Installed Applications" `
				-ItemType "InstalledApps"
		}
	
		# -----------------------------------------
		# SERVICES
		$STATUS_CODES = @{
			code1="Stopped"; code2="Start-Pending"; code3="Stop-Pending"
			code4="Running"; code5="Continue"; code6="Pause-Pending"; code7="Paused"
			code=""
		}
		$START_TYPES = @{ code0="Boot"; code1="System"; code2="Automatic"; code3="Manual"; code4="Disabled"; code="" }
		$SERVICE_TYPES = @{
			code1="Kernel-Driver"; code2="FS-Driver"; code4="HW-Driver"
			code8="FS-Startup-Driver"; code16="Normal"; code32="Shared"; code256="Interactive"
			code=""
		}
		if($NotificationsTriggers.ServicesChange -eq $True) {
			# Change numeric codes to their equivalent values IF the value in each item is numeric.
			#    This usually only happens when scanning localhost, but others using the script may encounter them.
			$clientDeltas.ChangedServices.Keys | ForEach-Object {
				$clientDeltas.ChangedServices.$_.Status = (Interpret-Flags -FlagSet $STATUS_CODES `
					-GivenValue $clientDeltas.ChangedServices.$_.Status).TrimEnd()
				$clientDeltas.ChangedServices.$_.StartType = (Interpret-Flags -FlagSet $START_TYPES `
					-GivenValue $clientDeltas.ChangedServices.$_.StartType).TrimEnd()
				$clientDeltas.ChangedServices.$_.ServiceType = (Interpret-Flags -FlagSet $SERVICE_TYPES `
					-GivenValue $clientDeltas.ChangedServices.$_.ServiceType -Binary).TrimEnd()
				# Begin priors.
				$clientDeltas.ChangedServices.$_.Status_prior = (Interpret-Flags -FlagSet $STATUS_CODES `
					-GivenValue $clientDeltas.ChangedServices.$_.Status_prior).TrimEnd()
				$clientDeltas.ChangedServices.$_.StartType_prior = (Interpret-Flags -FlagSet $START_TYPES `
					-GivenValue $clientDeltas.ChangedServices.$_.StartType_prior).TrimEnd()
				$clientDeltas.ChangedServices.$_.ServiceType_prior = (Interpret-Flags -FlagSet $SERVICE_TYPES `
					-GivenValue $clientDeltas.ChangedServices.$_.ServiceType_prior -Binary).TrimEnd()
			}
			$clientDeltas.RemovedServices.Keys | ForEach-Object {
				$clientDeltas.RemovedServices.$_.Status = (Interpret-Flags -FlagSet $STATUS_CODES `
					-GivenValue $clientDeltas.RemovedServices.$_.Status).TrimEnd()
				$clientDeltas.RemovedServices.$_.StartType = (Interpret-Flags -FlagSet $START_TYPES `
					-GivenValue $clientDeltas.RemovedServices.$_.StartType).TrimEnd()
				$clientDeltas.RemovedServices.$_.ServiceType = (Interpret-Flags -FlagSet $SERVICE_TYPES `
					-GivenValue $clientDeltas.RemovedServices.$_.ServiceType -Binary).TrimEnd()
			}
			$clientDeltas.NewServices.Keys | ForEach-Object {
				$clientDeltas.NewServices.$_.Status = (Interpret-Flags -FlagSet $STATUS_CODES `
					-GivenValue $clientDeltas.NewServices.$_.Status).TrimEnd()
				$clientDeltas.NewServices.$_.StartType = (Interpret-Flags -FlagSet $START_TYPES `
					-GivenValue $clientDeltas.NewServices.$_.StartType).TrimEnd()
				$clientDeltas.NewServices.$_.ServiceType = (Interpret-Flags -FlagSet $SERVICE_TYPES `
					-GivenValue $clientDeltas.NewServices.$_.ServiceType -Binary).TrimEnd()
			}
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewServices -RemovedObject $clientDeltas.RemovedServices `
				-ChangedObject $clientDeltas.ChangedServices -ItemName "Services" `
				-ItemType "Services"
		}
		
		# -----------------------------------------
		# STORE APPS
		$SA_STATUS_CODES = @{
			code0="Ok"; code1="License-Issue"; code2="Modified"; code4="Tampered"
			code8="Disabled"; code16="Package-Offline"; code32="Deployment"
			code64="Dependency-Issue"; code128="Data-Offline"; code256="Partially-Staged"
			code512="Not-Available"; code1024="Servicing"; code2048="Needs-Remediation"
			code=""
		}
		$ARCHITECTURE_CODES = @{ code0="X86"; code5="ARM"; code9="X64"; code11="Neutral"; code65535="Unknown"; code="" }
		if($NotificationsTriggers.StoreAppsChange -eq $True) {
			# Change numeric codes to their equivalent values IF the value in each item is numeric.
			#    This usually only happens when scanning localhost, but others using the script may encounter them.
			$clientDeltas.ChangedStoreApps.Keys | ForEach-Object {
				$clientDeltas.ChangedStoreApps.$_.Status = (Interpret-Flags -FlagSet $SA_STATUS_CODES `
					-GivenValue $clientDeltas.ChangedStoreApps.$_.Status -Binary).TrimEnd()
				$clientDeltas.ChangedStoreApps.$_.Architecture = (Interpret-Flags -FlagSet $ARCHITECTURE_CODES `
					-GivenValue $clientDeltas.ChangedStoreApps.$_.Architecture).TrimEnd()
				# Begin priors.
				$clientDeltas.ChangedStoreApps.$_.Status_prior = (Interpret-Flags -FlagSet $SA_STATUS_CODES `
					-GivenValue $clientDeltas.ChangedStoreApps.$_.Status_prior -Binary).TrimEnd()
				$clientDeltas.ChangedStoreApps.$_.Architecture_prior = (Interpret-Flags -FlagSet $ARCHITECTURE_CODES `
					-GivenValue $clientDeltas.ChangedStoreApps.$_.Architecture_prior).TrimEnd()
			}
			$clientDeltas.RemovedStoreApps.Keys | ForEach-Object {
				$clientDeltas.RemovedStoreApps.$_.Status = (Interpret-Flags -FlagSet $SA_STATUS_CODES `
					-GivenValue $clientDeltas.RemovedStoreApps.$_.Status -Binary).TrimEnd()
				$clientDeltas.RemovedStoreApps.$_.Architecture = (Interpret-Flags -FlagSet $ARCHITECTURE_CODES `
					-GivenValue $clientDeltas.RemovedStoreApps.$_.Architecture).TrimEnd()
			}
			$clientDeltas.NewStoreApps.Keys | ForEach-Object {
				$clientDeltas.NewStoreApps.$_.Status = (Interpret-Flags -FlagSet $SA_STATUS_CODES `
					-GivenValue $clientDeltas.NewStoreApps.$_.Status -Binary).TrimEnd()
				$clientDeltas.NewStoreApps.$_.Architecture = (Interpret-Flags -FlagSet $ARCHITECTURE_CODES `
					-GivenValue $clientDeltas.NewStoreApps.$_.Architecture).TrimEnd()
			}
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewStoreApps -RemovedObject $clientDeltas.RemovedStoreApps `
				-ChangedObject $clientDeltas.ChangedStoreApps -ItemName "Store Apps" `
				-ItemType "StoreApps"
		}
		
		# -----------------------------------------
		# STARTUP APPS
		if($NotificationsTriggers.StartupAppsChange -eq $True) {
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewStartupApps -RemovedObject $clientDeltas.RemovedStartupApps `
				-ChangedObject $clientDeltas.ChangedStartupApps -ItemName "Startup Apps" `
				-ItemType "StartupApps"
		}
		
		# -----------------------------------------
		# SCHEDULED TASKS APPS
		if($NotificationsTriggers.ScheduledTasksChange -eq $True) {
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewScheduledTasks -RemovedObject $clientDeltas.RemovedScheduledTasks `
				-ChangedObject $clientDeltas.ChangedScheduledTasks -ItemName "Scheduled Tasks" `
				-ItemType "ScheduledTasks"
		}
		
		# ---------- BUILD THE ENTIRE SECTION -----------
		if($NOTIFBODY_Rpt -ne "") {
			# Inject the hostname of the client into the email digest.
			$NOTIFBODY_Wrapper += "`n`n<hr /><h2>$client</h2>`n"
			$NOTIFBODY_Wrapper += $NOTIFBODY_Rpt
		}
	}
	
	# If the notification body is still null, inject the No Client Changes message.
	#    Otherwise, build the full report.
	if($NOTIFBODY_Wrapper.Trim() -eq "" -And $NotificationOnNoChange -eq $True) { $NOTIFBODY += $NotificationsBodyOnNoChange }
	elseif($NOTIFBODY_Wrapper.Trim() -eq "" -And $NotificationOnNoChange -eq $False) { $NOTIFBODY += "No changes detected." }
	else {
		# There were changes registered in the wrapper, so add everything to the primary email body.
		$NOTIFBODY = $NotificationsChangesBodyHeader
		$NOTIFBODY += $NOTIFBODY_Wrapper
	}
	
	# Send the compiled notification to the target address using the SMTP info provided at the top of the script.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NOTIFBODY
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to '$NotificationsAddress' (BCC: '$BCC') has failed!"
	}
} elseif($NotificationOnNoChange -eq $True -And $NoNotifications -eq $False) {
	# Send an email (if enabled) to notify that no changes were detected.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NotificationsBodyOnNoChange
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to '$NotificationsAddress' (BCC: '$BCC') has failed!"
	}
}




####################################################################################
# FINAL CLEANUP & MISC TASKS

# Generate a text file to track differences. This is optional based on whether the parameter to do so is given.
if($DeltasReport -eq $True -And $deltas.Count -gt 0) {
	$currentTime = (Get-Date -UFormat %Y-%m-%d-%H_%M).toString()
	Write-Output $deltas | ConvertTo-Json -Depth 6 | Out-File "$ReportsDirectory\DELTAS-$currentTime.txt"
} elseif($deltas.Count -eq 0) {
	Write-Host "`n`n`nNo changes were detected across the targeted clients." -ForegroundColor Yellow
}

# Notification that the script is finished.
Write-Host "`n`n*****" -NoNewLine
Write-Host " JOB COMPLETE " -NoNewLine -ForegroundColor Green
Write-Host "*****`n"

# Return $deltas in case the person running the script would like to manipulate the given differences.
return $deltas