<#

.SYNOPSIS
Gather, aggregate, and report information from client machines on the domain.
Intended to be run administratively.
.DESCRIPTION
This script will harvest data from client machines on the network using WinRM,
 then compare the differences from the prior report to the most recent one.
Feed the script a text file with the client IPs or hostnames (doesn't matter which) separated line-by-line.
If no file is given, the script will attempt to collect hostnames from the MSAD directory dynamically.
Many variables and settings are "hard-coded" into the script under the "Tweaks" section.
.PARAMETER ClientsList
Optional. The path to a line-delimited file of IPs/hostnames to gather information about.
.PARAMETER DeltasReport
Optional. If included as a switch to the script, a DELTAS text file will be generated in the reports directory.
This will only happen if deltas were actually detected.
.PARAMETER NoNotifications
Optional. If included as a switch to the script, the script will NOT send email notifications at all.
.PARAMETER BCC
Optional. If included, will BCC the target address(es) in the generated notifications.
.EXAMPLE
$0 -ClientsList ".\target_clients.txt" -BCC "Test Name <tname@test.com>, Second Recip <srecip@testing.com>"

#>


# Gather parameters called with the application, and set the initial state as needed.
param(
 	[string]$ClientsList = "use-AD-list",
 	[switch]$DeltasReport = $False,
 	[switch]$NoNotifications = $False,
 	[string]$BCC = ""
)
# Forcibly ignore any errors generated by the script, and do not write them to the CLI.
#$ErrorActionPreference = 'SilentlyContinue'



##################################################
#                     TWEAKS                     #
##################################################
#### Add more initial conditions to the script. Prevents needing many command-line parameters.


# The internal domain suffix of the given/extracted hostnames.
$DomainSuffix = '.thestraightpath.local'
$DomainSuffixRegex = ($DomainSuffix -Replace '\.', '\.') + '$'

# AD username filter; which users to collect when running the Get-ADComputer command (if not supplying a list).
#    Ex: $DomainUserFilter = "(Name -Like 'HOSPITAL-DESKTOP-*') -Or (Name -Like 'FACILITIES-*')"
$DomainUserFilter = "(Name -Like 'wkstn*')"

# The folder in which to store reports for comparison 
$ReportsDirectory = "$ENV:USERPROFILE"

<# How many hours to keep 'reports' in the above directory. After the given hours below,
    reports will be deleted from the directory as the script runs through it.
 #>
$MaxReportRetentionHours = 24

# Where to deliver notifications (which email address).
$NotificationsAddress = 'postmaster@thestraightpath.email'
# The address used as a 'source' on email notifications.
$NotificationsSource = 'Client Monitor <client-monitor@thestraightpath.email>'
# Email notification subject line.
$NotificationsSubject = "Summary of User Environment Changes"
# Which mail server to dispatch the notification to/through, and the target relay port.
$NotificationsServer = 'relay.internaldomain.withoutauthentication.com'
$NotificationsServerPort = 25
 
# Generate a notification even when there aren't any changes? Disabled by default.
#  This is more useful for just knowing when the script is running and monitoring if it's actually doing its job.
$NotificationOnNoChange = $True
# A preformatted template for notifications when there is no change to any clients.
$NotificationsBodyOnNoChange = @"
<h1 class='NoChangeHeader'>No Client Changes</h1>`n
<p class='SummaryText'><b><u>QUERY</u></b>: '$DomainUserFilter'</p>`n
<p class='SummaryText'>There were no client changes detected on the network for client machines.</p>
"@

# By default, all notifications are sent as HTML.
$NotificationsAsHTML = $True
# "Advanced" settings for the HTML notifications. These are just class names for certain objects used in the HTML notifs.
#    They're important to define, less important to change.
$NotificationsHTMLNewValClass = 'NewText'
$NotificationsHTMLPriorValClass = 'PriorText'
$NotificationsHTMLDiffValClass = 'DifferentText'
# HTML templating for the BODY field of notification emails.
#  [[BODYTEXT]] is replaced dynamically with the generated notification.
$NotificationsHTMLWrapper = @"
<html>
<head>
<style>
	body { word-wrap: break-word; font-size: 12px; }
	table { width: 100%; overflow-x: auto; }
	table, th, td { border: 1px solid black; }
	th, td { text-align: left; padding: 10px; }
	th { background-color: #CCCCCC; }
	tr:hover, td:hover { background-color: #EDEDED; }
	hr { padding: 0; margin: 10px auto; border: none; }
	p { font-size: 12px; color: black; }
	h1, h2 { padding: 0; margin: 5px 0; }
	h1 { color: #222222; }
	h2 { color: #560D06; }
	.NoChangeHeader { color: #FF2222; padding: 0; margin: 0; }
	.SummaryText { font-size: 16px; color: black; }
	.$NotificationsHTMLPriorValClass { color: #AA2222; font-size: 14px; }
	.$NotificationsHTMLNewValClass { color: #2222AA; font-size: 14px; }
	.$NotificationsHTMLDiffValClass { font-weight: bold; font-style: italic; }
	.SectionHeader { font-size: 20px; font-weight: bold; text-decoration: underline; }
	div.DiffsSection { margin-left: 20px; }
</style>
</head>
<body>
[[BODYTEXT]]
</body>
</html>
"@


# Tracked values across each given category. These values are used in the "Select-Object" method on the queries
#    for each item in the set returned per category, and also in the later comparisons.
$TrackedValues = @{
	InstalledApps = @("DisplayName", "DisplayVersion", "Publisher", "InstallDate", "InstallLocation")
}

<# The events or triggers used for notifications to be dispatched to the notifications address.
 #    This section effectively turns them on/off. Names are descriptive enough for the purpose.
 #    These are all enabled by default.
 #>
$NotificationsTriggers = @{
	ReachabilityChange = $True
	InstalledAppsChange = $True
	ServicesChange = $True
	StoreAppsChange = $True
	StartupAppsChange = $True
	ScheduledTasksChange = $True
}

# Is the filter a blacklist? If so, anything added to the object in the target sections is selectively FILTERED OUT.
#    Conversely, if set to False (acting as a whitelist) then only the given values/patterns will be allowed.
$NotificationsFiltersBlacklist = $True
# Whether or not to show the text of the below tweak in the generated notification, when an item is filtered out. Default off.
$NotificationsShowFilteredItem = $False
# A string (HTML formatting optional) to insert when an item is filtered from a notification, if the above value is $True.
$NotificationsFilteredIndicator =  "<div class='DiffsSection'><b>[FilteredItem]</b><br /><br /></div>`n"
<# Define strings (wildcards supported) which should be white/black-listed for allowance into notifications.
 #    The strings are ARRAYS of patterns. For example: @("win*","*micro*") will filter anything starting with "win" and
 #    anything containing the substring "micro".
 # NOTE: These filters apply to ALL data fields in the category and should be used with caution.
 #    If a service changes from "Group Policy Service" to "Microsoft GPO Svc" for example, and there's a "micro*" filter,
 #    you won't know about the change.
 #>
$NotificationsFilters = @{
	InstalledApps = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	Services = @{
		New = @()
		Removed = @()
		Changed = @("group policy*", "*windows update*")
		Changed = @("*client license*", "*group policy*", "windows update*")
	}
	StoreApps = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	StartupApps = @{
		New = @()
		Removed = @()
		Changed = @()
	}
	ScheduledTasks = @{
		New = @()
		Removed = @()
		Changed = @()
	}
}



###################################################
#                    FUNCTIONS                    #
###################################################



# Output information about issues encountered in the script, based on the passed code, and exit with the given code.
Function Output-Error() {
	param( [Parameter(Mandatory=$true)][int]$errorCode )
	$errorInfo = switch($errorCode) {
		1 { 'The path provided for the clientsList parameter does not exist.' }
		2 { 'Could not populate a list of client IP addresses to poll.' }
		3 { "Could not find the given ReportsDirectory: $ReportsDirectory" }
		4 { 'Could not get a list of workstations using Get-ADComputer. Please supply a ClientsList to the script if needed.' }
		default { 'Unknown issue.' }
	}
	Write-Host "ERROR" -ForegroundColor Red -NoNewLine; Write-Host ": $errorInfo"
	exit $errorCode
}


# Resolve hostnames to the appropriate IP address and return it.
Function Parse-Hostnames() {
	param( [Parameter(Mandatory=$true)][string]$line )
	# Strip off double-dashes from hostnames that may be prefixed by one (ex. \\WKSTN107)
	$line = $line -Replace '\\'
	# Use the System DNS library to resolve the hostname properly, then fetch the IP property.
	$address = [System.Net.Dns]::GetHostAddresses("$line").IPAddressToString
	# If the amount of returned IPs is greater than 1, this usually implies a link-local IPv6 was returned.
	#   We don't want that, so instead fetch the first IPv4 address in the array.
	if($address -Is [System.Array] -And $address.length -gt 1) {
		$addressOrig = $address
		foreach($ip in $address) { if($ip -Match "^[0-9\.]+$") {$address = $ip; break} }
		# Forcibly nullify the address field if a matching IPv4 address wasn't found.
		#   This prevents the script from iterating through v6 addresses only and just keeping the address variable the same.
		if($address -eq $addressOrig) { $address = $null }
	}
	return $address
}


# Send an email notification to the target address.
#    This wrapper function is only useful because it "injects" the given body into the HTML wrapper (when HTML is enabled).
Function Send-Email() {
	param(
		[Parameter(Mandatory=$True)][string]$RELAYSERVER,
		[Parameter(Mandatory=$True)][int]$RELAYPORT,
		[Parameter(Mandatory=$True)][string]$FROM,
		[Parameter(Mandatory=$True)][string]$TO,
		[Parameter(Mandatory=$True)][string]$SUBJECT,
		[Parameter(Mandatory=$True)][string]$BODY
	)
	# Wrap the message body with the HTML template, if NotificationsAsHTML is set to True.
	if($NotificationsAsHTML -eq $True) {
		$BODY = $NotificationsHTMLWrapper -Replace '\[\[BODYTEXT\]\]', "$BODY"
	} else {
		# WARNING!!!!!!!!!
		# This is a sloppy way to remove HTML, as it will destroy all text wrapped in angle brackets.
		#   Perhaps find a cleaner way to go about this, as it prevents plaintext emails from containing these <> pairs.
		$BODY = $BODY -Replace '<tr>', "`n"
		$BODY = $BODY -Replace '(</td>|</th>)', ' | '
		$BODY = $BODY -Replace '<.*?>'
	}
	# Define a dynamic parameter object to pass to Send-MailMessage.
	$emailParams = @{
		From = $FROM; To = $TO; Subject = $SUBJECT; Body = $BODY; SmtpServer = $RELAYSERVER; Port = $RELAYPORT
	}
	# If there's a BCC argument to the script, split the string into an array of recipients along the comma characters.
	if($BCC -ne "") { $BCC = $BCC.Split(",").Trim(); $emailParams.Add("Bcc", $BCC) }
	# Dispatch the email to the target server.
	Send-MailMessage @emailParams -BodyAsHtml:$NotificationsAsHTML
	# Return the success status of sending the message.
	return $?
}


# Write the report object as a JSON to the target output file.
Function Write-Report() {
	param( [System.Object]$outputJSON = @{} )
	
	# Today's date, format of YYYY-MM-DD-HH_MM
	$dateTag = Get-Date -UFormat %Y-%m-%d-%H_%M
	$targetFile = $ReportsDirectory + "\Report-$($outputJSON.Hostname)-$dateTag.txt"
	
	# Write the output as a JSON object to the report file (targetFile).
	Write-Output $outputJSON | ConvertTo-JSON -Depth 3 | Out-File -FilePath $targetFile
}


# Given a client hostname, clean reports according to the retention policy.
Function Clean-Reports() {
	param( [string]$clientHostname )
	Write-Host "-- Cleaning reports according to the script retention policy ($MaxReportRetentionHours Hours)."
	$TodaysDate = ((Get-Date -UFormat %Y-%m-%d-%H_%M).toString())
	# For each report filename containing the hostname, get the date on the filename and compare to the retention policy.
	foreach($report in (Get-ChildItem -Path "$ReportsDirectory\Report-$clientHostname*").Name) {
	$report -Match '-(\d{4}-\d{2}-\d{2}-\d{2}_\d{2}).txt$' | Out-Null
		if((Get-Date-Delta-Hours "$TodaysDate" "$($matches[1])") -ge $MaxReportRetentionHours) {
			Remove-Item -Confirm:$False -Force -Path "$ReportsDirectory\Report-$clientHostname-$($matches[1]).txt"
		}
	}
}


# Gather a report from a report file, return it as a HashTable.
Function Pull-Report() {
	param( [System.String]$hostname, [System.String]$dateString )
	if(Test-Path ($ReportsDirectory + "\Report-$hostname-$dateString.txt")) {
		return (Get-Content ($ReportsDirectory + "\Report-$hostname-$dateString.txt") | ConvertFrom-Json)
	} else { return $null }
}


# Compare two dates and return the difference in dates.
#    Since the dates are coming from filenames (which can't have a ':' character), replace '_' with ':'.
Function Get-Date-Delta-Hours() {
	param( [string]$dateOne, [string]$dateTwo )
	$dateOne = $dateOne -Replace '_', ':'
	$dateTwo = $dateTwo -Replace '_', ':'
	return ((Get-Date "$dateOne") - (Get-Date "$dateTwo")).TotalHours
}


# Template function to modularize comparing and generating deltas.
Function Compare-Deltas() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjChanged = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjNew = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjRemoved = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$Todays = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$Priors = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$TodaysIndex = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$PriorsIndex = @{},
		[Parameter(Mandatory=$True)][System.Array]$CompareProperties = @()
	)
	foreach($item in $TodaysIndex) {
		# Get the applications from the hashtable, so it can be compared to the prior report.
		$todayObject = $Todays.$item
		$priorObject = $Priors.$item
		# If the object isn't found in the last report, assume it's a new application.
		if($priorObject -eq $null -Or $priorObject -eq @{}) { continue }
		# Compare properties between the two report objects and return it as an array of True/False.
		$diffs = $CompareProperties | ForEach-Object { $todayObject.$_ -ne $priorObject.$_ }
		# If a "True" was found, there was a difference detected.
		if($diffs.Contains($True)) {
			# For each property name to compare, add on the _prior variable with the value of the "Prior" object.
			$CompareProperties | ForEach-Object {
				$todayObject | Add-Member -Name "$($_)_prior" -Value $priorObject.$_ -Type NoteProperty
			}
			# Add it to the object pointer for the deltasObject variable.
			$DeltasObjChanged.Add("$item", $todayObject)
		}
	}
	# Compare the indices of fields to see if an application was added/removed.
	$indexDiffs = Compare-Object $TodaysIndex $PriorsIndex
	foreach($difference in $indexDiffs) {
		$diff = $difference.InputObject
		if($difference.SideIndicator -eq "<=") {
			# The item was added.
			$DeltasObjNew.Add("$diff", $Todays.$diff)
		} elseif($difference.SideIndicator -eq "=>") {
			# The item was removed.
			$DeltasObjRemoved.Add("$diff", $Priors.$diff)
		}
	}
}


# Check the NotificationsFilter variable against the given object to see if it should be filtered out of the notification.
#    If the return value is False, do NOT filter the item (meaning there was no match).
Function Check-Notification-Filter() {
	# FilterType : Which sub-field of "$NotificationsFilters" is being examined?
	# FilterAge  : Is this for "New", "Removed", or "Changed"?
	# ItemValue  : The object that is being checked for a filter match.
	param(
		[Parameter(Mandatory=$True)][string]$FilterType = "",
		[Parameter(Mandatory=$True)][string]$FilterAge = "",
		[Parameter(Mandatory=$True)][PSCustomObject]$ItemValue = @{}
	)
	# Dynamically define the two values for filtering. This is controlled by whether the filtering is white/black-list.
	$DoFilter = $NotificationsFiltersBlacklist
	$DontFilter = (-Not $NotificationsFiltersBlacklist)
	# Set $filters equal to the string array of filter names.
	$filters = $NotificationsFilters.$FilterType.$FilterAge
	# If there aren't any items in the array, no filters are defined, so don't filter anything.
	if($filters.Count -eq 0) { return $DontFilter }
	# Convert the input object into a Hashtable as needed. This allows us to properly use the "Keys" property below.
	$ItemValueHT = @{}
	if(($ItemValue.GetType()).Name -eq 'PSCustomObject') {
		$ItemValue.PSObject.Properties | ForEach-Object { $ItemValueHT[$_.Name] = $_.Value }
	} else { $ItemValueHT = $ItemValue }
	# For each filter string in the array, ...
	foreach($filter in $filters) {
		# Iterate through the ItemValueHT object's keys to see if it matches the current filter.
		$filterMatch = @()
		$ItemValueHT.Keys | ForEach-Object { $filterMatch += ($ItemValueHT.$_ -Like $filter) }
		# If there's a match, immediately notify the script to filter.
		if($filterMatch.Contains($True)) { return $DoFilter }
	}
	# Otherwise, there is no match, so don't filter anything.
	return $DontFilter
}


<# Template function to modularize the repetitive task of adding pieces to the email notification.
 #  For New and Removed objects, it simply iterates the Hashtable keys (after checking if there even are any)
 #    and adds the HTML for each corresponding object under the detected keys.
 #  For Changed objects, the two different objects are spliced together to create a single table to show differences.
 #>
Function Add-To-Report() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$NewObject = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$RemovedObject = @{},
		[Parameter(Mandatory=$True)][PSCustomObject]$ChangedObject = @{},
		[Parameter(Mandatory=$True)][string]$ItemName,
		[Parameter(Mandatory=$True)][string]$ItemType
	)
	# Declare initial local variables.
	# NOTIFSXN later gets extended by underscored/suffixed variables as the script builds the notification.
	$NOTIFSXN = ""
	$spanNewItem = "<span class='$NotificationsHTMLNewValClass'>"
	$spanPriorItem = "<span class='$NotificationsHTMLPriorValClass'>"
	$spanDifferentItem = "<span class='$NotificationsHTMLDiffValClass'>"
	# New Objects section. If the amount of hashtable keys is >0, check notification filters and
	#    then iterate the keys and add the object to the table.
	if($NewObject.Keys.Count -gt 0) {
		$NOTIFSXN_New = "<span class='SectionHeader'>New $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		foreach($new in $NewObject.Keys) {
			# For each key in the new item, check the value of the field against the values in the notification filters.
			$isFiltered = Check-Notification-Filter -FilterType $ItemType -FilterAge "New" -ItemValue $NewObject.$new
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				if($NotificationsShowFilteredItem -eq $True) { $NOTIFSXN_New += $NotificationsFilteredIndicator }
				continue
			}
			$fillVar = $NewObject.$new | ConvertTo-HTML -Fragment
			$NOTIFSXN_New += "<div class='DiffsSection'>`n"
			$NOTIFSXN_New += "$spanNewItem<b>Name</b>: $new</span><br />`n"
			$NOTIFSXN_New += "$spanNewItem$($fillVar)</span><br />`n"
			$NOTIFSXN_New += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_New }
	}
	# Removed Objects section. Same process as the "New Objects" section.
	if($RemovedObject.Keys.Count -gt 0) {
		$NOTIFSXN_Removed = "<span class='SectionHeader'>Removed $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		foreach($removed in $RemovedObject.Keys) {
			# For each key in the removed item, check the value of the field against the values in the notification filters.
			$isFiltered = Check-Notification-Filter -FilterType $ItemType -FilterAge "Removed" -ItemValue $RemovedObject.$removed
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				if($NotificationsShowFilteredItem -eq $True) { $NOTIFSXN_Removed += $NotificationsFilteredIndicator }
				continue
			}
			$fillVar = $RemovedObject.$removed | ConvertTo-HTML -Fragment
			$NOTIFSXN_Removed += "<div class='DiffsSection'>`n"
			$NOTIFSXN_Removed += "$spanPriorItem<b>Name</b>: $removed</span><br />`n"
			$NOTIFSXN_Removed += "$spanPriorItem$($fillVar)</span><br />`n"
			$NOTIFSXN_Removed += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_Removed }
	}
	# Changed Objects section.
	if($ChangedObject.Keys.Count -gt 0) {
		$NOTIFSXN_Changed = "<span class='SectionHeader'>Changed $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		foreach($changed in $ChangedObject.Keys) {
			# ------------- CHECK BOTH OBJECTS WITH FILTERS ---------------
			# For each key in the changed item, check the value of the field against the values in the notification filters.
			$isFiltered = Check-Notification-Filter -FilterType $ItemType -FilterAge "Changed" -ItemValue $ChangedObject.$changed
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				if($NotificationsShowFilteredItem -eq $True) { $NOTIFSXN_Changed += $NotificationsFilteredIndicator }
				continue
			}
			# --------------------------------------------------------------
			# Create two separate objects and merge them together under the same property names.
			#    The objects are split based on the '_prior' suffixes added in the deltas phase of the script.
			$tableNews = @{}; $tablePriors = @{}
			($ChangedObject.$changed | Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike *_prior).Name `
				| Sort-Object | ForEach-Object {
				# Each key will correspond to a fully-HTML value for the "output table" object.
				$diffHighlight=$diffHighlightTerm = ""
				# If the two specific values are different, define a stylization class and wrap the text with it.
				if($ChangedObject.$changed.$_ -ne $ChangedObject.$changed."$($_)_prior") {
					$diffHighlight = $spanDifferentItem; $diffHighlightTerm = "</span>"
				}
				# In short, if the "diff" spans are filled out, the object will be highlighted to show it contains one of the deltas.
				$tableNewsWrapper = "$spanNewItem" + "$diffHighlight" + `
					$ChangedObject.$changed.$_ + "$diffHighlightTerm" + "</span>"
				$tableNews.Add($_,$tableNewsWrapper)
				$tablePriorsWrapper = "$spanPriorItem" + "$diffHighlight" + `
					$ChangedObject.$changed."$($_)_prior" + "$diffHighlightTerm" + "</span>"
				$tablePriors.Add($_, $tablePriorsWrapper)
			}
			# Send the spliced array to the HTML function to output both items under the same headers.
			$tableOut = (@($tablePriors,$tableNews) | ConvertTo-Json | ConvertFrom-Json) | ConvertTo-Html -Fragment
			# Ensure that pieces aren't added to the table as HTML special chars ("&lt;"). Allows for formatting w/ SPAN.
			$finalTable = [System.Web.HttpUtility]::HtmlDecode($tableOut)
			# Add it to the string and close the div tag as appropriate.
			$NOTIFSXN_Changed += "<div class='DiffsSection'>`n"
			$NOTIFSXN_Changed += "<span style='color:black;font-size:14px;'><b>Name</b>: $changed</span><br />`n"
			$NOTIFSXN_Changed += "$finalTable<br />`n"
			$NOTIFSXN_Changed += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_Changed }
	}
	# Send the finished string back.
	return $NOTIFSXN
}


# Interpret compounding flags using a logical AND. Used for report generation.
Function Interpret-Flags() {
	param( [PSCustomObject]$FlagSet = @{}, $GivenValue )
	# If the passed argument for "GivenValue" isn't numeric, then leave with "GivenValue" as the return.
	if($GivenValue.GetType().Name -ne "Int32") { return $GivenValue }
	# Can't do a bitwise AND against a 0, so just automatically default to the flagset's 0 code.
	if($GivenValue -eq 0) { return $FlagSet["code0"] }
	# Initialize the return variable.
	$flagsInfo = ""
	# For each "codeXX" key, strip off the "code" prefix and do a logical AND against the integer to see if that bit is set.
	#    If the bit is set, append the corresponding "codeXX" value from the object onto the return string.
	$FlagSet.Keys | ForEach-Object {
		# Strip the "code" piece from the key.
		$code = $_ -Replace "code"
		# Do a bitwise AND on the givenvalue and the code from the key ID.
		$isMatch = $GivenValue -BAND $code
		# If it matches (ergo the flag is set), append the piece/verb from the flagset onto the return variable.
		if($isMatch -ne 0) { $flagsInfo += $FlagSet["code$($code)"] + " " }
	}
	return $flagsInfo
}



##################################################
#                      MAIN                      #
##################################################


# Ensure that the ReportsDirectory exists.
if(($ReportsDirectory -eq "") -Or (-Not(Test-Path "$ReportsDirectory"))) { Output-Error(3) }

# Initialize an empty array for the client address/hostname pool.
$clientAddresses = [System.Collections.ArrayList]@()

# Check to see whether a clientsList file was provided to the script.
if($clientsList -eq "use-AD-list") {
	$clientNames = Get-ADComputer -Filter $DomainUserFilter | Select-Object -Property Name
	if($? -eq $False) { Output-Error(4)  }
	foreach($line in $clientNames) {
		# May want to verify it's not an IP here but the Get-ADComputer
		#    command doesn't seem to return raw IPs in the "Name" property.
		$hostname = $line.Name
		$address = Parse-Hostnames($hostname)
		# Sanity check, ensuring it's not a duplicate and that it exists.
		if($address -eq $null -Or $clientAddresses.Contains($address)) { continue }
		# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
		if(-Not($hostname -Match $DomainSuffixRegex)) { $hostname = $hostname + $DomainSuffix }
		# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
		$localObject = @{IP = ''; Hostname = ''}
		$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
		$clientAddresses += $localObject
	}
} else {
	# Make sure the clientsList file exists. If not, exit.
	if(-Not(Test-Path $ClientsList)) { Output-Error(1) }

	# Parse each line in the clientsList file.
	foreach($line in Get-Content $ClientsList) {
		# Check to see whether the line matches a hostname or an IPv4 address.
		if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$' -Or $line -Match '\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}\b') {
			$address=$addressOrig=$hostname = $null
			# If it's a hostname, resolve it to an IPv4 address. Otherwise, just capture the IP.
			if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$') {
				$address = Parse-Hostnames($line)
				$hostname = $line -Replace '\\'
			} else {
				$address = $line
				# Get the hostname from the IP, or at least attempt to.Res
				$hostname = [System.Net.Dns]::Resolve([string]$address).HostName
			}
			# If a valid address couldn't be captured, or if the clientAddresses array already contains it,
			#    consider the entry invalid and continue to the next one.
			if($address -eq $null -Or $clientAddresses.Contains($address)) { continue }
			# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
			if((-Not($hostname -Match $DomainSuffixRegex)) -And (-Not($hostname -Match '^LOCALHOST\.?'))) {
				$hostname = $hostname + $DomainSuffix
			}
			# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
			$localObject = @{IP = ''; Hostname = ''}
			$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
			$clientAddresses += $localObject
		}
	}
}




# Check whether or not $clientAddresses has been properly populated. If not, exit.
if($clientAddresses -eq $null -Or $clientAddresses.length -eq 0) { Output-Error(2) }

# Define a base object to hold deltas between yesterday and today.
$deltas = @{}

# Iterate through each client and generate the report.
foreach($client in $clientAddresses) {
	# Aesthetix.
	Write-Host "`n`n"
	
	# Build a base for the newest report object to be generated.
	$FullReport = [ordered]@{
		IP = "$($client.IP)"; Hostname = "$($client.Hostname)"
		IsOnline = $False; Invokable = $False
	}
	# Template an object to track any changes from the most recent report to the newest one.
	$deltasObject = [ordered]@{
		OnlineStatusChange = $False; InvokableChange = $False
		NewServices = @{}; RemovedServices = @{};	ChangedServices = @{}
		NewInstalledApps = @{}; RemovedInstalledApps = @{}; ChangedInstalledApps = @{}
		NewStoreApps = @{}; RemovedStoreApps = @{}; ChangedStoreApps = @{}
		NewStartupApps = @{}; RemovedStartupApps = @{}; ChangedStartupApps = @{}
		NewScheduledTasks = @{}; RemovedScheduledTasks = @{}; ChangedScheduledTasks = @{}
	}
	# Create a "dummy" (reference) object for the null array.
	$deltasObjectDummy = $deltasObject | Select-Object *
	
	# Write the current client to the terminal/host for tracking/debugging.
	Write-Host "Hostname: " -NoNewLine
	Write-Host "$($client.Hostname)" -ForegroundColor Cyan
	Write-Host "IP: " -NoNewLine
	Write-Host "$($client.IP)" -ForegroundColor Cyan
	
	Write-Host "-- Pulling prior report."
	# Collect the top of the list for most recent files/reports matching the given hostname.
	#    If an object isn't returned from the query below, assume there is no "prior" report and act accordingly.
	$LastReportMade = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
		| Sort-Object LastWriteTime | Select-Object -Last 1)
	if($LastReportMade.Length -le 0) {
		Write-Host "**** No prior report found. Setting the comparison object to the default reference."
		$MostRecentReport = $FullReport
	} else {
		$LastReportMade = $LastReportMade[0].Name
		# Bring the previous report and the recent report into the script.
		$DateofLastReport = [Regex]::Matches($LastReportMade, '\d{4}-\d{2}-\d{2}-\d{2}_\d{2}')[0].Value
		$MostRecentReport = Pull-Report "$($client.Hostname)" "$DateofLastReport"
	}
	
	
	# Create a parameters object for Invoke.
	$invokeParams = @{}
	# Is the tested client the local host? If not, set the ComputerName parameter to the client hostname.
	if(-Not($client.Hostname -Match '^LOCALHOST\.?')) {
		$invokeParams.Add("ComputerName", "$($client.Hostname)")
	}
	
	Write-Host "-- Running connectivity tests for WinRM and ICMP."
	
	# Run a basic ICMP ping test against the target to see if it's online. Add it to the report.
	Test-Connection "$($client.Hostname)" -Count 1 | Out-Null
	$FullReport.IsOnline = $?
	
	# Check if the target is invokable at all, i.e. can we run WinRM commands on it?
	Invoke-Command @invokeParams -ScriptBlock { Get-Culture } | Out-Null
	$FullReport.Invokable = $?
	
	# Compare invokability and availability to the last report, as long as this ISN'T the first report.
	if((($FullReport.Invokable -ne $MostRecentReport.Invokable) -Or
			($FullReport.IsOnline -ne $MostRecentReport.IsOnline)) -And
			(-Not($LastReportMade.Length -le 0))) {
			$deltasObject.OnlineStatusChange = ($FullReport.IsOnline -ne $MostRecentReport.IsOnline)
			$deltasObject.InvokableChange = ($FullReport.Invokable -ne $MostRecentReport.Invokable)
			$deltas.Add("$($client.Hostname)", $deltasObject)	
		}
	
	# The target host cannot be invoked. Note this, generate the report, clean old reports, and skip.
	if ($FullReport.Invokable -eq $False) {
		Write-Host "**** WinRM is not active on the target."
		Write-Report($FullReport)
		Clean-Reports "$($client.Hostname)"
		continue
	}
	
	
	<# Harvest an object full of data from the client.
	 #   PSParentPath is using the registry key where we've found the entry, so it shouldn't ever be null.
	 #   PSChildName is the registry key's name. So if there is not any other info, at least get the key name.
	 #>
	 
	Write-Host "-- Collecting information about the target machine."
	
	
	# -----------------------------------------
	# Collect installed applications at multiple layers.
	$installedAppsObject = Invoke-Command @invokeParams -ScriptBlock {
		$installedApps = @()
		# Local Machine applications.
		$installedApps += Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
		# Current User applications.
		$installedApps += Get-ItemProperty HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
		# 64-to-32-bit applications.
		$installedApps += Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*
		# Send back the aggregated object.
		return $installedApps
	}
	# Define the two objects to insert into the main report hashtable.
	$reportInstalledApps = @{}; $installedAppsIndex = @()
	foreach($app in $installedAppsObject) {
		# Append a suffix onto each index to ensure uniqueness, based on which part of the registry the key lives in.
		$keysuffix = "_"
		if($app.PSPath -Match 'Wow6432Node') { $keysuffix += '6432Node' }
		elseif($app.PSPath -Match '::HKEY_CURRENT') { $keysuffix += 'HKCU' }
		elseif($app.PSPath -Match '::HKEY_LOCAL') { $keysuffix += 'HKLM' }
		else { $keysuffix += '?' }
		$keyname = "$($app.PSChildName)" + $keysuffix
		# Add the keyname onto the index.
		$installedAppsIndex += $keyname
		# Create the key in the hashtable.
		$reportInstalledApps.Add($keyname, ($installedAppsObject | Where-Object -Property PSPath -eq "$($app.PSPath)" `
			| Select-Object $TrackedValues.InstalledApps | ConvertTo-Json | ConvertFrom-Json))
	}
	# Add the items to the new report.
	$FullReport.Add("InstalledAppsIndex", $installedAppsIndex)
	$FullReport.Add("InstalledApps", $reportInstalledApps)
	
		
	# -----------------------------------------
	# Harvest Windows Store-based applications.
	$priorELVL = $ErrorActionPreference; $ErrorActionPreference = 'SilentlyContinue'   # shhhh...
	# Get the store apps a single time and run all computations on the LOCAL side! (fix to Issue #1 on GitHub).
	$storeAppsList = Invoke-Command @invokeParams -ScriptBlock { Get-AppxPackage -AllUsers }
	# If there was an issue getting the list, write it out and move on.
	if($storeAppsList.Count -eq 0) {
		Write-Host "~~~~~ Store apps couldn't be captured for this client. Please verify administrative permissions."
	}; $ErrorActionPreference = $priorELVL
	$reportStoreApps = @{}
	# Iterate the list of store apps.
	foreach($app in $storeAppsList) {
		$keyname = "$($app.InstallLocation)"
		$i = 0  #Keep track of the "layer"
		for(; $i -lt 4; $i++) {
			# Allow up to 4 nested key names, each successive duplicate being suffixed by an extra underscore.
			if($reportStoreApps.ContainsKey($keyname)) { $keyname += "_" }
		}
		# NOTE: This section has added 15-20 seconds in per-client processing.
		$storeAppsInfo = ($storeAppsList | Where-Object -Property InstallLocation -eq "$($app.InstallLocation)" `
			| Select-Object Name, Architecture, InstallLocation, Status, PublisherId) #json conversions WERE here
		$perUserAppStatus = ($storeAppsList | Where-Object -Property InstallLocation -eq "$($app.InstallLocation)" `
			| Select-Object PackageUserInformation) | ForEach-Object {
				[System.String]::Join("; ", @("App Status:", [string]@(("$($_.PackageUserInformation)" `
					| Select-String -Pattern '\[[\\\w]+\]\s*\:\s+\w+' -AllMatches).Matches.Value) | Out-String))
			}
		# Add the PackageUserInformation property (with extracted names/statuses) into the final object.
		$storeAppsInfo | Add-Member -Name PackageUserInformation -Type NoteProperty -Value "$($perUserAppStatus)"
		$reportStoreApps.Add($keyname, $storeAppsInfo)
	}
	# Get an index of store apps based on the InstallLocation.
	$storeAppsIndex = [System.Collections.ArrayList]@()
	$storeAppsList | ForEach-Object {
		$keyname = "$($_.InstallLocation)"
		for($i = 0; $i -lt 4; $i++) { if($storeAppsIndex.Contains($keyname)) { $keyname += "_" } }
		$storeAppsIndex += $keyname
	}
	$storeAppsIndexFIX = @(); $storeAppsIndexFIX += $storeAppsIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("StoreAppsIndex", $storeAppsIndexFIX)
	$FullReport.Add("StoreApps", $reportStoreApps)
	
	
	# -----------------------------------------
	# Harvest startup applications.
	$reportStartupApps = Invoke-Command @invokeParams -ScriptBlock {
		$startupAppsObject = @{}
		# Get Startup apps using the below command. This will catch everything except 6432 Nodes in the registry.
		$w32StartupCmd = Get-CimInstance Win32_StartupCommand
		foreach($startupapp in $w32StartupCmd) {
			$startupAppsObject.Add("$($startupapp.Name)_$($startupapp.User)", `
				($w32StartupCmd | Where-Object -Property Name -eq "$($startupapp.Name)" `
					| Where-Object -Property User -eq "$($startupapp.User)" `
					| Select-Object Command, Location, User | ConvertTo-Json | ConvertFrom-Json))
		}
		# Get Startup apps from the location mentioned above.
		$6432NodeItems = (Get-ItemProperty HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run) `
			| Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike PS*
		# Add each one onto the startup apps that are registered for the client.
		foreach($item in $6432NodeItems) {
			$startupAppsObject.Add("$($item.Name)_6432-NODE", `
				@{Command="$($item.Definition -Replace 'string ')"; Location="64-to-32_Registry_Node"; User="6432-NODE"})
		}
		return $startupAppsObject
	}
	# Index StartupApps by the "Name" key.
	$startupAppsIndex = Invoke-Command @invokeParams -ScriptBlock {
		$startupAppsArray = [System.Collections.ArrayList]@()
		Get-CimInstance Win32_StartupCommand | ForEach-Object { $startupAppsArray += "$($_.Name)_$($_.User)" }
		Get-ItemProperty HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run `
			| Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike PS* | ForEach-Object {
				$startupAppsArray += "$($_.Name)_6432-NODE"
			}
		return $startupAppsArray
	}
	$startupAppsIndexFIX = @(); $startupAppsIndexFIX += $startupAppsIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("StartupAppsIndex", $startupAppsIndexFIX)
	$FullReport.Add("StartupApps", $reportStartupApps)
		
	
	# -----------------------------------------
	# Get a list of services (all of them).
	$reportServices = Invoke-Command @invokeParams -ScriptBlock {
		$svcObject = @{}
		$svcs = Get-Service
		foreach($service in $svcs) {
			$svcObject.Add("$($service.DisplayName)_$($service.Name)", `
				($svcs | Where-Object -Property DisplayName -eq "$($service.DisplayName)" `
					| Where-Object -Property Name -eq "$($service.Name)" `
					| Select-Object DisplayName, ServiceName, ServiceType, StartType, Status | ConvertTo-Json | ConvertFrom-Json))
		}
		return $svcObject
	}
	# Get an index of all "DisplayName_Name" unique keys.
	$servicesIndex = Invoke-Command @invokeParams -ScriptBlock {
		$svcNameArray = [System.Collections.ArrayList]@()
		Get-Service | ForEach-Object { $svcNameArray += "$($_.DisplayName)_$($_.Name)" }
		return $svcNameArray
	}
	$servicesIndexFIX = @(); $servicesIndexFIX += $servicesIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("ServicesIndex", $servicesIndexFIX)
	$FullReport.Add("Services", $reportServices)
	
	
	# -----------------------------------------
	# Get scheduled tasks and jobs.
	$reportTasks = Invoke-Command @invokeParams -ScriptBlock {
		$taskObject = @{}
		$taskList = Get-ScheduledTask
		foreach($task in $taskList) {
			$taskObject.Add("$($task.URI)", `
				($taskList | Where-Object -Property URI -eq "$($task.URI)" `
					| Select-Object TaskName, Author, SecurityDescriptor, TaskPath | ConvertTo-Json | ConvertFrom-Json))
		}
		return $taskObject
	}
	# Get an index of all "TaskName" keys.
	$scheduledTasksIndex = Invoke-Command @invokeParams -ScriptBlock {
		$taskURIArray = [System.Collections.ArrayList]@()
		Get-ScheduledTask | ForEach-Object { $taskURIArray += "$($_.URI)" }
		return $taskURIArray
	}
	$scheduledTasksIndexFIX = @(); $scheduledTasksIndexFIX += $scheduledTasksIndex | ForEach-Object { [string]$_ }
	# Add it to the report.
	$FullReport.Add("ScheduledTasksIndex", $scheduledTasksIndexFIX)
	$FullReport.Add("ScheduledTasks", $reportTasks)
	
	
	# -----------------------------------------
	# Generate the final report file with all of the information.
	Write-Report($FullReport)
	
	
	
	#####################################################################
	# COMPARISON SECTION.
	# All comparisons will use the most recent report as the reference object, comparing AGAINST the prior report.
	Write-Host "-- Comparing the differences between the generated report and the prior report."
	# Stop here if the file is the first in the line of reports.
	if($LastReportMade.Length -le 1) {
		Write-Host "**** Client does not have a prior report to provide a comparison to the new report. Skipping comparisons..."
		continue
	}
	# HashTable -> JSON -> HashTable, so that it matches the conversion that the $MostRecentReport variable went through.
	$FullReportIntermediate = $FullReport | ConvertTo-Json -Depth 3
	$TodaysReport = $FullReportIntermediate | ConvertFrom-Json
	
	# -----------------------------------------
	# Compare Services.
	Compare-Deltas `
		-CompareProperties @("DisplayName", "ServiceName", "ServiceType", "StartType", "Status") `
		-DeltasObjChanged $deltasObject.ChangedServices `
		-DeltasObjNew $deltasObject.NewServices `
		-DeltasObjRemoved $deltasObject.RemovedServices `
		-Todays $TodaysReport.Services -TodaysIndex $TodaysReport.ServicesIndex `
		-Priors $MostRecentReport.Services -PriorsIndex $MostRecentReport.ServicesIndex
	
	# -----------------------------------------
	# Compare ScheduledTasks.
	Compare-Deltas `
		-CompareProperties @("TaskName", "TaskPath", "Author", "SecurityDescriptor") `
		-DeltasObjChanged $deltasObject.ChangedScheduledTasks `
		-DeltasObjNew $deltasObject.NewScheduledTasks `
		-DeltasObjRemoved $deltasObject.RemovedScheduledTasks `
		-Todays $TodaysReport.ScheduledTasks -TodaysIndex $TodaysReport.ScheduledTasksIndex `
		-Priors $MostRecentReport.ScheduledTasks -PriorsIndex $MostRecentReport.ScheduledTasksIndex
	
	# -----------------------------------------
	# Compare StoreApps.
	Compare-Deltas `
		-CompareProperties @("Name", "Architecture", "InstallLocation", "Status", "PublisherId", "PackageUserInformation") `
		-DeltasObjChanged $deltasObject.ChangedStoreApps `
		-DeltasObjNew $deltasObject.NewStoreApps `
		-DeltasObjRemoved $deltasObject.RemovedStoreApps `
		-Todays $TodaysReport.StoreApps -TodaysIndex $TodaysReport.StoreAppsIndex `
		-Priors $MostRecentReport.StoreApps -PriorsIndex $MostRecentReport.StoreAppsIndex
	
	# -----------------------------------------
	# Compare StartupApps.
	Compare-Deltas `
		-CompareProperties @("Command", "Location", "User") `
		-DeltasObjChanged $deltasObject.ChangedStartupApps `
		-DeltasObjNew $deltasObject.NewStartupApps `
		-DeltasObjRemoved $deltasObject.RemovedStartupApps `
		-Todays $TodaysReport.StartupApps -TodaysIndex $TodaysReport.StartupAppsIndex `
		-Priors $MostRecentReport.StartupApps -PriorsIndex $MostRecentReport.StartupAppsIndex
	
	# -----------------------------------------
	# Compare InstalledApps.
	Compare-Deltas `
		-CompareProperties $TrackedValues.InstalledApps `
		-DeltasObjChanged $deltasObject.ChangedInstalledApps `
		-DeltasObjNew $deltasObject.NewInstalledApps `
		-DeltasObjRemoved $deltasObject.RemovedInstalledApps `
		-Todays $TodaysReport.InstalledApps -TodaysIndex $TodaysReport.InstalledAppsIndex `
		-Priors $MostRecentReport.InstalledApps -PriorsIndex $MostRecentReport.InstalledAppsIndex
		
	
	# Compare the AMOUNT of keys in each item within the deltasObject against its blank "dummy" variable.
	# If the amount of keys differs in any way that means some changes were added and the deltas must be noted.
	#  NOTE: Don't want to compare "OnlineStatusChange" and "InvokableChange" since these aren't object containers.
	$deltasOnDeltasOnDeltas = $deltasObjectDummy.Keys | Foreach-Object {
		if($_ -eq "OnlineStatusChange" -Or $_ -eq "InvokableChange") { $True }
		else { $deltasObjectDummy[$_].Count -eq $deltasObject[$_].Count }
	}
	# If a change was detected, add the $deltasObject onto the primary $deltas variable with the
	#    client hostname to track each change.
	if(
		($deltasOnDeltasOnDeltas.Contains($False)) -Or
		($deltasObject.InvokableChange -eq $True) -Or
		($deltasObject.OnlineStatusChange -eq $True)
	) { $deltas.Add("$($client.Hostname)", $deltasObject) | Out-Null }
	
	
	#####################################################################
	# CLEANUP SECTION.
	# Clean up the script and reports according to the retention policy.
	Clean-Reports "$($client.Hostname)"
}




####################################################################################
# NOTIFICATION GENERATION
# Use the notification format that's easily replaceable (see Tweaks section).

# Firstly, check if the $deltas object contains any keys from the operations above.
#    If not, don't bother generating a notification unless specified in the configuration.
if($deltas.Count -gt 0 -And $NoNotifications -eq $False) {
	$NOTIFBODY = "<h1>Summary of Environment Changes</h1>`n`n"
	$NOTIFBODY += "<p class='SummaryText'><b><u>QUERY</u></b>: '$DomainUserFilter'</p>`n"
	$NOTIFBODY += "<p class='SummaryText'>There were changes detected on the network for the following clients. "
	$NOTIFBODY += "Anything in <span class='$NotificationsHTMLPriorValClass'>red</span> is a removed property, "
	$NOTIFBODY += "and anything in <span class='$NotificationsHTMLNewValClass'>blue</span> has been added.</p>`n`n"
	# Now process the information from the deltas and generate a notification if needed.
	foreach($client in $deltas.Keys) {
		# Declare a new "tracker" variable/container for all report info returned from the categories.
		#    If this is blank for any reason, the client will ommitted.
		$NOTIFBODY_Rpt = ""
		# Set the $clientDeltas object equal to the per-client changes so they can be iterated.
		$clientDeltas = $deltas.$client
		
		<# First thing to do is check that the Invokable or Online statuses have changed, because if they have,
		 #    the rest of the object won't matter to parse.
		 #    This is noteworthy because it prevents a host from coming back online after an "outage" and having ALL
		 #    of its Services, Apps, etc. being registered as "new" in notifications.
		 # NOTE: A drawback to this is a host coming back online after an outage and having NEW apps on it since the last
		 #        test while the target was online previously.
		 #>
		if((($clientDeltas.OnlineStatusChange -eq $True) -Or ($clientDeltas.InvokableChange -eq $True)) -And
			($NotificationsTriggers.ReachabilityChange -eq $True)) {
			# Read the newly-generated report back in just for this, to get the previous online & invokable statuses.
			$TodaysReport = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
				| Sort-Object LastWriteTime | Select-Object -Last 1)[0].Name
			$TodaysReport = Get-Content "$ReportsDirectory\$TodaysReport" | ConvertFrom-Json
			if($clientDeltas.OnlineStatusChange -eq $True) {
				$newStatus = -Not $TodaysReport.IsOnline
				$NOTIFBODY_Rpt += "<span class='SectionHeader'>Client Online</span><br />`n<div class='DiffsSection'>`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLPriorValClass'>$($TodaysReport.IsOnline)</span><br />`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLNewValClass'>$newStatus</span><br />`n"
			} elseif ($clientDeltas.InvokableChange -eq $True) {
				$newStatus = -Not $TodaysReport.Invokable
				$NOTIFBODY_Rpt += "<span class='SectionHeader'>Invokable</span><br />`n<div class='DiffsSection'>`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLPriorValClass'>$($TodaysReport.Invokable)</span><br />`n"
				$NOTIFBODY_Rpt += "<span class='$NotificationsHTMLNewValClass'>$newStatus</span><br />`n"
			}
			# One of the two above will always be True, so just close the div tag here.
			$NOTIFBODY_Rpt += "</div>"
			# Move to the next client. This is all we need from the current one.
			$NOTIFBODY += "`n`n<hr /><h2>$client</h2>`n"
			$NOTIFBODY += $NOTIFBODY_Rpt
			continue
		}
		
		# Now that the reachability flags are reviewed, the rest should be easy variable-matching and iterating keys.
		# This process is repeated almost identically for each object and can probably be modularized later to trim fat.
		#  --> Get counts of keys in each delta field.
		#  ----> Count > 0 ? add-to-report : ignore
		# "New" and "Removed" apps don't need a "comparison" section.
		
		# -----------------------------------------
		# INSTALLED APPLICATIONS
		if($NotificationsTriggers.InstalledAppsChange -eq $True) {
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewInstalledApps -RemovedObject $clientDeltas.RemovedInstalledApps `
				-ChangedObject $clientDeltas.ChangedInstalledApps -ItemName "Installed Applications" `
				-ItemType "InstalledApps"
		}
	
		# -----------------------------------------
		# SERVICES
		$STATUS_CODES = @{
			code1="STOPPED"; code2="START-PENDING"; code3="STOP-PENDING"
			code4="RUNNING"; code5="CONTINUE"; code6="PAUSE-PENDING"; code7="PAUSED"
			code=""
		}
		$START_TYPES = @{
			code0="BOOT"; code1="SYSTEM"; code2="AUTOMATIC"
			code3="MANUAL"; code4="DISABLED"
			code=""
		}
		# These are FLAGS (multiple values that can be compounded).
		$SERVICE_TYPES = @{
			code1="KERNEL-DRIVER"; code2="FS-DRIVER"; code4="HW-DRIVER"
			code8="FS-STARTUP-DRIVER"; code16="NORMAL"; code32="SHARED"; code256="INTERACTIVE"
			code=""
		}
		if($NotificationsTriggers.ServicesChange -eq $True) {
			# Change numeric codes to their equivalent status.
			$clientDeltas.ChangedServices.Keys | ForEach-Object {
				$statuscode = $clientDeltas.ChangedServices.$_.Status
				$startcode = $clientDeltas.ChangedServices.$_.StartType
				$svccode = $clientDeltas.ChangedServices.$_.ServiceType
				$clientDeltas.ChangedServices.$_.Status = $STATUS_CODES["code$($statuscode)"]
				$clientDeltas.ChangedServices.$_.StartType = $START_TYPES["code$($startcode)"]
				$clientDeltas.ChangedServices.$_.ServiceType = `
					(Interpret-Flags -FlagSet $SERVICE_TYPES -GivenValue $svccode).TrimEnd()
				$statuscode = $clientDeltas.ChangedServices.$_.Status_prior
				$startcode = $clientDeltas.ChangedServices.$_.StartType_prior
				$svccode = $clientDeltas.ChangedServices.$_.ServiceType_prior
				$clientDeltas.ChangedServices.$_.Status_prior = $STATUS_CODES["code$($statuscode)"]
				$clientDeltas.ChangedServices.$_.StartType_prior = $START_TYPES["code$($startcode)"]
				$clientDeltas.ChangedServices.$_.ServiceType_prior = `
					(Interpret-Flags -FlagSet $SERVICE_TYPES -GivenValue $svccode).TrimEnd()
			}
			$clientDeltas.RemovedServices.Keys | ForEach-Object {
				$statuscode = $clientDeltas.RemovedServices.$_.Status
				$startcode = $clientDeltas.RemovedServices.$_.StartType
				$svccode = $clientDeltas.RemovedServices.$_.ServiceType
				$clientDeltas.RemovedServices.$_.Status = $STATUS_CODES["code$($statuscode)"]
				$clientDeltas.RemovedServices.$_.StartType = $START_TYPES["code$($startcode)"]
				$clientDeltas.RemovedServices.$_.ServiceType = `
					(Interpret-Flags -FlagSet $SERVICE_TYPES -GivenValue $svccode).TrimEnd()
			}
			$clientDeltas.NewServices.Keys | ForEach-Object {
				$statuscode = $clientDeltas.NewServices.$_.Status
				$startcode = $clientDeltas.NewServices.$_.StartType
				$svccode = $clientDeltas.NewServices.$_.ServiceType
				$clientDeltas.NewServices.$_.Status = $STATUS_CODES["code$($statuscode)"]
				$clientDeltas.NewServices.$_.StartType = $START_TYPES["code$($startcode)"]
				$clientDeltas.NewServices.$_.ServiceType = `
					(Interpret-Flags -FlagSet $SERVICE_TYPES -GivenValue $svccode).TrimEnd()
			}
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewServices -RemovedObject $clientDeltas.RemovedServices `
				-ChangedObject $clientDeltas.ChangedServices -ItemName "Services" `
				-ItemType "Services"
		}
		
		# -----------------------------------------
		# STORE APPS
		$SA_STATUS_CODES = @{
			code0="OK"; code1="LICENSE-ISSUE"; code2="MODIFIED"; code4="TAMPERED"
			code8="DISABLED"; code16="PACKAGE-OFFLINE"; code32="DEPLOYMENT"
			code64="DEPENDENCY-ISSUE"; code128="DATA-OFFLINE"; code256="PARTIALLY-STAGED"
			code512="NOT-AVAILABLE"; code1024="SERVICING"; code2048="NEED-REMEDIATION"
			code=""
		}
		$ARCHITECTURE_CODES = @{
			code0="x86"; code5="ARM"; code9="x64"; code11="Neutral"; code65535="UNKNOWN"; code=""
		}
		if($NotificationsTriggers.StoreAppsChange -eq $True) {
			# Change numeric codes to their equivalent values.
			$clientDeltas.ChangedStoreApps.Keys | ForEach-Object {
				$clientDeltas.ChangedStoreApps.$_.Status = `
					(Interpret-Flags -FlagSet $SA_STATUS_CODES -GivenValue $statuscode).TrimEnd()
				#$archcode = $clientDeltas.ChangedStoreApps.$_.Architecture
				#$clientDeltas.ChangedStoreApps.$_.Architecture = $ARCHITECTURE_CODES["code$($archcode)"]
				$statuscode = $clientDeltas.ChangedStoreApps.$_.Status_prior
				$clientDeltas.ChangedStoreApps.$_.Status_prior = `
					(Interpret-Flags -FlagSet $SA_STATUS_CODES -GivenValue $statuscode).TrimEnd()
				#$archcode = $clientDeltas.ChangedStoreApps.$_.Architecture_prior
				#$clientDeltas.ChangedStoreApps.$_.Architecture_prior = $ARCHITECTURE_CODES["code$($archcode)"]
			}
			$clientDeltas.RemovedStoreApps.Keys | ForEach-Object {
				$clientDeltas.RemovedStoreApps.$_.Status = `
					(Interpret-Flags -FlagSet $SA_STATUS_CODES -GivenValue $statuscode).TrimEnd()
				#$archcode = $clientDeltas.RemovedStoreApps.$_.Architecture
				#$clientDeltas.RemovedStoreApps.$_.Architecture = $ARCHITECTURE_CODES["code$($archcode)"]
			}
			$clientDeltas.NewStoreApps.Keys | ForEach-Object {
				$clientDeltas.NewStoreApps.$_.Status = `
					(Interpret-Flags -FlagSet $SA_STATUS_CODES -GivenValue $statuscode).TrimEnd()
				#$archcode = $clientDeltas.NewStoreApps.$_.Architecture
				#$clientDeltas.NewStoreApps.$_.Architecture = $ARCHITECTURE_CODES["code$($archcode)"]
			}
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewStoreApps -RemovedObject $clientDeltas.RemovedStoreApps `
				-ChangedObject $clientDeltas.ChangedStoreApps -ItemName "Store Apps" `
				-ItemType "StoreApps"
		}
		
		# -----------------------------------------
		# STARTUP APPS
		if($NotificationsTriggers.StartupAppsChange -eq $True) {
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewStartupApps -RemovedObject $clientDeltas.RemovedStartupApps `
				-ChangedObject $clientDeltas.ChangedStartupApps -ItemName "Startup Apps" `
				-ItemType "StartupApps"
		}
		
		# -----------------------------------------
		# SCHEDULED TASKS APPS
		if($NotificationsTriggers.ScheduledTasksChange -eq $True) {
			$NOTIFBODY_Rpt += Add-To-Report `
				-NewObject $clientDeltas.NewScheduledTasks -RemovedObject $clientDeltas.RemovedScheduledTasks `
				-ChangedObject $clientDeltas.ChangedScheduledTasks -ItemName "Scheduled Tasks" `
				-ItemType "ScheduledTasks"
		}
		
		# ---------- BUILD THE ENTIRE SECTION -----------
		if($NOTIFBODY_Rpt -ne "") {
			# Inject the hostname of the client into the email digest.
			$NOTIFBODY += "`n`n<hr /><h2>$client</h2>`n"
			$NOTIFBODY += $NOTIFBODY_Rpt
		}
	}
	# Send the compiled notification to the target address using the SMTP info provided at the top of the script.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NOTIFBODY
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to '$NotificationsAddress' (BCC: '$BCC') has failed!"
	}
} elseif($NotificationOnNoChange -eq $True -And $NoNotifications -eq $False) {
	# Send an email (if enabled) to notify that no changes were detected.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NotificationsBodyOnNoChange
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to '$NotificationsAddress' (BCC: '$BCC') has failed!"
	}
}




####################################################################################
# FINAL CLEANUP & MISC TASKS

# Generate a text file to track differences. This is optional based on whether the parameter to do so is given.
if($DeltasReport -eq $True -And $deltas.Count -gt 0) {
	$currentTime = (Get-Date -UFormat %Y-%m-%d-%H_%M).toString()
	Write-Output $deltas | ConvertTo-Json -Depth 3 | Out-File "$ReportsDirectory\DELTAS-$currentTime.txt"
} elseif($DeltasReport -eq $False -And $deltas.Count -le 0) {
	Write-Host "No changes were detected across the targeted clients."
}

# Notification that the script is finished.
Write-Host "`n`n*****" -NoNewLine
Write-Host " JOB COMPLETE " -NoNewLine -ForegroundColor Green
Write-Host "*****"

# Return $deltas in case the person running the script would like to manipulate the given differences.
return $deltas