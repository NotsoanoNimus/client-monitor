<#

.SYNOPSIS
Gather, aggregate, and report information from client machines on the domain.
Intended to be run administratively.
Project repository and documentation located at: https://github.com/NotsoanoNimus/client-monitor
.DESCRIPTION
This script will harvest data from client machines on the network using WinRM,
 then compare the differences from the prior report to the most recent one.
Feed the script a text file with the client IPs or hostnames (doesn't matter which) separated line-by-line.
If no file is given, the script will attempt to collect hostnames from the MSAD directory dynamically.
Many variables and settings are "hard-coded" into the script under the "Tweaks" section.
.PARAMETER ClientsList
Optional. The path to a line-delimited file of IPs/hostnames to gather information about.
.PARAMETER DeltasReport
Optional. If included as a switch to the script, a DELTAS text file will be generated in the reports directory.
This will only happen if deltas were actually detected.
.PARAMETER NoNotifications
Optional. If included as a switch to the script, the script will NOT send email notifications at all.
.PARAMETER BCC
Optional. If included, will BCC the target address(es) in the generated notifications.
.PARAMETER NoMini
Optional. If included, the reports generated by the script will NOT be compress/mini-fied, so they become more readable.
Note: Delta reports are NEVER mini-fied.
.PARAMETER Debug
Optional. Debug the script as it runs. 0 = no debug. 1 = Least verbose ---> 4 = Most verbose.
.PARAMETER ConfigFile
Optional. Defaults to ".\Client-MonitorConfig.ps1", but can be the full path of a Client Monitor configuration file.
.PARAMETER SmtpCredential
Optional. In order to use this, a PowerShell credentials object should be passed to the script.
Please refer to the README on the GitHub repo for more information on using this parameter.
.EXAMPLE
$0 -ClientsList ".\target_clients.txt" -BCC "Test Name <tname@test.com>, Second Recip <srecip@testing.com>"

#>



######################################################################################
# Copyright (C) 2019 @NotsoanoNimus on GitHub, as a free software project
#  licensed under GNU GPLv3.
#
# Original Repository: https://github.com/NotsoanoNimus/client-monitor
# Author: Notsoano Nimus <github@xmit.xyz>
#
# This program is free software: you can redistribute it and/or modify it under
#  the terms of the GNU General Public License as published by the Free Software
#  Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
#  this program. If not, see https://www.gnu.org/licenses/.
######################################################################################



# Gather parameters called with the application, and set the initial state as needed.
param(
 	[string]$ClientsList = "use-AD-list",
 	[switch]$DeltasReport = $False,
 	[switch]$NoNotifications = $False,
 	[string]$BCC = "",
	[switch]$NoMini = $False,
	[int]$Debug = 0,
	[string]$ConfigFile = ".\Client-MonitorConfig.ps1",
 	[PSCredential]$SmtpCredential = $null
)
# Forcibly ignore any errors generated by the script, and do not write them to the CLI.
#$ErrorActionPreference = 'SilentlyContinue'
$NoMiniSet = (-Not $NoMini)

# Ensure that the ConfigFile exists.
if(-Not(Test-Path "$($ConfigFile)")) {
	Write-Error "The specified configuration file `"$ConfigFile`" does not exist."
	exit 1
}



##################################################
#                     TWEAKS                     #
##################################################
# "Tweaks" (the deprecated name for "config variables") are sourced from a separate file.
Write-Debug "Loading Client Monitor ConfigFile at '$ConfigFile'..." -Threshold 1 -Prefix '>>'
. "$($ConfigFile)"
# Sanity check to ensure the provided config file is a valid client-monitor configuration.
if($CliMonConfig -ne $True) {
	Write-Error "The given configuration file `"$ConfigFile`" is not a valid Client Monitor configuration."
	exit 1
}
# If the DomainName isn't defined, use the ComputerName variable instead. This helps with SID processing.
if($DomainName -eq "" -Or $null -eq $DomainName) {
	Write-Debug "DomainName variable is blank. Using %ComputerName% instead: $env:COMPUTERNAME" -Threshold 2 -Prefix '>>>>'
	$DomainName = $env:COMPUTERNAME
}
# Added config/global variables based on the configuration file.
$DomainSuffixRegex = [Regex]::Escape($DomainSuffix)



###################################################
#                    FUNCTIONS                    #
###################################################


# Control output for debugging.
Function Write-Debug() {
	param(
		[int]$Threshold = 10000,
		[Parameter(Mandatory=$True)][string]$Message,
		[string]$Prefix = "",
		[switch]$IsInvoked = $False
	)
	if($Threshold -le $DebugVerbosity) {
		Write-Host "[$Threshold] " -ForegroundColor Yellow -BackgroundColor Black -NoNewline
		Write-Host "$($Prefix) " -ForegroundColor Cyan -BackgroundColor Black -NoNewline
		Write-Host "$(if($IsInvoked -eq $True){'[INVOKE]'})" -ForegroundColor White -BackgroundColor Black -NoNewline
		Write-Host " $Message" -ForegroundColor Magenta -BackgroundColor Black
	}
}


# Resolve hostnames to the appropriate IP address and return it.
Function Get-IPAddress() {
	param( [Parameter(Mandatory=$true)][string]$Hostname )
	Write-Debug -Message "`tResolving hostname '$Hostname' to IP address." -Threshold 2 -Prefix '>>>>'
	# Strip off double-dashes from hostnames that may be prefixed by one (ex. \\WKSTN107)
	$Hostname = $Hostname -Replace '\\'
	# Use the System DNS library to resolve the hostname properly, then fetch the IP property.
	$address = [System.Net.Dns]::GetHostAddresses("$Hostname").IPAddressToString
	Write-Debug -Message "`tResolved Addresses:" -Threshold 2 -Prefix '>>>>>>'
	$address | ForEach-Object { Write-Debug -Message "`t`t$_" -Threshold 2 -Prefix '>>>>>>' }
	# If the amount of returned IPs is greater than 1, this usually implies a link-local IPv6 was returned.
	#   We don't want that, so instead fetch the first IPv4 address in the array.
	if($address -Is [System.Array] -And $address.length -gt 1) {
		$addressOrig = $address
		foreach($ip in $address) { if($ip -Match "^[0-9\.]+$") {$address = $ip; break} }
		# Forcibly nullify the address field if a matching IPv4 address wasn't found.
		#   This prevents the script from iterating through v6 addresses only and just keeping the address variable the same.
		if($address -eq $addressOrig) { $address = $null }
	}
	Write-Debug -Message "`tReturned address: $address" -Threshold 2 -Prefix '>>>>>>'
	return $address
}


# Send an email notification to the target address.
#    This wrapper function is only useful because it "injects" the given body into the HTML wrapper (when HTML is enabled).
Function Send-Email() {
	param(
		[Parameter(Mandatory=$True)][string]$RELAYSERVER,
		[Parameter(Mandatory=$True)][int]$RELAYPORT,
		[Parameter(Mandatory=$True)][string]$FROM,
		[Parameter(Mandatory=$True)][string]$TO,
		[Parameter(Mandatory=$True)][string]$SUBJECT,
		[Parameter(Mandatory=$True)][string]$BODY
	)
	Write-Debug -Message "Generating an email to '$TO' from '$FROM'." -Threshold 1 -Prefix '>>'
	if($DebugVerbosity -ge 4) {
		Write-Debug -Message "{Send-Email} parameters:" -Threshold 4 -Prefix '>>>>'
		Write-Debug -Message "`$RELAYSERVER = $RELAYSERVER" -Threshold 4 -Prefix '>>>>>>'
		Write-Debug -Message "`$RELAYPORT = $RELAYPORT" -Threshold 4 -Prefix '>>>>>>'
		Write-Debug -Message "`$FROM = $FROM" -Threshold 4 -Prefix '>>>>>>'
		Write-Debug -Message "`$TO = $TO" -Threshold 4 -Prefix '>>>>>>'
		Write-Debug -Message "`$SUBJECT = $SUBJECT" -Threshold 4 -Prefix '>>>>>>'
		Write-Debug -Message "`$BODY = $BODY" -Threshold 4 -Prefix '>>>>>>'
	}
	# Wrap the message body with the HTML template, if NotificationsAsHTML is set to True.
	if($NotificationsAsHTML -eq $True) {
		# BUGFIX: 20190820
		### Fixed a bug where '$_' in the $BODY value would expand to the [[BODYTEXT]] value in the email.
		$BODY = $BODY -Replace '\$_', '$$$$_'
		##########
		$BODY = $NotificationsHTMLWrapper -Replace '\[\[BODYTEXT\]\]', "$BODY"
		Write-Debug -Message "Email is HTML-formatted, injecting body text into the message." -Threshold 2 -Prefix '>>>>'
	} else {
		# WARNING!!!!!!!!!
		# This is a sloppy way to remove HTML, as it will destroy all text wrapped in angle brackets.
		#   Perhaps find a cleaner way to go about this, as it prevents plaintext emails from containing these <> pairs.
		$BODY = $BODY -Replace '<tr>', "`n"
		$BODY = $BODY -Replace '(</td>|</th>)', ' | '
		$BODY = $BODY -Replace '<.*?>'
		Write-Debug -Message "Email is in plain-text. Removing and replacing HTML tags." -Threshold 2 -Prefix '>>>>'
	}
	# Define a dynamic parameter object to pass to Send-MailMessage.
	$emailParams = @{
		From = $FROM; To = $TO; Subject = $SUBJECT; Body = $BODY; SmtpServer = $RELAYSERVER; Port = $RELAYPORT
	}
	
	# If there's a BCC argument to the script, split the string into an array of recipients along the comma characters.
	if($BCC -ne "") {
		$BCC = $BCC.Split(",").Trim();
		$emailParams.Add("Bcc", $BCC)
		Write-Debug -Message "BCC Addresses: $BCC" -Threshold 2 -Prefix '>>>>'
	}
		
	if($NotificationsRelayWithCredential -eq $True) {
		# Relay with auth is on, is a valid SmtpCredential object provided?
		if($null -eq $SmtpCredential -Or $SmtpCredential -IsNot [PSCredential]) {
			Write-Host "~~~~ Relay with Authentication is enabled, but no valid Credentials object was detected!"
			Write-Host "~~~~~~ Please use the -SmtpCredential parameter with a valid Credentials object (using Get-Credential)."
			Write-Host "~~~~~~ Attempting relay WITHOUT authentication anyway..."
		} else {
			# Otherwise, add it to the email parameters.
			$emailParams.Add("Credential", $SmtpCredential)
			Write-Debug -Message "Relaying the email using given SMTP credentials." -Threshold 2 -Prefix '>>>>'
		}
	}

	Write-Debug -Message "Relay over SSL: $NotificationsRelayWithSSL" -Threshold 2 -Prefix '>>>>'
	Write-Debug -Message "Attempting to dispatch the email." -Threshold 3 -Prefix '>>>>>>'
	# Dispatch the email to the target server.
	Send-MailMessage @emailParams -BodyAsHtml:$NotificationsAsHTML -UseSsl:$NotificationsRelayWithSSL
	# Return the success status of sending the message.
	return $?
}


# Write the report object as a JSON to the target output file.
Function Write-Report() {
	param( [System.Object]$outputJSON = @{} )
	# Today's date, format of YYYY-MM-DD-HH_MM
	$dateTag = Get-Date -UFormat %Y-%m-%d-%H_%M
	$targetFile = $ReportsDirectory + "\Report-$($outputJSON.Hostname)-$dateTag.txt"
	Write-Debug -Message "Writing report to output file at: $targetFile" -Threshold 1 -Prefix '>>'
	# Write the output as a JSON object to the report file (targetFile).
	try {
		Write-Debug -Message "Report file will be minified: $NoMiniSet" -Threshold 3 -Prefix '>>>>'
		Write-Output $outputJSON | ConvertTo-JSON -Depth 3 -Compress:$NoMiniSet | Out-File -FilePath $targetFile
		Write-Debug -Message "Conversion and write: SUCCESS." -Threshold 2 -Prefix '>>>>'
	} catch {
		Write-Debug -Message "Conversion or write FAILURE." -Threshold 2 -Prefix '>>>>'
		Write-Error "There was an issue writing report: $targetFile. Aborting."
		exit 6
	}
}


# Given a client hostname, clean reports according to the retention policy.
Function Remove-Reports() {
	param( [string]$ClientHostname )
	Write-Debug -Message "Removing aged reports for hostname: $ClientHostname" -Threshold 2 -Prefix '>>'
	Write-Host "-- Cleaning reports according to the script retention policy ($MaxReportRetentionHours Hours)."
	$TodaysDate = ((Get-Date -UFormat %Y-%m-%d-%H_%M).toString())
	# For each report filename containing the hostname, get the date on the filename and compare to the retention policy.
	foreach($report in (Get-ChildItem -Path "$ReportsDirectory\Report-$ClientHostname*").Name) {
		$report -Match '-(\d{4}-\d{2}-\d{2}-\d{2}_\d{2}).txt$' | Out-Null
		if((Get-DateDeltaHours -dateOne "$TodaysDate" -dateTwo "$($matches[1])") -ge $MaxReportRetentionHours) {
			Remove-Item -Confirm:$False -Force -Path "$ReportsDirectory\Report-$ClientHostname-$($matches[1]).txt"
			Write-Debug -Message "Removed report: $ReportsDirectory\Report-$ClientHostname-$($matches[1]).txt" `
				-Threshold 2 -Prefix '>>>>'
		}
	}
}


# Compare two dates and return the difference in dates.
#    Since the dates are coming from filenames (which can't have a ':' character), replace '_' with ':'.
Function Get-DateDeltaHours() {
	param( [string]$dateOne, [string]$dateTwo )
	$dateOne = $dateOne -Replace '_', ':'
	$dateTwo = $dateTwo -Replace '_', ':'
	return ((Get-Date "$dateOne") - (Get-Date "$dateTwo")).TotalHours
}


# Gather a report from a report file, return it as a HashTable.
Function Get-Report() {
	param( [System.String]$Hostname, [System.String]$DateString )
	Write-Debug -Message "Getting report for $Hostname with date string '$DateString'." -Threshold 2 -Prefix '>>'
	if(Test-Path ($ReportsDirectory + "\Report-$Hostname-$DateString.txt")) {
		return (Get-Content ($ReportsDirectory + "\Report-$Hostname-$DateString.txt") | ConvertFrom-Json)
	} else { return $null }
}


# Template function to modularize comparing and generating deltas.
Function Compare-Deltas() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjChanged,
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjNew,
		[Parameter(Mandatory=$True)][PSCustomObject]$DeltasObjRemoved,
		[Parameter(Mandatory=$True)][PSCustomObject]$Todays,
		[Parameter(Mandatory=$True)][PSCustomObject]$Priors,
		[Parameter(Mandatory=$True)][PSCustomObject]$TodaysIndex,
		[Parameter(Mandatory=$True)][PSCustomObject]$PriorsIndex,
		[Parameter(Mandatory=$True)][System.Array]$CompareProperties
	)
	$readInFilters = (@{} | ConvertTo-Json)
	$NotificationsRecentInstallationsReportChange = $False
	# Only perform the READ when the Compare-Deltas function is called for the InstalledApps section.
	if(($NotificationsRecentInstallationsAutoTrack -eq $True) -And
	  ($CompareProperties -contains "DisplayName") -And
	  ($CompareProperties -contains "DisplayVersion")) {
		Write-Debug -Message "Auto-Tracking {InstalledApps}: Importing current filters from '$NotificationsRecentInstallationsReportLoc'." -Threshold 3 -Prefix '>>>>>>'
		# Read in the current filters from the ReportLoc.
		$readInFilters = Get-Content $NotificationsRecentInstallationsReportLoc | ConvertFrom-Json
		# If for whatever reason the read/conversion fails, set it to an empty JSON object.
		if($? -ne $True) { $readInFilters = (@{} | ConvertTo-Json) }
	}
	foreach($item in $TodaysIndex) {
		Write-Debug -Message "Examining item '$item'" -Threshold 4 -Prefix '>>>>'
		# Get the applications from the hashtable, so it can be compared to the prior report.
		$todayObject = $Todays.$item
		$priorObject = $Priors.$item
		# If the object isn't found in the last report, assume it's a new application.
		if($null -eq $priorObject -Or @{} -eq $priorObject) {
			Write-Debug -Message "Could not find a valid 'priors' object to work from. Continuing." -Threshold 4 -Prefix '>>>>>>'
			continue
		}
		# Compare properties between the two report objects and return it as an array of True/False.
		$diffs = $CompareProperties | ForEach-Object { $todayObject.$_ -ne $priorObject.$_ }
		# If a "True" was found, there was a difference detected.
		if($diffs.Contains($True)) {
			Write-Debug -Message "Differences between reports detected for this item: $item." -Threshold 4 -Prefix '>>>>'
			# Check that auto-tracking is enabled for InstalledApps suppression, and that this is a call for InstalledApps.
			if(($NotificationsRecentInstallationsAutoTrack -eq $True) -And
			  (Test-Path $NotificationsRecentInstallationsReportLoc) -And
			  ($CompareProperties -contains "DisplayName") -And
			  ($CompareProperties -contains "DisplayVersion")) {
				# Ensure that there is a change ONLY in the DisplayVersion property.
				if($todayObject."DisplayVersion" -ne $priorObject."DisplayVersion") {
					$installedAppFilterProperties = $readInFilters["$($todayObject.DisplayName)"]
					# Check to see if the DisplayVersion is not already in the array of strings for this DisplayName.
					if($installedAppFilterProperties -notcontains "$($todayObject.DisplayVersion)") {
						Write-Debug -Message "Auto-Tracking {InstalledApps}: Setting properties DisplayName=`"$($todayObject.DisplayName)`", DisplayVersion=`"$($todayObject.DisplayVersion)`"" -Threshold 4 -Prefix '>>>>>>'
						# Add it to the array.
						$installedAppFilterProperties += @($todayObject.DisplayVersion)
						# Splice it onto the object.
						$readInFilters | Add-Member -Name "$($todayObject.DisplayName)" `
							-Value $installedAppFilterProperties -Type NoteProperty -Force
						# Set the flag to True that changes were added.
						$NotificationsRecentInstallationsReportChange = $True
					}
				}
			}
			# For each property name to compare, add on the _prior variable with the value of the "Prior" object.
			$CompareProperties | ForEach-Object {
				$todayObject | Add-Member -Name "$($_)_prior" -Value $priorObject.$_ -Type NoteProperty
			}
			Write-Debug -Message "Spliced desired prior properties onto the current object." -Threshold 4 -Prefix '>>>>>>'
			# Add it to the object pointer for the deltasObject variable.
			$DeltasObjChanged.Add("$item", $todayObject)
		}
	}
	# If there were changes to the tracker, send them to the file.
	if($NotificationsRecentInstallationsReportChange -eq $True) {
		# Write the new spliced object to the JSON file.
		($readInFilters | ConvertTo-Json) | Set-Content $NotificationsRecentInstallationsReportLoc -Force
	}
	# Compare the indices of fields to see if an application was added/removed.
	$indexDiffs = Compare-Object $TodaysIndex $PriorsIndex
	Write-Debug -Message "Comparing indices for the category." -Threshold 2 -Prefix '>>>>'
	foreach($difference in $indexDiffs) {
		$diff = $difference.InputObject
		if($difference.SideIndicator -eq "<=") {
			# The item was added.
			Write-Debug -Message "New Item: $diff" -Threshold 3 -Prefix '>>>>'
			$DeltasObjNew.Add("$diff", $Todays.$diff)
		} elseif($difference.SideIndicator -eq "=>") {
			# The item was removed.
			Write-Debug -Message "Removed Item: $diff" -Threshold 3 -Prefix '>>>>'
			$DeltasObjRemoved.Add("$diff", $Priors.$diff)
		}
	}
}


<# Template function to modularize the repetitive task of adding pieces to the email notification.
    #  For New and Removed objects, it simply iterates the Hashtable keys (after checking if there even are any)
    #    and adds the HTML for each corresponding object under the detected keys.
    #  For Changed objects, the two different objects are spliced together to create a single table to show differences.
    #>
Function Add-ToReport() {
	param(
		[Parameter(Mandatory=$True)][PSCustomObject]$NewObject,
		[Parameter(Mandatory=$True)][PSCustomObject]$RemovedObject,
		[Parameter(Mandatory=$True)][PSCustomObject]$ChangedObject,
		[Parameter(Mandatory=$True)][string]$ItemName,
		[Parameter(Mandatory=$True)][string]$ItemType,
		[System.Array]$PreFilteredItems = $null
	)
	# Declare initial local variables.
	# NOTIFSXN later gets extended by underscored/suffixed variables as the script builds the notification.
	Write-Debug -Message "{Add-ToReport} call for $ItemName." -Threshold 1 -Prefix '>>'
	$NOTIFSXN = ""
	$spanNewItem = "<span class='$NotificationsHTMLNewValClass'>"
	$spanPriorItem = "<span class='$NotificationsHTMLPriorValClass'>"
	$spanDifferentItem = "<span class='$NotificationsHTMLDiffValClass'>"
	# New Objects section. If the amount of hashtable keys is >0, check notification filters and
	#    then iterate the keys and add the object to the table.
	$StripTableHeaders = $False
	if($NewObject.Keys.Count -gt 0) {
		Write-Debug -Message "Discovered NEW objects, adding to the report." -Threshold 1 -Prefix '>>>>'
		$NOTIFSXN_New = "<span class='SectionHeader'>New $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		$filteredCount = 0  # Used to indicate how many items were filtered from the notification.
		foreach($new in $NewObject.Keys) {
			Write-Debug -Message "Adding NEW object to the report with keyname $new." -Threshold 2 -Prefix '>>>>>>'
			# For each key in the new item, check the value of the field against the values in the notification filters.
			$isFiltered = Search-NotificationFilter -FilterType $ItemType -FilterAge "New" -ItemValue $NewObject.$new
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				Write-Debug -Message "ITEM IS FILTERED." -Threshold 2 -Prefix '>>>>>>>>'
				if($NotificationsShowFilteredItem -eq $True) { $filteredCount++ }
				continue
			}
			Write-Debug -Message "Expanding object into HTML formatting." -Threshold 2 -Prefix '>>>>>>>>'
			$fillVar = $NewObject.$new | ConvertTo-HTML -Fragment
			if($StripTableHeaders -eq $True -And $NotificationsHTMLStripTableHeaders -eq $True) {
				Write-Debug -Message "Stripping table header tags from the resulting HTML. REGEX: '<tr>\s*<th>.*?</th>\s*</tr>'" -Threshold 3 -Prefix '>>>>>>>>'
				$fillVar = $fillVar -Replace '<tr>\s*<th>.*?</th>\s*</tr>'
			}
			# Any td tags with nothing in between should be manually filled in with a "null" piece of text, to avoid empty spots.
			$fillVar = $fillVar -Replace '<td>(<span class=.*?></span>)?</td>', '<td>null</td>'
			$NOTIFSXN_New += "<div class='DiffsSection'>`n"
			$NOTIFSXN_New += "$spanNewItem<b>Name</b>: $new</span><br />`n"
			$NOTIFSXN_New += "$spanNewItem$($fillVar)</span><br />`n"
			$NOTIFSXN_New += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
			# After the first run through, set stripHeaders to True to strip out <th> tags from the HTML tables.
			$StripTableHeaders = $True
		}
		# Count up the amount of filtered objects and add it to the report.
		if($filteredCount -gt 0) {
			$NOTIFSXN_New += "<div class='DiffsSection'>$NotificationsFilteredIndicator --- $filteredCount<br /><br /></div>`n"
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_New }
	}
	# Removed Objects section. Same process as the "New Objects" section.
	$StripTableHeaders = $False
	if($RemovedObject.Keys.Count -gt 0) {
		Write-Debug -Message "Discovered REMOVED objects, adding to the report." -Threshold 1 -Prefix '>>>>'
		$NOTIFSXN_Removed = "<span class='SectionHeader'>Removed $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		$filteredCount = 0  # Used to indicate how many items were filtered from the notification.
		foreach($removed in $RemovedObject.Keys) {
			Write-Debug -Message "Adding REMOVED object to the report with keyname $removed." -Threshold 2 -Prefix '>>>>>>'
			# For each key in the removed item, check the value of the field against the values in the notification filters.
			$isFiltered = Search-NotificationFilter -FilterType $ItemType -FilterAge "Removed" -ItemValue $RemovedObject.$removed
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				Write-Debug -Message "ITEM IS FILTERED." -Threshold 2 -Prefix '>>>>>>>>'
				if($NotificationsShowFilteredItem -eq $True) { $filteredCount++ }
				continue
			}
			Write-Debug -Message "Expanding object into HTML formatting." -Threshold 2 -Prefix '>>>>>>>>'
			$fillVar = $RemovedObject.$removed | ConvertTo-HTML -Fragment
			if($StripTableHeaders -eq $True -And $NotificationsHTMLStripTableHeaders -eq $True) {
				Write-Debug -Message "Stripping table header tags from the resulting HTML. REGEX: '<tr>\s*<th>.*?</th>\s*</tr>'" -Threshold 3 -Prefix '>>>>>>>>'
				$fillVar = $fillVar -Replace '<tr>\s*<th>.*?</th>\s*</tr>'
			}
			# Any td tags with nothing in between should be manually filled in with a "null" piece of text, to avoid empty spots.
			$fillVar = $fillVar -Replace '<td>(<span class=.*?></span>)?</td>', '<td>null</td>'
			$NOTIFSXN_Removed += "<div class='DiffsSection'>`n"
			$NOTIFSXN_Removed += "$spanPriorItem<b>Name</b>: $removed</span><br />`n"
			$NOTIFSXN_Removed += "$spanPriorItem$($fillVar)</span><br />`n"
			$NOTIFSXN_Removed += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
			# After the first run through, set stripHeaders to True to strip out <th> tags from the HTML tables.
			$StripTableHeaders = $True
		}
		# Count up the amount of filtered objects and add it to the report.
		if($filteredCount -gt 0) {
			Write-Debug -Message "Displaying a count of filtered items: $NotificationsShowFilteredItem" -Threshold 3 -Prefix '>>>>'
			$NOTIFSXN_Removed += "<div class='DiffsSection'>$NotificationsFilteredIndicator --- $filteredCount<br /><br /></div>`n"
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) {
			$NOTIFSXN += $NOTIFSXN_Removed
		}
	}
	# Changed Objects section.
	$StripTableHeaders = $False
	if($ChangedObject.Keys.Count -gt 0) {
		Write-Debug -Message "Discovered CHANGED objects, adding to the report." -Threshold 1 -Prefix '>>>>'
		$NOTIFSXN_Changed = "<span class='SectionHeader'>Changed $ItemName</span><br />`n"
		$SomethingUnfiltered = $False   # Used to indicate if something NOT filtered was present.
		$filteredCount = 0  # Used to indicate how many items were filtered from the notification.
		foreach($changed in $ChangedObject.Keys) {
			if($PreFilteredItems.Count -gt 0) {
				# There are items that are pre-filtered. Ensure this key isn't on that list.
				if($PreFilteredItems.Contains("$($changed)")) {
					Write-Debug -Message "ITEM IS FILTERED (pre-filtered)." -Threshold 2 -Prefix '>>>>>>>>'
					if($NotificationsShowFilteredItem -eq $True) { $filteredCount++ }
					continue
				}
			}
			Write-Debug -Message "Adding CHANGED object to the report with keyname $changed." -Threshold 2 -Prefix '>>>>>>'
			# ------------- CHECK BOTH OBJECTS WITH FILTERS ---------------
			# For each key in the changed item, check the value of the field against the values in the notification filters.
			$isFiltered = Search-NotificationFilter -FilterType $ItemType -FilterAge "Changed" -ItemValue $ChangedObject.$changed
			# If the isFiltered is True, one of the filters matched so skip adding the item to the email.
			if($isFiltered -eq $True) {
				Write-Debug -Message "ITEM IS FILTERED." -Threshold 2 -Prefix '>>>>>>>>'
				if($NotificationsShowFilteredItem -eq $True) { $filteredCount++ }
				continue
			}
			# --------------------------------------------------------------
			# Create two separate objects and merge them together under the same property names.
			#    The objects are split based on the '_prior' suffixes added in the deltas phase of the script.
			$tableNews = @{}; $tablePriors = @{}
			Write-Debug -Message "Wrapping changed variables in HTML styling to highlight differences." -Threshold 2 -Prefix '>>>>>>>>'
			($ChangedObject.$changed | Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike *_prior).Name `
				| Sort-Object | ForEach-Object {
					# Manually fill in the "null" spots via string assignment here. This must be different than the above "Replace"
					#    method because the color highlight (prior vs. new) would be great to have instead of plain text.
					if($null -eq $ChangedObject.$changed.$_ -Or $ChangedObject.$changed.$_ -eq "") {
						$ChangedObject.$changed.$_ = "null"
					}
					if($null -eq $ChangedObject.$changed."$($_)_prior" -Or $ChangedObject.$changed."$($_)_prior" -eq "") {
						$ChangedObject.$changed."$($_)_prior" = "null"
					}
				# Each key will correspond to a fully-HTML value for the "output table" object.
				$diffHighlight=$diffHighlightTerm = ""
				# If the two specific values are different, define a stylization class and wrap the text with it.
				if($ChangedObject.$changed.$_ -ne $ChangedObject.$changed."$($_)_prior") {
					$diffHighlight = $spanDifferentItem; $diffHighlightTerm = "</span>"
				}
				# In short, if the "diff" spans are filled out, the object will be highlighted to show it contains one of the deltas.
				$tableNewsWrapper = "$spanNewItem" + "$diffHighlight" + `
					$ChangedObject.$changed.$_ + "$diffHighlightTerm" + "</span>"
				$tableNews.Add($_,$tableNewsWrapper)
				$tablePriorsWrapper = "$spanPriorItem" + "$diffHighlight" + `
					$ChangedObject.$changed."$($_)_prior" + "$diffHighlightTerm" + "</span>"
				$tablePriors.Add($_, $tablePriorsWrapper)
			}
			Write-Debug -Message "Splicing object arrays and expanding the final object into HTML formatting." -Threshold 3 -Prefix '>>>>>>>>'
			# Send the spliced array to the HTML function to output both items under the same headers.
			$tableOut = (@($tablePriors,$tableNews) | ConvertTo-Json | ConvertFrom-Json) | ConvertTo-Html -Fragment
			# Ensure that pieces aren't added to the table as HTML special chars ("&lt;"). Allows for formatting w/ SPAN.
			$finalTable = [System.Web.HttpUtility]::HtmlDecode($tableOut)
			if($StripTableHeaders -eq $True -And $NotificationsHTMLStripTableHeaders -eq $True) {
				Write-Debug -Message "Stripping table header tags from the resulting HTML. REGEX: '<tr>\s*<th>.*?</th>\s*</tr>'" -Threshold 3 -Prefix '>>>>>>>>'
				$finalTable = $finalTable -Replace '<tr>\s*<th>.*?</th>\s*</tr>'
			}
			# Add it to the string and close the div tag as appropriate.
			$NOTIFSXN_Changed += "<div class='DiffsSection'>`n"
			$NOTIFSXN_Changed += "<span style='color:black;font-size:14px;'><b>Name</b>: $changed</span><br />`n"
			$NOTIFSXN_Changed += "$finalTable<br />`n"
			$NOTIFSXN_Changed += "</div>`n"
			# If this point is reached then there is something that was NOT filtered.
			$SomethingUnfiltered = $True
			# After the first run through, set stripHeaders to True to strip out <th> tags from the HTML tables.
			$StripTableHeaders = $True
		}
		# Count up the amount of filtered objects and add it to the report.
		if($filteredCount -gt 0) {
			Write-Debug -Message "Displaying a count of filtered items: $NotificationsShowFilteredItem" -Threshold 3 -Prefix '>>>>'
			$NOTIFSXN_Changed += "<div class='DiffsSection'>$NotificationsFilteredIndicator --- $filteredCount<br /><br /></div>`n"
		}
		# If either (a) something unfiltered is present, or (b) filtered items are displayed, add the variable to the main SXN.
		if(($SomethingUnfiltered -eq $True) -Or ($NotificationsShowFilteredItem -eq $True)) { $NOTIFSXN += $NOTIFSXN_Changed }
	}
	# Send the finished string back.
	return $NOTIFSXN
}


# Check the NotificationsFilter variable against the given object to see if it should be filtered out of the notification.
#    If the return value is False, do NOT filter the item (meaning there was no match).
Function Search-NotificationFilter() {
	# FilterType : Which sub-field of "$NotificationsFilters" is being examined?
	# FilterAge  : Is this for "New", "Removed", or "Changed"?
	# ItemValue  : The object that is being checked for a filter match.
	param(
		[Parameter(Mandatory=$True)][string]$FilterType,
		[Parameter(Mandatory=$True)][string]$FilterAge,
		[Parameter(Mandatory=$True)][PSCustomObject]$ItemValue
	)
	Write-Debug -Message "{Search-NotificationFilter} call." -Threshold 4 '>>>>>>**'
	# Dynamically define the two values for filtering. This is controlled by whether the filtering is white/black-list.
	$DoFilter = $NotificationsFiltersBlacklist
	$DontFilter = (-Not $NotificationsFiltersBlacklist)
	# Set $filters equal to the string array of filter names.
	$filters = $NotificationsFilters.$FilterType.$FilterAge
	# If there aren't any items in the array, no filters are defined, so don't filter anything.
	if($filters.Count -eq 0) { return $DontFilter }
	# Convert the input object into a Hashtable as needed. This allows us to properly use the "Keys" property below.
	$ItemValueHT = @{}
	if(($ItemValue.GetType()).Name -eq 'PSCustomObject') {
		$ItemValue.PSObject.Properties | ForEach-Object { $ItemValueHT[$_.Name] = $_.Value }
	} else { $ItemValueHT = $ItemValue }
	# For each filter string in the array, ...
	foreach($filter in $filters) {
		# Iterate through the ItemValueHT object's keys to see if it matches the current filter.
		$filterMatch = @()
		if($NotificationFiltersRegex -eq $False) {
			$ItemValueHT.Keys | ForEach-Object { $filterMatch += ($ItemValueHT.$_ -Like $filter) }
		} else { $ItemValueHT.Keys | ForEach-Object { $filterMatch += ($ItemValueHT.$_ -Match $filter) } }
		# If there's a match, immediately notify the script to filter.
		if($filterMatch.Contains($True)) { return $DoFilter }
	}
	# Otherwise, there is no match, so don't filter anything.
	return $DontFilter
}


# Control mounting (and dismounting) user hives for gathering information.
Function Mount-UserHives() {
	param( [switch]$Dismount = $False )
	$priorELVL = $ErrorActionPreference; $ErrorActionPreference = 'SilentlyContinue'   # shhhh...
	# Get all user profiles, whether loaded or unloaded in the registry.
    $userProfiles = Invoke-Command @invokeParams -ScriptBlock {
        (Get-ChildItem -Path $args[0] | Where-Object -Property Name -NotMatch '^Public$').FullName
    } -ArgumentList $UserProfileBase
    $Info = @{
		Profiles = $userProfiles; Domain = $DomainName;
		NTUSERLoc = $NTUSERLocation; NTUSERShadowLoc = $NTUSERShadowLocation
	}

	# Null/Empty check for the passed parameter.
	if($Info.Profiles -eq "" -Or $null -eq $Info.Profiles) {
		Write-Debug -Message "No user profiles detected on the remote machine. Aborting." -Threshold 1 -Prefix '>>'
		return @()
	}

	if($Dismount -eq $True) {
		Write-Debug -Message "Dismounting remote hives:" -Threshold 2 -Prefix '>>'
		# Attempt to get each node in the registry that's mounted under "CLI-MON-[username]"
		$mountedHives = Invoke-Command @invokeParams -ScriptBlock {
			(Get-ChildItem "REGISTRY::HKU" | Where-Object -Property PSChildName -Like "CLI-MON-*").Name `
				| ForEach-Object { $_ -Replace "HKEY_USERS", "HKU" }
		}
		if($DebugVerbosity -gt 0) {
			$mountedHives | ForEach-Object {
				Write-Debug -Message "Discovered CLI-MON hive: $_" -Threshold 2 -Prefix '>>>>'
			}
		}
		# Attempt to unload each registry node.
		$mountedHives | ForEach-Object {
			Write-Host "---- Node: $_   [" -NoNewline
			Invoke-Command @invokeParams -ArgumentList $_ -ScriptBlock {
				reg unload $args[0] 2>&1 | Out-Null
				if($? -eq $True) { Write-Host "SUCCESS" -ForegroundColor Green -NoNewline }
				else { Write-Host "FAILURE" -ForegroundColor Red -NoNewline }
			}
			Write-Host "]"
		}
		# Exit the function.
		return @()
	} else {
		$returnedHives = Invoke-Command @invokeParams -ArgumentList $Info,${function:Write-Debug},$DebugVerbosity -ScriptBlock {
			param ( [PSCustomObject]$Info, [string]$writeDebugCommand, [int]$DebugVerbosity )
			$writeDebug = [scriptblock]::Create($writeDebugCommand)
			$mountedHives = @()
			# If the shadow location doesn't exist, create the directory and force admin-only ACLs on the folder.
			if(-Not(Test-Path -Path $Info.NTUSERShadowLoc)) {
				New-Item -Path "$($Info.NTUSERShadowLoc)" -ItemType Directory
				if($? -eq $False) {
					Write-Host "~~~~ COULD NOT CREATE A DIRECTORY TO SHADOW USER HIVES. WILL NOT TRACK PER-USER ITEMS."
					return @()
				}
			}

			& $writeDebug -Message 'Profiles on the target machine:' -Threshold 1 -Prefix '>>' -IsInvoked
			$Info.Profiles | ForEach-Object { & $writeDebug -Message "`t$_" -Threshold 1 -Prefix '>>' -IsInvoked }

			# Doing anything possible to avoid starting CMD.EXE with a UNC path.
			Push-Location -Path $Info.NTUSERShadowLoc
			if($? -ne $True) { Push-Location -Path "C:\" }
			# Go through each profile, shadow the NTUSER hive, and mount it onto the registry.
			foreach($profile in ($Info.Profiles | Sort-Object)) {
                & $writeDebug -Message "Working on user profile: $profile" -Threshold 2 -Prefix '>>>>' -IsInvoked
				# Get the username from the folder structure.
				$username = Split-Path -Path "$($profile)" -Leaf
				# Set up the shadow location for the NTUSER file (in case the hive isn't mounted).
				$hiveFile = "$($Info.NTUSERShadowLoc)\\NTUSER.DAT_$($username)"
				# If the NTUSER.DAT registry file can't be found then continue to the next profile.
				Copy-Item -Path "$($profile)\\$($Info.NTUSERLoc)\\NTUSER.DAT" -Destination $hiveFile -Force
				# If there was en error copying the file ($False return), that means it's open (and locked). Skip.
				if($? -eq $True) {
                    & $writeDebug -Message "Copied NTUSER.DAT hive for $profile" -Threshold 2 -Prefix '>>>>>>' -IsInvoked
					if(-Not(Test-Path -Path $hiveFile)) {
						Write-Host "~~~~ Could not find or access the shadow hive file, despite it being copied successfully. Skipping..."
						continue
					}
					# Quickly set the NTUSER ACLs to its original content.
					Get-Acl "$($profile)\\$($Info.NTUSERLoc)\\NTUSER.DAT" | Set-Acl $hiveFile
					# Attempt to load the NTUSER file into the registry.
					reg load "HKU\CLI-MON-$($username)" `"$hiveFile`" | Out-Null
					# Index the mounted hive.
					if($? -eq $True) { $mountedHives += "$($Info.Domain)\$($username)" }
				} else {
                    & $writeDebug -Message "Unable to copy NTUSER.DAT hive for $profile" -Threshold 2 -Prefix '>>>>>>' -IsInvoked
					# See if the user's profile name is already mounted under "CLI-MON-[username]".
					$profilesMounted = (Get-ChildItem "REGISTRY::HKU" `
						| Where-Object -Property PSChildName -Like "CLI-MON-*").PSChildName

					if(-Not($null -eq $profilesMounted) -And $profilesMounted.Contains("CLI-MON-$username")) {
                        & $writeDebug -Message "Hive already mounted by CLI-MON for $username" -Threshold 2 -Prefix '>>>>>>>>' -IsInvoked
						$mountedHives += "$($Info.Domain)\$($username)"
					} else {
						# Get the Security Identifier for the mounted profile.
						$userObject = if($Info.Domain -ne "") {
							New-Object System.Security.Principal.NTAccount($Info.Domain, $username)
						} else { New-Object System.Security.Principal.NTAccount($username) }
						$sid = $userObject.Translate([System.Security.Principal.SecurityIdentifier])
						& $writeDebug -Message "User hive already mounted for SID: $sid" -Threshold 2 -Prefix '>>>>>>>>' -IsInvoked
						# Add it to the section.
						$mountedHives += "$sid"
					}
				}
			}
			# Return to the original script location.
			Pop-Location
			return $mountedHives
		}
		$ErrorActionPreference = $priorELVL
		return $returnedHives
	}
}


# Pull information from the mounted user hives for each user on the machine.
Function Get-UserHivesInformation() {
	param(
		[System.Array]$hives,
		[System.Array]$registryTargets,
		[string]$DomainName,
		[bool]$SepMembers = $False,
		[string]$writeDebugCommand, [int]$DebugVerbosity
	)
	$writeDebug = [scriptblock]::Create($writeDebugCommand)
	if($DebugVerbosity -ge 4) {
		& $writeDebug -Message "{Get-UserHivesInformation} parameters: " -Threshold 4 -Prefix '>>' -IsInvoked
		& $writeDebug -Message "`t`$hives = @(" -Threshold 4 -Prefix '>>' -IsInvoked
		$hives | ForEach-Object { & $writeDebug -Message "`t`t$_," -Threshold 4 -Prefix '>>' -IsInvoked }
		& $writeDebug -Message "`t), `$registryTargets = @(" -Threshold 4 -Prefix '>>' -IsInvoked
		$registryTargets | ForEach-Object { & $writeDebug -Message "`t`t$_," -Threshold 4 -Prefix '>>' -IsInvoked }
		& $writeDebug -Message "`t), `$DomainName = $DomainName," -Threshold 4 -Prefix '>>' -IsInvoked
		& $writeDebug -Message "`t`$SepMembers = $SepMembers" -Threshold 4 -Prefix '>>' -IsInvoked
	}
	# Param check...
	if($hives.Count -le 0) {
		& $writeDebug -Message "HIVES array is empty. Aborting." -Threshold 1 -Prefix '>>>>' -IsInvoked
		return @{}
	}
	$priorELVL = $ErrorActionPreference; $ErrorActionPreference = 'SilentlyContinue'   # shhhh...
	$allProfilesInfo = @{}
	foreach($hive in $hives) {
		& $writeDebug -Message "Examining hive: $hive" -Threshold 1 -Prefix '>>' -IsInvoked
		# Check whether or not the given hive name is a SID.
		if($hive -Match '^S-\d+-\d+-\d+-') {
			& $writeDebug -Message "Hive is a match for a SID regex: '^S-\d+-\d+-\d+-'" -Threshold 2 -Prefix '>>>>' -IsInvoked
			# If so, translate the SID to a username, but continue using the SID for fetching data.
			$sidObj = New-Object System.Security.Principal.SecurityIdentifier("$hive")
			$username = ($sidObj.Translate([System.Security.Principal.NTAccount])).Value
			$regLocation = $hive
		} else {
			# Otherwise, set the username directly and use CLI-MON-[username] as the target.
			$username = $hive
			$regLocation = $hive -Replace "^$($DomainName)\\","CLI-MON-"
		}
		& $writeDebug -Message "Registry Location: $regLocation" -Threshold 2 -Prefix '>>>>' -IsInvoked
		& $writeDebug -Message "Username: $username" -Threshold 2 -Prefix '>>>>' -IsInvoked
		# Iterate through the locations fed to the function.
		foreach($target in $registryTargets) {
			# Dynamically replace [TARGET_USER] with the user's ID or mounted name.
			$loc = $target -Replace '\[TARGET_USER\]', "$regLocation"
			& $writeDebug -Message "Expanded Registry Target: $loc" -Threshold 3 -Prefix '>>>>>>' -IsInvoked
			# Try to find the key/value pairs for the given location.
			### SepMembers will determine if the registry keys themselves return a value,
			###  or if each is an individual object (and the PS* keys are desired).
			if($SepMembers -eq $True) {
				$registryValue = Get-ItemProperty "$loc" | Get-Member -Type NoteProperty `
				| Where-Object -Property Name -NotLike "PS*"
			} else { $registryValue = Get-ItemProperty "$loc" }
			# Add the information to the return variable.
			$allProfilesInfo.Add($username, $registryValue)
		}
	}
	# Return all items.
	$ErrorActionPreference = $priorELVL
	return $allProfilesInfo
}



##################################################
#                      MAIN                      #
##################################################


# Let the user know debugging is enabled (if the DebugVerbosity is > 0).
if($DebugVerbosity -gt 0) {
	Write-Host "`n`n** Debugging is enabled, at a verbosity threshold of $DebugVerbosity.`n" -ForegroundColor Red
}

# Ensure that the ReportsDirectory exists.
if(($ReportsDirectory -eq "") -Or (-Not(Test-Path "$ReportsDirectory"))) {
	Write-Error "Could not find the given Reports Directory: $ReportsDirectory"
	exit 2
}

# Reading the installed apps filters has to be done before any items are collected or generated.
$filteredInstalledApps = $null
if(Test-Path $NotificationsRecentInstallationsReportLoc) {
	Write-Debug -Message "Reading recent installations filters configuration file at '$NotificationsRecentInstallationsReportLoc'." -Threshold 2 -Prefix '>>>>'
	# Import from a JSON format.
	$filteredInstalledApps = Get-Content $NotificationsRecentInstallationsReportLoc | ConvertFrom-Json
	if($null -eq $filteredInstalledApps) {
		# Make sure the read items are valid.
		Write-Debug -Message "Unable to read the file at '$NotificationsRecentInstallationsReportLoc'." -Threshold 1 -Prefix '>>>>'
	}
} else {
	Write-Debug -Message "Recent Installations filter file '$NotificationsRecentInstallationsReportLoc' doesn't exist. Creating." -Threshold 2 -Prefix '>>>>'
	(@{} | ConvertTo-Json) | Out-File -FilePath "$NotificationsRecentInstallationsReportLoc" -Force
}

# Initialize an empty array for the client address/hostname pool.
$clientAddresses = [System.Collections.ArrayList]@()

# Check to see whether a clientsList file was provided to the script.
if($clientsList -eq "use-AD-list") {
	Write-Debug -Message "Attempting to use Microsoft AD to find a list of clients..." -Threshold 1 -Prefix '>>'
	Write-Debug -Message "{Get-ADComputer} filter: '$DomainUserFilter'" -Threshold 2 -Prefix '>>>>'
	$clientNames = Get-ADComputer -Filter $DomainUserFilter | Select-Object -Property Name
	if($? -eq $False) {
		Write-Error "Could not get a list of workstations using Get-ADComputer. Please supply a ClientsList to the script if needed."
		exit 3
	}
	Write-Debug -Message "Successfully fetched AD clients." -Threshold 1 -Prefix '>>'
	foreach($line in $clientNames) {
		# May want to verify it's not an IP here but the Get-ADComputer
		#    command doesn't seem to return raw IPs in the "Name" property.
		$hostname = $line.Name
		Write-Debug -Message "CLIENT: $hostname" -Threshold 2 -Prefix '>>>>'
		$address = Get-IPAddress($hostname)
		# Sanity check, ensuring it's not a duplicate and that it exists.
		if($null -eq $address -Or $clientAddresses.Contains($address)) {
			Write-Host "~~~~ Workstation $hostname did not return a valid address. Excluding from report." -ForegroundColor Red
			continue
		}
		# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
		if(-Not($hostname -Match $DomainSuffixRegex)) {
			$hostname = $hostname + $DomainSuffix
			Write-Debug -Message "Appended domain suffix to client hostname: $hostname" -Threshold 3 -Prefix '>>>>>>'
		}
		# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
		$localObject = @{IP = ''; Hostname = ''}
		$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
		$clientAddresses += $localObject
	}
} else {
	# Make sure the clientsList file exists. If not, exit.
	if(-Not(Test-Path $ClientsList)) { Write-Error "The path provided for the clientsList parameter does not exist."; exit 4 }
	Write-Debug -Message "Iterating Client List at: $ClientsList" -Threshold 1 -Prefix '>>'
	# Parse each line in the clientsList file.
	foreach($line in Get-Content $ClientsList) {
		Write-Debug -Message "Checking line: $line" -Threshold 1 -Prefix '>>>>'
		# Check to see whether the line matches a hostname or an IPv4 address.
		if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$' -Or $line -Match '\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}\b') {
			$address=$addressOrig=$hostname = $null
			# If it's a hostname, resolve it to an IPv4 address. Otherwise, just capture the IP.
			if($line -Match '^\\{0,2}[a-zA-Z0-9\-_\\]+$') {
				Write-Debug -Message "Matched hostname regex: '^\\{0,2}[a-zA-Z0-9\-_\\]+$'" -Threshold 3 -Prefix '>>>>'
				$address = Get-IPAddress($line)
				$hostname = $line -Replace '\\'
			} else {
				Write-Debug -Message "Matched IPv4 address regex: '\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}\b'" -Threshold 3 -Prefix '>>>>'
				$address = $line
				# Get the hostname from the IP, or at least attempt to.Res
				$hostname = [System.Net.Dns]::Resolve([string]$address).HostName
				Write-Debug -Message "Resolved IPv4 address to hostname: $hostname" -Threshold 3 -Prefix '>>>>>>'
			}
			# If a valid address couldn't be captured, or if the clientAddresses array already contains it,
			#    consider the entry invalid and continue to the next one.
			if($null -eq $address -Or $clientAddresses.Contains($address)) {
				Write-Host -Message "Given address was null or was already entered. Skipping." -Threshold 2 -Prefix '>>>>'
				continue
			}
			# If the hostname doesn't include the local domain name (listed at the initial section of the script), append it.
			if((-Not($hostname -Match $DomainSuffixRegex)) -And (-Not($hostname -Match '^LOCALHOST\.?'))) {
				$hostname = $hostname + $DomainSuffix
				Write-Debug -Message "Appended domain suffix to client hostname: $hostname" -Threshold 3 -Prefix '>>>>>>'
			}
			# Add the client address and hostname onto the hashtable, then push it onto $clientAddresses.
			$localObject = @{IP = ''; Hostname = ''}
			$localObject.IP = $address; $localObject.Hostname = $hostname.ToUpper()
			$clientAddresses += $localObject
		}
	}
}




# Check whether or not $clientAddresses has been properly populated. If not, exit.
if($clientAddresses -eq $null -Or $clientAddresses.length -eq 0) {
	Write-Error "Could not populate a list of client IP addresses to poll."
	exit 5
}

# Define a base object to hold deltas between yesterday and today.
$deltas = @{}

# Iterate through each client and generate the report.
foreach($client in $clientAddresses) {
	# Aesthetix.
	Write-Host "`n`n"
	# Build a base for the newest report object to be generated.
	$FullReport = [ordered]@{
		IP = "$($client.IP)"; Hostname = "$($client.Hostname)"
		IsOnline = $False; Invokable = $False
	}
	# Template an object to track any changes from the most recent report to the newest one.
	$deltasObject = [ordered]@{
		OnlineStatusChange = $False; InvokableChange = $False
		NewServices = @{}; RemovedServices = @{};	ChangedServices = @{}
		NewInstalledApps = @{}; RemovedInstalledApps = @{}; ChangedInstalledApps = @{}
		NewStoreApps = @{}; RemovedStoreApps = @{}; ChangedStoreApps = @{}
		NewStartupApps = @{}; RemovedStartupApps = @{}; ChangedStartupApps = @{}
		NewScheduledTasks = @{}; RemovedScheduledTasks = @{}; ChangedScheduledTasks = @{}
		FilenameViolations = @{};
	}
	# Create a "dummy" (reference) object for the null array.
	$deltasObjectDummy = $deltasObject | Select-Object *
	
	# Write the current client to the terminal/host for tracking/debugging.
	Write-Host "Hostname: " -NoNewLine
	Write-Host "$($client.Hostname)" -ForegroundColor Cyan
	Write-Host "IP: " -NoNewLine
	Write-Host "$($client.IP)" -ForegroundColor Cyan
	
	Write-Host "-- Pulling prior report."
	# Collect the top of the list for most recent files/reports matching the given hostname.
	#    If an object isn't returned from the query below, assume there is no "prior" report and act accordingly.
	Write-Debug -Message "Fetching most recent report based on {LastWriteTime} and filter 'Report-$($client.Hostname)*'" -Threshold 1 -Prefix '>>'
	$LastReportMade = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client.Hostname)*" `
		| Sort-Object LastWriteTime | Select-Object -Last 1)
	if($LastReportMade.Length -le 0) {
		Write-Host "** No prior report found. Setting the comparison object to the default reference."
		$MostRecentReport = $FullReport
	} else {
		$LastReportMade = $LastReportMade[0].Name
		Write-Debug -Message "Last Report Made: $LastReportMade" -Threshold 2 -Prefix '>>>>'
		# Bring the previous report and the recent report into the script.
		$DateofLastReport = [Regex]::Matches($LastReportMade, '\d{4}-\d{2}-\d{2}-\d{2}_\d{2}')[0].Value
		Write-Debug -Message "Date of Last Report: $DateofLastReport" -Threshold 2 -Prefix '>>>>'
		$MostRecentReport = Get-Report -Hostname "$($client.Hostname)" -DateString "$DateofLastReport"
	}
	
	# Create a parameters object for Invoke.
	$invokeParams = @{}
	# Is the tested client the local host? If not, set the ComputerName parameter to the client hostname.
	if(-Not($client.Hostname -Match '^LOCALHOST\.?')) {
		Write-Debug -Message "Target hostname is NOT a match for regex '^LOCALHOST\.?'. Building invokeParams with ComputerName." -Threshold 3 -Prefix '>>'
		$invokeParams.Add("ComputerName", "$($client.Hostname)")
	}
	
	Write-Host "-- Running connectivity tests for WinRM and ICMP."
	$priorELVL = $ErrorActionPreference; $ErrorActionPreference = 'SilentlyContinue'   # shhhh...
	# Run a basic ICMP ping test against the target to see if it's online. Add it to the report.
	Test-Connection "$($client.Hostname)" -Count 1 | Out-Null
	$FullReport.IsOnline = $?
	Write-Debug -Message "Target online: $($FullReport.IsOnline)" -Threshold 1 -Prefix '>>'
	# Check if the target is invokable at all, i.e. can we run WinRM commands on it?
	Invoke-Command @invokeParams -ScriptBlock { Get-Culture } | Out-Null
	$FullReport.Invokable = $?
	Write-Debug -Message "Target invokable: $($FullReport.Invokable)" -Threshold 1 -Prefix '>>'
	# Restore the previous error-output action.
	$ErrorActionPreference = $priorELVL
	
	# Compare invokability and availability to the last report, as long as this ISN'T the first report.
	if((($FullReport.Invokable -ne $MostRecentReport.Invokable) -Or
		($FullReport.IsOnline -ne $MostRecentReport.IsOnline)) -And
		(-Not($LastReportMade.Length -le 0))) {
			# This section lets the notification generation portion of the script know that
			### something to do with client reachability has changed.
			Write-Debug -Message "An online/invokable status change was detected." -Threshold 2 -Prefix '>>>>'
		    $deltasObject.OnlineStatusChange = ($FullReport.IsOnline -ne $MostRecentReport.IsOnline)
			$deltasObject.InvokableChange = ($FullReport.Invokable -ne $MostRecentReport.Invokable)
			# If the host isn't invokable, track the deltas here, because below will cause a forced continue.
		    if($FullReport.Invokable -eq $False) { $deltas.Add("$($client.Hostname)", $deltasObject) }
	}
	
	# The target host cannot be invoked. Note this, generate the report, clean old reports, and skip.
	if ($FullReport.Invokable -eq $False) {
		Write-Host "**** WinRM is not active on the target, or the target is unreachable."
		Write-Host "****  Copying the most recent report (if it exists) forward to preserve the last known state."
		# Set the most recent report's status variables accordingly, but preserve everything else.
		$MostRecentReport.Invokable = $False
		$MostRecentReport.IsOnline = $FullReport.IsOnline
		# Write the "new" report as the slightly-modified old one.
		Write-Report($MostRecentReport)
		# Clean up and move on.
		Remove-Reports -ClientHostname "$($client.Hostname)"
		continue
	}
	
	# Start mounting the registry hives for each user, and track which hives are already mounted. 
	Write-Host "-- Mounting user registry hives."
	$mountedUserHives = Mount-UserHives
	$mountedUserHives | ForEach-Object {
		Write-Host "---- Mounted Hive: " -NoNewLine
		Write-Host "$_ " -ForegroundColor Yellow
	}
	Write-Host "-- Collecting information about the target machine and building a report."
	
	####### TODO: PIECES OF THIS SECTION CAN BE MODULARIZED INTO A GENERIC FUNCTION #######
	# -----------------------------------------
	# Iterate through the filename trackers, if enabled.
	if($FilenameTracking -eq $True) {
		Write-Host "---- Tracking filenames across the below directories or places:"
		$TrackedFiles = @{}
		# Check user directories, if enabled.
		if($TrackedFilenameLocations.UserProfiles -eq $True) {
			Write-Host "------ User Profiles."
			$UserProfileCounts = @{}
			$UserProfiles = Invoke-Command @invokeParams -ScriptBlock {
				param( [string]$profileBase )
				# Get a list of the user profiles on the target machine.
				(Get-ChildItem -Path "$profileBase" | Where-Object -Property Attributes -Like '*Directory*').FullName
			} -ArgumentList $UserProfileBase
			$ProfileContents = Invoke-Command @invokeParams -ScriptBlock {
				param( [System.Array]$paths = @(), [string]$writeDebugCommand, [int]$DebugVerbosity )
				$writeDebug = [scriptblock]::Create($writeDebugCommand)
				# Get the actual contents of all the directories and send the full path + filename back out.
				$paths | ForEach-Object {
					& $writeDebug -Message "Fetching Remote Path Content: $_" -Threshold 1 -Prefix '>>>>>>>>' -IsInvoked
					Get-ChildItem -Path $_ -Recurse | Sort-Object CreationTime | Select-Object FullName
					if($? -eq $False) { & $writeDebug -Message "Failed to get directory contents." -Threshold 1 -Prefix '>>>>>>>>>>**' -IsInvoked  }
				}
			} -ArgumentList $UserProfiles,${function:Write-Debug},$DebugVerbosity
			# Iterate through the profile list.
			foreach($prof in $UserProfiles) {
				Write-Debug -Message "Profile: $prof" -Threshold 1 -Prefix '>>>>>>'
				$PerProfileCount = @{}
				# Go through each pattern being checked, and get a count for the amount of matching filenames.
				foreach($pattern in $TrackedFilenamePatterns.Keys) {
					$matchedfiles = $ProfileContents | ForEach-Object {
						if($_.FullName -Like "$($prof)\*" -And $_.FullName -Match $pattern) {
							$_.FullName -Replace "^$([Regex]::Escape($prof))", "."
						}
					}
					$filecount = $matchedfiles.Count
					if($null -eq $filecount) { $filecount = 0 }
					# Add the count onto the per-profile object, as well as the associated filenames for info later.
					$PerProfileCount.Add($pattern, $filecount)
					Write-Debug "Found $filecount matching files for pattern '$pattern'." -Threshold 1 -Prefix '>>>>>>>>'
					if($DebugVerbosity -gt 0 -And $filecount -gt 0) {
						Write-Debug -Message "Filenames:" -Threshold 3 -Prefix '>>>>>>>>>>'
						$matchedfiles | ForEach-Object { Write-Debug -Message "$_" -Threshold 3 -Prefix '>>>>>>>>>>>>' }
					}
					$PerProfileCount.Add("FILES_$($pattern)", ($matchedfiles | Select-Object -Last $TrackedFilenameViewLimit))
				}
				# Add the per-profile object to this wrapper.
				$UserProfileCounts.Add($prof, $PerProfileCount)
			}
			# Add the totals under the "UserProfileCounts" field.
			$TrackedFiles.Add("UserProfilesCounts", $UserProfileCounts)
		} else { $TrackedFiles.Add("UserProfilesCounts", @{}) }
		
		# This section should be used with caution, as it may cause a delay in script processing per client.
		if($TrackedFilenameLocations.SystemFiles -eq $True) {
			Write-Host "------ The %SYSTEMROOT% directory (typically 'C:\Windows')"
			Write-Host "~~~~~~ WARNING: This could add a potentially-large delay in per-client processing."
			# Recursively get all files in the %SYSTEMROOT% location, from the remote client.
			$SystemDirContents = Invoke-Command @invokeParams -ScriptBlock {
				Get-ChildItem -Path $ENV:SYSTEMROOT -Recurse
			}
			$FoundPatterns = @{}
			foreach($pattern in $TrackedFilenamePatterns.Keys) {
				if($null -eq $SystemDirContents) { continue }
				$matchedfiles = ($SystemDirContents | Where-Object -Property Name -Match $pattern)
				$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
				$filecount = $actualnames.Count
				if($null -eq $filecount) { $filecount = 0 }
				$FoundPatterns.Add($pattern, $filecount)
				$FoundPatterns.Add("FILES_$($pattern)", $actualnames)
			}
			# Create an intermediate object to give this the same nesting as the "user" and "custom" fields.
			$IntermediateObject = @{}; $IntermediateObject.Add("SystemFiles", $FoundPatterns)
			$TrackedFiles.Add("SystemFilesCounts", $IntermediateObject)
		} else { $TrackedFiles.Add("SystemFilesCounts", @{}) }
		
		# This section should be used with caution, as it may cause a delay in script processing per client.
		if($TrackedFilenameLocations.ProgramData -eq $True) {
			Write-Host "------ The %ProgramData% directory (typically 'C:\ProgramData')"
			Write-Host "~~~~~~ WARNING: This could add a potentially-large delay in per-client processing."
			# Recursively get all files in the %ProgramData% location, from the remote client.
			$ProgramDataContents = Invoke-Command @invokeParams -ScriptBlock {
				Get-ChildItem -Path $ENV:ProgramData -Recurse
			}
			$FoundPatterns = @{}
			# See below section (custom directories) is commented and effectively doing the same thing.
			foreach($pattern in $TrackedFilenamePatterns.Keys) {
				if($null -eq $ProgramDataContents) { continue }
				$matchedfiles = ($ProgramDataContents | Where-Object -Property Name -Match $pattern)
				$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
				$filecount = $actualnames.Count
				if($null -eq $filecount) { $filecount = 0 }
				$FoundPatterns.Add($pattern, $filecount)
				$FoundPatterns.Add("FILES_$($pattern)", $actualnames)
			}
			# Again, create an intermediate object to give this the same nesting as the "user" and "custom" fields.
			$IntermediateObject = @{}; $IntermediateObject.Add("ProgramFiles", $FoundPatterns)
			$TrackedFiles.Add("ProgramFilesCounts", $IntermediateObject)
		} else { $TrackedFiles.Add("ProgramFilesCounts", @{}) }
		
		# Are there any custom directories? If so, iterate the object.
		if($TrackedFilenameLocationsCustom.Keys.Count -gt 0) {
			Write-Host "------ Custom Directories:"
			$CustomDirTrackers = @{}
			foreach($customlocation in $TrackedFilenameLocationsCustom.Keys) {
				Write-Host "-------- " -NoNewLine; Write-Host "'$($customlocation)'" -ForegroundColor Magenta
				# Get the contents of the custom directory. If it doesn't exist, return a null.
				$CustomDirContents = Invoke-Command @invokeParams -ScriptBlock {
					if(-Not(Test-Path $args[1])) { return $null }
					Get-ChildItem -Path $args[1] -Recurse:$args[0] | Sort-Object CreationTime
				} -ArgumentList $TrackedFilenameLocationsCustom.$customlocation,$customlocation
				$PerLocationCount = @{}
				foreach($pattern in $TrackedFilenamePatterns.Keys) {
					# if the contents returned = null, just get out.
					if($null -eq $CustomDirContents) { continue }
					# Get files matching the current pattern.
					$matchedfiles = ($CustomDirContents | Where-Object -Property Name -Match $pattern)
					# Get the full name (with the path prepended).
					$actualnames = ($matchedfiles | Select-Object FullName -Last $TrackedFilenameViewLimit).FullName
					# Count the amount of full pathnames/filenames present.
					$filecount = $actualnames.Count
					# If for whatever reason the "Count" property returns a null, default to 0.
					if($null -eq $filecount) { $filecount = 0 }
					# Add the pieces to the per-location object (indexing everything for the CURRENT custom location).
					$PerLocationCount.Add($pattern, $filecount)
					$PerLocationCount.Add("FILES_$($pattern)", $actualnames)
				}
				# Add the per-location object onto the main tracker.
				$CustomDirTrackers.Add($customlocation, $PerLocationCount)
			}
			# Add the main tracker for custom directories to the meta/super object.
			$TrackedFiles.Add("CustomLocationsCounts", $CustomDirTrackers)
		} else { $TrackedFiles.Add("CustomLocationsCounts", @{}) }
		
		# Add the meta/super object to the report, and also index the extensions/expressions used.
		$FullReport.Add("FilenameTrackers", $TrackedFiles)
		$TrackedFilenamePatternsAsArray = @(); $TrackedFilenamePatterns.Keys `
			| ForEach-Object { $TrackedFilenamePatternsAsArray += $_ }
		$FullReport.Add("FilenameTrackersPatterns", $TrackedFilenamePatternsAsArray)
		<# FullReport is adding this structure:
		    # "FilenameTrackers" : {
		    #    UserProfilesCounts    : {  <user1>:{patterns-found}, <user2>:{patterns-found}, ..., <userN>:{patterns-found}  }
		    #    CustomLocationsCounts : {  <loc1>:{patterns-found}, <loc2>:{patterns-found}, ..., <locN>:{patterns-found}  }
		    #    ProgramFilesCounts    : {  "ProgramFiles":{patterns-found}  }
		    #    SystemFilesCounts     : {  "SystemFiles":{patterns-found}  }
		    # }
		    #    ... where "patterns-found" uses the pattern from the $TrackedFilenamePatterns variable as the key
		    #        and the count as the value. There is also a "FILES_[pattern]" key for the actual full filenames found.
		    #>
	}
	
	
	# -----------------------------------------
	# Collect installed applications at multiple layers.
	Write-Host "---- Gathering installed applications..."
	Write-Debug -Message "INDEX  : [PSChildName]_[LocationSuffx (HKLM|Username|6432Node)]" -Threshold 1 -Prefix '>>>>>>'
	Write-Debug -Message "REQUEST: Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	Write-Debug -Message "REQUEST: Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	Write-Debug -Message "REQUEST: Get-ItemProperty HKU:\[USER]\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	$installedAppsObject = @{}
	# Find system-wide installations from the HKLM.
	$machineApplications = Invoke-Command @invokeParams -ScriptBlock {
		Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*
	}
	$installedAppsObject.Add("HKLM", $machineApplications)
	# Find the 64-to-32-bit applications in the registry.
	$6432Nodes = Invoke-Command @invokeParams -ScriptBlock {
		Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*
	}
	$installedAppsObject.Add("6432Node", $6432Nodes)
	# Use the targets below to get each user's information from the mounted registry nodes.
	$appTargets = @(
		"REGISTRY::HKEY_USERS\[TARGET_USER]\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
	)
	$perProfileApps = Invoke-Command @invokeParams -ScriptBlock ${function:Get-UserHivesInformation} `
		-ArgumentList $mountedUserHives,$appTargets,$DomainName,$False,${function:Write-Debug},$DebugVerbosity
	# Append the per-profile items from the registry onto the output object.
	$installedAppsObject += $perProfileApps
	# Define the two objects to insert into the main report hashtable.
	$reportInstalledApps = @{}; $installedAppsIndex = @()
	foreach($appKey in $installedAppsObject.Keys) {
		foreach($app in $installedAppsObject.$appKey) {
			if($null -eq $app) { continue }
			$keyname = "$($app.PSChildName)_$appKey"
			# Add the keyname onto the index.
			$installedAppsIndex += $keyname
			# Create the key in the hashtable.
			$reportInstalledApps.Add($keyname, `
				($installedAppsObject.$appKey | Where-Object -Property PSPath -eq "$($app.PSPath)" `
				| Select-Object $TrackedValues.InstalledApps))
		}
	}
	# Add the items to the new report.
	$FullReport.Add("InstalledAppsIndex", $installedAppsIndex)
	$FullReport.Add("InstalledApps", $reportInstalledApps)
	
		
	# -----------------------------------------
	# Harvest Windows Store-based applications.
	Write-Host "---- Gathering store applications..."
	Write-Debug -Message "INDEX  : [PackageFullName]" -Threshold 1 -Prefix '>>>>>>'
	Write-Debug -Message "REQUEST: Get-AppxPackage -AllUsers" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	$priorELVL = $ErrorActionPreference; $ErrorActionPreference = 'SilentlyContinue'   # shhhh...
	# Get the store apps a single time and run all computations on the LOCAL side! (fix to Issue #1 on GitHub).
	$storeAppsList = Invoke-Command @invokeParams -ScriptBlock { Get-AppxPackage -AllUsers }
	# If there was an issue getting the list, write it out and move on.
	if($storeAppsList.Count -eq 0) {
		Write-Host "~~~~ Store apps couldn't be captured for this client. Please verify administrative permissions."
	}; $ErrorActionPreference = $priorELVL
	$reportStoreApps = @{}; $storeAppsIndex = @()
	# Iterate the list of store apps.
	foreach($app in $storeAppsList) {
		$keyname = "$($app.PackageFullName)"
		$i = 0  #Keep track of the "layer"
		for(; $i -lt 4; $i++) {
			# Allow up to 4 nested key names, each successive duplicate being suffixed by an extra underscore.
			if($reportStoreApps.ContainsKey($keyname)) { $keyname += "_" }
		}
		# Get all the fields from the StoreApps trackers that are needed to build the report.
		$storeAppsInfo = ($storeAppsList `
			| Where-Object -Property PackageFullName -eq "$($app.PackageFullName)" `
			| Select-Object $TrackedValues.StoreApps)
		# Additionally, ALWAYS track the PackageUserInformation to find out who has which apps, and their statuses.
		$perUserAppStatus = "App Status: `r`n" + [System.String]::Join("`r`n", `
			@($storeAppsInfo.PackageUserInformation | ForEach-Object {
				($_ | Select-String -Pattern '\[[\\\w]+\]\s*\:\s+\w+' -AllMatches).Matches.Value
			}))
		# Add the PackageUserInformation property (with extracted names/statuses) into the final object.
		$storeAppsInfo | Add-Member -Name PackageUserInformation -Type NoteProperty -Value "$($perUserAppStatus)"
		$reportStoreApps.Add($keyname, $storeAppsInfo)
		$storeAppsIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("StoreAppsIndex", $storeAppsIndex)
	$FullReport.Add("StoreApps", $reportStoreApps)
	
	
	# -----------------------------------------
	# Harvest startup applications.
	Write-Host "---- Gathering startup applications..."
	Write-Debug -Message "INDEX  : [Name (of regsitry key)]_[Domain\Username]" -Threshold 1 -Prefix '>>>>>>'
	Write-Debug -Message "REQUEST: Get-ItemProperty HKU\[USER]\Software\Microsoft\Windows\CurrentVersion\Run\" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
    # Define the two objects to insert into the main report hashtable.
	$reportStartupApps = @{}; $startupAppsIndex = @()

	# Use the targets below to get each user's information from the mounted registry nodes.
	$startupTargets = @(
		"REGISTRY::HKEY_USERS\[TARGET_USER]\Software\Microsoft\Windows\CurrentVersion\Run\"
	)
	$perProfileStartupApps = Invoke-Command @invokeParams -ScriptBlock ${function:Get-UserHivesInformation} `
		-ArgumentList $mountedUserHives,$startupTargets,$DomainName,$True,${function:Write-Debug},$DebugVerbosity

	# For every user in the mounted registry point, parse the returned information.
	foreach($user in ($perProfileStartupApps.Keys | Sort-Object)) {
        foreach($item in $perProfileStartupApps.$user) {
            if($null -eq $item) { continue }
            $keyname = "$($item.Name)_$($user)"
            $addedInformation = [ordered]@{}
            foreach($value in $TrackedValues.StartupApps) {
                if($value -eq "Command") {
                    $addedInformation.Add($value, "$($item.Definition -Replace 'string ')")
                } elseif($value -eq "Location") {
					$userNoDomain = $user -Replace "^$($DomainName)\\"
                    $addedInformation.Add($value, "HKEY_USERS\$($userNoDomain)")
                } elseif($value -eq "User") {
                    $addedInformation.Add($value, "$($user)")
                } else { $addedInformation.Add($value, "") }
            }
            $reportStartupApps.Add($keyname, $addedInformation)
            $startupAppsIndex += $keyname
        }
    }

	# Get Startup apps using the below command. This will capture the current startup commands registered
	### on the Local Machine and Current User. The "where" clause specifies that we're searching only for Local Machine keys.
	Write-Debug -Message "REQUEST: Get-CimInstance Win32_StartupCommand | Where-Object -Property User -Match '^(Public|NT\sAUTHORITY\\.+)$'" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	$w32StartupCmd = Invoke-Command @invokeParams -ScriptBlock {
		Get-CimInstance Win32_StartupCommand | Where-Object -Property User -Match "^(Public|NT\sAUTHORITY\\.+)$"
    }
	foreach($startupapp in $w32StartupCmd) {
		$keyname = "$($startupapp.Name)_$($startupapp.User)"
		$reportStartupApps.Add($keyname, `
			($w32StartupCmd | Where-Object -Property Name -eq "$($startupapp.Name)" `
				| Where-Object -Property User -eq "$($startupapp.User)" `
				| Select-Object $TrackedValues.StartupApps))
		$startupAppsIndex += $keyname
	}
	# Get Startup apps from the location mentioned above.
	$6432NodeItems = Invoke-Command @invokeParams -ScriptBlock {
		(Get-ItemProperty HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run) `
			| Get-Member -Type NoteProperty | Where-Object -Property Name -NotLike PS*
	}
	# Add each one onto the startup apps that are registered for the client.
	foreach($item in $6432NodeItems) {
		$keyname = "$($item.Name)_6432-NODE"
		$addedInformation = @{}
		foreach($value in $TrackedValues.StartupApps) {
			if($value -eq "Command") {
				$addedInformation.Add($value, "$($item.Definition -Replace 'string ')")
			} elseif($value -eq "Location") {
				$addedInformation.Add($value, "64-to-32_Registry_Node")
			} elseif($value -eq "User") {
				$addedInformation.Add($value, "6432-NODE")
			} else { $addedInformation.Add($value, "") }
		}
		$reportStartupApps.Add($keyname, $addedInformation)
		$startupAppsIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("StartupAppsIndex", $startupAppsIndex)
	$FullReport.Add("StartupApps", $reportStartupApps)
		
	
	# -----------------------------------------
	# Get a list of services (all of them).
	Write-Host "---- Gathering services..."
	Write-Debug -Message "INDEX  : [DisplayName]_[Name]" -Threshold 1 -Prefix '>>>>>>'
	Write-Debug -Message "REQUEST: Get-Service" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	$svcs = Invoke-Command @invokeParams -ScriptBlock { Get-Service }
	$reportServices = @{}; $servicesIndex = @()
	foreach($service in $svcs) {
		$keyname = "$($service.DisplayName)_$($service.Name)"
		$reportServices.Add($keyname, `
			($svcs | Where-Object -Property DisplayName -eq "$($service.DisplayName)" `
				| Where-Object -Property Name -eq "$($service.Name)" `
				| Select-Object $TrackedValues.Services))
		$servicesIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("ServicesIndex", $servicesIndex)
	$FullReport.Add("Services", $reportServices)
	
	
	# -----------------------------------------
	# Get scheduled tasks and jobs.
	Write-Host "---- Gathering scheduled tasks..."
	Write-Debug -Message "INDEX  : [URI]" -Threshold 1 -Prefix '>>>>>>'
	Write-Debug -Message "REQUEST: Get-ScheduledTask" -Threshold 1 -Prefix '>>>>>>' -IsInvoked
	$taskList = Invoke-Command @invokeParams -ScriptBlock { Get-ScheduledTask }
	$reportTasks = @{}; $scheduledTasksIndex = @() 
	foreach($task in $taskList) {
		$keyname = "$($task.URI)"
		$reportTasks.Add($keyname, `
			($taskList | Where-Object -Property URI -eq "$($task.URI)" `
				| Select-Object $TrackedValues.ScheduledTasks))
		$scheduledTasksIndex += $keyname
	}
	# Add it to the report.
	$FullReport.Add("ScheduledTasksIndex", $scheduledTasksIndex)
	$FullReport.Add("ScheduledTasks", $reportTasks)
	
	
	# -----------------------------------------
	# Generate the final report file with all of the information.
	Write-Host "---- Finalizing generated report."
	Write-Report($FullReport)
	

	# Dismount the user hives.
	Write-Host "-- Unmounting user hives for users that are not logged on."
	Mount-UserHives -Dismount

	
	#####################################################################
	# COMPARISON SECTION.
	# All comparisons will use the most recent report as the reference object, comparing AGAINST the prior report.
	Write-Host "-- Comparing the differences between the generated report and the prior report."
	# Stop here if the file is the first in the line of reports.
	if($LastReportMade.Length -le 1) {
		Write-Host "** Client does not have a prior report to provide a comparison to the new report. Skipping comparisons..."
		continue
	}
	# HashTable -> JSON -> PSCustomObject, so that it matches the import that the $MostRecentReport variable went through.
	$FullReportIntermediate = $FullReport | ConvertTo-Json -Depth 3
	$TodaysReport = $FullReportIntermediate | ConvertFrom-Json
	Write-Debug -Message "Converting generated report to JSON and back (object conversion)." -Threshold 2 -Prefix '>>'
	
	
	# -----------------------------------------
	# Filename Tracking.
	if($FilenameTracking -eq $True) {
		Write-Debug -Message "Checking comparisons for filename pattern tracking." -Threshold 1 -Prefix '>>'
		# TODO: Make the code a bit more readable/manageable.
		$todayfilenames = $TodaysReport.FilenameTrackers
		$priorfilenames = $MostRecentReport.FilenameTrackers
		# Structure of these nested loops:
		#    $category = "outer" nest (like "SystemFilesCounts")
		#    $subcategory = per-user/per-location information (like "C:\Users\TestAccount")
		#    $pattern = the pattern or FILES_ key in the actual table.
		$categoryDeltas = @{}
		foreach($category in ($todayfilenames | Get-Member -Type NoteProperty).Name) {
			Write-Debug -Message "Category: $category" -Threshold 2 -Prefix '>>>>'
			$subcategoryDeltas = @{}
			foreach($subcategory in ($todayfilenames.$category | Get-Member -Type NoteProperty).Name) {
				Write-Debug -Message "Subcategory: $subcategory" -Threshold 3 -Prefix '>>>>>>'
				$perpatternDeltas = @{}
				foreach($pattern in $TodaysReport.FilenameTrackersPatterns) {
					Write-Debug -Message "Pattern: $pattern" -Threshold 3 -Prefix '>>>>>>>>'
					# If the previous object is null/empty, this might be a new key, move on as there's no delta to measure.
					if($null -eq $priorfilenames.$category.$subcategory.$pattern -Or
						$priorfilenames.$category.$subcategory.$pattern -eq @{}) { continue }
					# Get the threshold from the Tweaks section.
					$itemThreshold = $TrackedFilenamePatterns.$pattern
					Write-Debug -Message "Pattern threshold: $itemThreshold" -Threshold 3 -Prefix '>>>>>>>>>>'
					# If it's set to 0 (or less) or isn't an integer, set it to a very high value (effectively neutering it).
					if($itemThreshold -le 0 -Or $itemThreshold -IsNot 'Int32') { $itemThreshold = 99999 }
					# Get the difference between the amount of files matching the given pattern between reports.
					$filenameCountDelta = ($todayfilenames.$category.$subcategory.$pattern `
						- $priorfilenames.$category.$subcategory.$pattern)
					Write-Debug -Message "Filename Delta Count for pattern '$pattern': $filenameCountDelta" -Threshold 3 -Prefix '>>>>>>>>>>'
					if($filenameCountDelta -ge $itemThreshold) {
						Write-Debug -Message "Delta exceeds the threshold. Tracking and reporting..." -Threshold 3 -Prefix '>>>>>>>>>>>>'
						# The threshold was passed, so add the new count and the previous counts the the changed object.
						#    Also, add the filenames and the threshold value.
						$perpatternDeltas.Add($pattern, $todayfilenames.$category.$subcategory.$pattern)
						$perpatternDeltas.Add("Files_$($pattern)", $todayfilenames.$category.$subcategory."Files_$($pattern)")
						$perpatternDeltas.Add("Threshold_$($pattern)", $itemThreshold)
						$perpatternDeltas.Add("__Prior_$($pattern)", $priorfilenames.$category.$subcategory.$pattern)
					}
				}
				# Anything added to the per-pattern keys based on a passed threshold? If so, add the subcat to its object.
				if($perpatternDeltas.Keys.Count -gt 0) {
					$subcategoryDeltas.Add($subcategory, $perpatternDeltas)
				}
			}
			# Anything present in the subcategory items? If so, add the category to its object.
			if($subcategoryDeltas.Keys.Count -gt 0) { $categoryDeltas.Add($category, $subcategoryDeltas) }
		}
		# And now that the FOR loops are complete, take a look at categoryDeltas. If the key count is >0 there are changes.
		if($categoryDeltas.Keys.Count -gt 0) {
			Write-Debug -Message "Filename Trackers items were caught, adding them to the deltas object." -Threshold 1 -Prefix '>>'
			$deltasObject.FilenameViolations = $categoryDeltas
		}
	} else { $deltasObject.FilenameViolations = @{} }
	
	
	# -----------------------------------------
	# Compare Services.
	Write-Debug -Message "{Compare-Deltas} for Services." -Threshold 1 -Prefix '>>'
	Compare-Deltas `
		-CompareProperties $TrackedValues.Services `
		-DeltasObjChanged $deltasObject.ChangedServices `
		-DeltasObjNew $deltasObject.NewServices `
		-DeltasObjRemoved $deltasObject.RemovedServices `
		-Todays $TodaysReport.Services -TodaysIndex $TodaysReport.ServicesIndex `
		-Priors $MostRecentReport.Services -PriorsIndex $MostRecentReport.ServicesIndex
	
	# -----------------------------------------
	# Compare ScheduledTasks.
	Write-Debug -Message "{Compare-Deltas} for Scheduled Tasks." -Threshold 1 -Prefix '>>'
	Compare-Deltas `
		-CompareProperties $TrackedValues.ScheduledTasks `
		-DeltasObjChanged $deltasObject.ChangedScheduledTasks `
		-DeltasObjNew $deltasObject.NewScheduledTasks `
		-DeltasObjRemoved $deltasObject.RemovedScheduledTasks `
		-Todays $TodaysReport.ScheduledTasks -TodaysIndex $TodaysReport.ScheduledTasksIndex `
		-Priors $MostRecentReport.ScheduledTasks -PriorsIndex $MostRecentReport.ScheduledTasksIndex
	
	# -----------------------------------------
	# Compare StoreApps.
	# Add on the static (always-checked) tracker for the StoreApps section.
	$storeAppsTrackers = $TrackedValues.StoreApps
	$storeAppsTrackers += "PackageUserInformation"
	Write-Debug -Message "{Compare-Deltas} for Store Apps." -Threshold 1 -Prefix '>>'
	Compare-Deltas `
		-CompareProperties $storeAppsTrackers `
		-DeltasObjChanged $deltasObject.ChangedStoreApps `
		-DeltasObjNew $deltasObject.NewStoreApps `
		-DeltasObjRemoved $deltasObject.RemovedStoreApps `
		-Todays $TodaysReport.StoreApps -TodaysIndex $TodaysReport.StoreAppsIndex `
		-Priors $MostRecentReport.StoreApps -PriorsIndex $MostRecentReport.StoreAppsIndex
	
	# -----------------------------------------
	# Compare StartupApps.
	Write-Debug -Message "{Compare-Deltas} for Startup Apps." -Threshold 1 -Prefix '>>'
	Compare-Deltas `
		-CompareProperties $TrackedValues.StartupApps `
		-DeltasObjChanged $deltasObject.ChangedStartupApps `
		-DeltasObjNew $deltasObject.NewStartupApps `
		-DeltasObjRemoved $deltasObject.RemovedStartupApps `
		-Todays $TodaysReport.StartupApps -TodaysIndex $TodaysReport.StartupAppsIndex `
		-Priors $MostRecentReport.StartupApps -PriorsIndex $MostRecentReport.StartupAppsIndex
	
	# -----------------------------------------
	# Compare InstalledApps.
	Write-Debug -Message "{Compare-Deltas} for Installed Apps." -Threshold 1 -Prefix '>>'
	Compare-Deltas `
		-CompareProperties $TrackedValues.InstalledApps `
		-DeltasObjChanged $deltasObject.ChangedInstalledApps `
		-DeltasObjNew $deltasObject.NewInstalledApps `
		-DeltasObjRemoved $deltasObject.RemovedInstalledApps `
		-Todays $TodaysReport.InstalledApps -TodaysIndex $TodaysReport.InstalledAppsIndex `
		-Priors $MostRecentReport.InstalledApps -PriorsIndex $MostRecentReport.InstalledAppsIndex
		
	
	# Compare the AMOUNT of keys in each item within the deltasObject against its blank "dummy" variable.
	# If the amount of keys differs in any way that means some changes were added and the deltas must be noted.
	#  NOTE: Don't want to compare "OnlineStatusChange" and "InvokableChange" since these aren't object containers.
	$deltasOnDeltasOnDeltas = $deltasObjectDummy.Keys | ForEach-Object {
		if($_ -eq "OnlineStatusChange" -Or $_ -eq "InvokableChange") { $True }
		else { $deltasObjectDummy[$_].Count -eq $deltasObject[$_].Count }
	}
	# If a change was detected, add the $deltasObject onto the primary $deltas variable with the
	#    client hostname to track each change.
	if(
		($deltasOnDeltasOnDeltas.Contains($False)) -Or
		($deltasObject.InvokableChange -eq $True) -Or
		($deltasObject.OnlineStatusChange -eq $True)
	) { $deltas.Add("$($client.Hostname)", $deltasObject) | Out-Null }
	
	
	#####################################################################
	# CLEANUP SECTION.
	# Clean up the script and reports according to the retention policy.
	Remove-Reports -ClientHostname "$($client.Hostname)"
}




####################################################################################
# NOTIFICATION GENERATION
# Use the notification format that's easily replaceable (see Tweaks section).

# Firstly, check if the $deltas object contains any keys from the operations above.
#    If not, don't bother generating a notification unless specified in the configuration.
if($deltas.Count -gt 0 -And $NoNotifications -eq $False) {
	Write-Host "`n`n-- Generating a notification if applicable." -ForegroundColor White
	# Create an outer wrapper for the loop below, to detect if any info is picked up at all.
	$NOTIFBODY_Wrapper = ""
	$FlipColors = $True
	# Now process the information from the deltas and generate a notification if needed.
	foreach($client in ($deltas.Keys | Sort-Object)) {
		Write-Debug -Message "Client with detected changes: $client" -Threshold 1 -Prefix '>>>>'
		# Declare a new "tracker" variable/container for all report info returned from the categories.
		#    If this is blank for any reason, the client will ommitted.
		$NOTIFBODY_Rpt = ""
		# Set the $clientDeltas object equal to the per-client changes so they can be iterated.
		$clientDeltas = $deltas.$client
		
		<#####
			# First thing to do is check that the Invokable or Online statuses have changed, because if they have,
		    #    the rest of the object won't matter to parse.
		    #    This is noteworthy because it prevents a host from coming back online after an "outage" and having ALL
		    #    of its Services, Apps, etc. being registered as "new" in notifications.
		    # NOTE: A drawback to this is a host coming back online after an outage and having NEW apps on it since the last
			#        test while the target was online previously.
			# 20190917 : THE ISSUE ABOVE HAS SINCE BEEN FIXED BY COPYING REPORTS FORWARD UNTIL A HOST BECOMES REACHABLE AGAIN.
		    #>
		if((($clientDeltas.OnlineStatusChange -eq $True) -Or ($clientDeltas.InvokableChange -eq $True)) -And
			($NotificationsTriggers.ReachabilityChange -eq $True)) {
			Write-Debug -Message "A reachability change is being handled in the report for this client." -Threshold 2 -Prefix '>>>>>>'
			# Read the newly-generated report back in just for this, to get the current online & invokable statuses.
			$TodaysReport = @(Get-ChildItem -Path "$ReportsDirectory" -Filter "Report-$($client)*" `
				| Sort-Object LastWriteTime | Select-Object -Last 1)[0].Name
			Write-Debug -Message "Importing recent report: $TodaysReport" -Threshold 2 -Prefix '>>>>>>'
			$TodaysReport = Get-Content "$ReportsDirectory\$TodaysReport" | ConvertFrom-Json
			# Build the section for the report, to show the online/offline differences.
            if($clientDeltas.OnlineStatusChange -eq $True) {
				# The below value is to check with the "IsOnline" field and must be negated to show the "was" status properly.
				Write-Debug -Message "ONLINE STATUS CHANGE. IsOnline: $($TodaysReport.IsOnline)" -Threshold 3 -Prefix '>>>>>>>>'
				$onlineStatus = @{$True = "online"; $False = "offline" }
				$clientWas = "$($onlineStatus[-Not $TodaysReport.IsOnline])"
				$clientIs = "$($onlineStatus[$TodaysReport.IsOnline])"
            } elseif($clientDeltas.InvokableChange -eq $True) {
				# Same as the above onlineStatus field.
				Write-Debug -Message "INVOKABLE STATUS CHANGE. Invokable: $($TodaysReport.Invokable)" -Threshold 3 -Prefix '>>>>>>>>'
				$invokableStatus = @{$True = "invokable"; $False = "uninvokable" }
				$clientWas = "$($invokableStatus[-Not $TodaysReport.Invokable])"
				$clientIs = "$($invokableStatus[$TodaysReport.Invokable])"
			}
			$NOTIFBODY_Rpt += "<div class='DiffsSection'>`n"
			$NOTIFBODY_Rpt += "Client was <span class='$NotificationsHTMLPriorValClass'>$clientWas</span>"
			$NOTIFBODY_Rpt += ", and is now <span class='$NotificationsHTMLNewValClass'>$clientIs</span>."
			$NOTIFBODY_Rpt += "`n</div>"
			# If the target is now offline, stop here at tracking the most recent changes.
			if($TodaysReport.IsOnline -eq $False) {
				Write-Debug -Message "Client is currently offline. Continuing." -Threshold 2 -Prefix '>>>>>>'
				# Move to the next client. This is all we need from the current one.
				$NOTIFBODY_Wrapper += "`n`n<hr /><table style='border-collapse:collapse;' width='100%'><tr>"
				$NOTIFBODY_Wrapper += "<td bgColor='#$($NotificationsHTMLBackgroundColors[$FlipColors])' width='100%' "
				$NOTIFBODY_Wrapper += "style='border:none;background-color:#$($NotificationsHTMLBackgroundColors[$FlipColors]);'>"
				$NOTIFBODY_Wrapper += "<h2>$client</h2>`n" + $NOTIFBODY_Rpt + "</td></tr></table>`n"
				# Rotate colors.
				$FlipColors = -Not $FlipColors
				continue
			}
		}
		
		
		# -----------------------------------------
		# FILENAME PATTERNS
		if($FilenameTracking -eq $True -And $clientDeltas.FilenameViolations.Count -gt 0) {
			Write-Debug -Message "Building filename trackers section." -Threshold 1 -Prefix '>>>>>>'
			$violations = $clientDeltas.FilenameViolations
			$allTables = ""
			# Structure of these nested loops:
			#    $category = "outer" nest (like "SystemFilesCounts")
			#    $subcategory = per-user/per-location information (like "C:\Users\TestAccount")
			#    $pattern = the pattern or FILES_ key in the actual table.
			foreach($category in $violations.Keys) {
				foreach($subcategory in $violations.$category.Keys) {
					# Set up a variable to patchwerk into the final value to add to the notification.
					$addToReport = $violations.$category.$subcategory
					# Automatically set the "subcategory" field as the Location member.
					$addToReport | Add-Member -Name Location -Value $subcategory -Type NoteProperty
					# For each tracked pattern, check the keys in the object against them (improve later) and clean from there.
					#    This helps to easily generate some tables that correspond dynamically to each entered/tracked pattern.
					foreach($item in $TrackedFilenamePatterns.Keys) {
						$selectedFields = @()
						$violations.$category.$subcategory.Keys | ForEach-Object {
							if($_ -Like "*$($item)*") { $selectedFields += $_ }
						}
						$selectedFields += "Location"
						# If "selectedFields" contains more than just "Location" a table should be generated.
						if($selectedFields.Count -gt 1) {
							if($DebugVerbosity -gt 0) {
								Write-Debug -Message "Selected fields in subcategory '$subcategory':" -Threshold 2 -Prefix '>>>>>>'
								$selectedFields | ForEach-Object { Write-Debug -Message "$_" -Threshold 2 -Prefix '>>>>>>>>' }
							}
							$intermediateTable = (($addToReport | ConvertTo-Json | ConvertFrom-Json) `
								| Select-Object ($selectedFields | Sort-Object) `
								| ConvertTo-Html -Fragment)
							# Cheaply and hackily replace some of the table-header field names after the fact.
							$intermediateTable = $intermediateTable -Replace `
								">Files_$([Regex]::Escape($item))</th", ">Most Recent Files</th"
							$intermediateTable = $intermediateTable -Replace `
								">Threshold_$([Regex]::Escape($item))</th", ">Threshold to Pass</th"
							$intermediateTable = $intermediateTable -Replace `
								">$([Regex]::Escape($item))</th", ">New Count</th"
							$intermediateTable = $intermediateTable -Replace `
								">__Prior_$([Regex]::Escape($item))</th", ">Previous Count</th"
							# Add it to the tables string and thusly onto the body pipeline.
							$allTables += "<span style='color:black;font-size:14px;'><b>Pattern</b>: $($item)</span><br />`n" `
								+ $intermediateTable
						}
					}
				}
			}
			# Add the collected information to the report.
			$NOTIFBODY_Rpt += "<span class='SectionHeader'>Filename Trackers</span><br />`n"
			$NOTIFBODY_Rpt += "<div class='DiffsSection'>`n"
			$NOTIFBODY_Rpt += "$($allTables)<br /><br />`n"
			$NOTIFBODY_Rpt += "</div>`n"
		}
		
		
		# Now that the reachability flags & filenames are reviewed, the rest should be easy variable-matching and iterating keys.
		#    Use a modularized function to add to the report body if the given category/section is enabled with the triggers.
		# -----------------------------------------
		# INSTALLED APPLICATIONS
		$ChangedInstalledAppsFiltered = @()
		if(($NotificationsRecentInstallationsFiltering -eq $True) -And
		  ($TrackedValues.InstalledApps.Contains("DisplayName")) -And
		  ($TrackedValues.InstalledApps.Contains("DisplayVersion"))) {
			Write-Debug -Message "Attempting to track recent installations and suppress recent version changes." -Threshold 1 -Prefix '>>'
			# Test whether or not the trackers CSV exists.
			if($null -ne $filteredInstalledApps) {
				# Set displayNames to each column name.
				$displayNames = ($filteredInstalledApps | Get-Member -Type NoteProperty).Name
				# Output the individual items to the debug console.
				if($DebugVerbosity -gt 0) {
					Write-Debug -Message "Items and Installed Apps with version updates being suppressed:" -Threshold 3 -Prefix '>>>>'
					$displayNames | ForEach-Object { Write-Debug -Message "$($_) :: $($filteredInstalledApps.$_)" -Threshold 3 -Prefix '>>>>>>' }
				}
				# Iterate the ChangedInstalledApps section. If the item matches one of the filters, add it to the tracking object.
				### The tracking object is later added to the Add-ToReport function for InstalledApps and then filtered out of the notification.
				if($clientDeltas.ChangedInstalledApps.Count -gt 0) {
					Write-Debug -Message "Changed {InstalledApps} were detected. Searching." -Threshold 3 -Prefix '>>>>>>'
					foreach($keyname in $clientDeltas.ChangedInstalledApps.Keys) {
						Write-Debug -Message "Examining CHANGED {InstalledApps} key: $keyname" -Threshold 4 -Prefix '>>>>>>>>'
						$installedApp = $clientDeltas.ChangedInstalledApps.$keyname
						# Not using the _prior field because the concern is for the version the app is going TO.
						Write-Debug "Prior : $($installedApp.DisplayVersion_prior) --- New : $($installedApp.DisplayVersion)" -Threshold 4 -Prefix '>>>>>>>>>>>>'
						if(($displayNames -contains "$($installedApp.DisplayName)") -And
						  ($installedApp.DisplayVersion_prior -ne $installedApp.DisplayVersion)) {
							$displayName = "$($installedApp.DisplayName)"
							Write-Debug -Message "Found matching DisplayName :: $displayName" -Threshold 4 -Prefix '>>>>>>>>>>'
							if($filteredInstalledApps.$displayName -contains "$($installedApp.DisplayVersion)") {
								Write-Debug -Message "Found matching DisplayVersion :: $($installedApp.DisplayVersion)" -Threshold 4 -Prefix '>>>>>>>>>>'
								$ChangedInstalledAppsFiltered += $keyname
							}
						}
					}
				} else { Write-Debug -Message "No changed {InstalledApps} were detected." -Threshold 3 -Prefix '>>>>>>' }
			}
		}
		if($NotificationsTriggers.InstalledAppsChange -eq $True) {
			Write-Debug -Message "Building {InstalledApps} Section." -Threshold 1 -Prefix '>>>>>>'
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-ToReport `
				-NewObject $clientDeltas.NewInstalledApps -RemovedObject $clientDeltas.RemovedInstalledApps `
				-ChangedObject $clientDeltas.ChangedInstalledApps -ItemName "Installed Applications" `
				-ItemType "InstalledApps" -PreFilteredItems $ChangedInstalledAppsFiltered
		}
		# -----------------------------------------
		# SERVICES
		if($NotificationsTriggers.ServicesChange -eq $True) {
			Write-Debug -Message "Building {Services} Section." -Threshold 1 -Prefix '>>>>>>'
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-ToReport `
				-NewObject $clientDeltas.NewServices -RemovedObject $clientDeltas.RemovedServices `
				-ChangedObject $clientDeltas.ChangedServices -ItemName "Services" `
				-ItemType "Services"
		}
		# -----------------------------------------
		# STORE APPS
		if($NotificationsTriggers.StoreAppsChange -eq $True) {
			Write-Debug -Message "Building {StoreApps} Section." -Threshold 1 -Prefix '>>>>>>'
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-ToReport `
				-NewObject $clientDeltas.NewStoreApps -RemovedObject $clientDeltas.RemovedStoreApps `
				-ChangedObject $clientDeltas.ChangedStoreApps -ItemName "Store Apps" `
				-ItemType "StoreApps"
		}
		# -----------------------------------------
		# STARTUP APPS
		if($NotificationsTriggers.StartupAppsChange -eq $True) {
			Write-Debug -Message "Building {StartupApps} Section." -Threshold 1 -Prefix '>>>>>>'
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-ToReport `
				-NewObject $clientDeltas.NewStartupApps -RemovedObject $clientDeltas.RemovedStartupApps `
				-ChangedObject $clientDeltas.ChangedStartupApps -ItemName "Startup Apps" `
				-ItemType "StartupApps"
		}
		# -----------------------------------------
		# SCHEDULED TASKS APPS
		if($NotificationsTriggers.ScheduledTasksChange -eq $True) {
			Write-Debug -Message "Building {ScheduledTasks} Section." -Threshold 1 -Prefix '>>>>>>'
			# Add the gathered information to the report.
			$NOTIFBODY_Rpt += Add-ToReport `
				-NewObject $clientDeltas.NewScheduledTasks -RemovedObject $clientDeltas.RemovedScheduledTasks `
				-ChangedObject $clientDeltas.ChangedScheduledTasks -ItemName "Scheduled Tasks" `
				-ItemType "ScheduledTasks"
		}
		
		# ##############################################
		# ########## BUILD THE ENTIRE SECTION ##########
		if($NOTIFBODY_Rpt -ne "") {
			Write-Debug -Message "The report body for '$client' contains information. Adding to notification body." -Threshold 1 -Prefix '>>>>>>'
			# Inject the hostname of the client into the email digest, followed by the Rpt subsection that's been constructed.
			$NOTIFBODY_Wrapper += "`n`n<hr /><table style='border-collapse:collapse;' width='100%'><tr>"
			$NOTIFBODY_Wrapper += "<td bgColor='#$($NotificationsHTMLBackgroundColors[$FlipColors])' width='100%' "
			$NOTIFBODY_Wrapper += "style='border:none;background-color:#$($NotificationsHTMLBackgroundColors[$FlipColors]);'>"
			$NOTIFBODY_Wrapper += "<h2>$client</h2>`n" + $NOTIFBODY_Rpt + "</td></tr></table>"
			# Swap colors.
			$FlipColors = -Not $FlipColors
		} else {
			Write-Debug -Message "The report body for '$client' contained NO INFORMATION." -Threshold 1 -Prefix '>>>>>>'
		}
	}
	
	# If the notification body is still null, inject the No Client Changes message.
	#    Otherwise, build the full report.
	if($NOTIFBODY_Wrapper.Trim() -eq "" -And $NotificationOnNoChange -eq $True) { $NOTIFBODY += $NotificationsBodyOnNoChange }
	elseif($NOTIFBODY_Wrapper.Trim() -eq "" -And $NotificationOnNoChange -eq $False) { $NOTIFBODY += "no-change" }
	else {
		# There were changes registered in the wrapper, so add everything to the primary email body.
		$NOTIFBODY = $NotificationsChangesBodyHeader
		$NOTIFBODY += $NOTIFBODY_Wrapper
	}
	
	# If NOTIFBODY isn't equal to "no-change" then send something out. Otherwise be silent.
	#    This is different because it's not relying on the clientDeltas object to track necessities of notifications.
	#    Instead it can recognize that there ARE changes/deltas but they've ALL been filtered out, and user doesn't want notif.
	if($NOTIFBODY -ne "no-change") {
		# Send the compiled notification to the target address using the SMTP info provided at the top of the script.
		$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
			-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NOTIFBODY
		if($EmailSuccess -ne $True) {
			Write-Host "~~~~ Dispatching email notification to '$NotificationsAddress' (BCC: '$BCC') has failed!"
		}
	} else { Write-Host "~~~~ Notifications on no-change turned off. There were no changes detected." }
} elseif($NotificationOnNoChange -eq $True -And $NoNotifications -eq $False) {
	# Send an email (if enabled) to notify that no changes were detected.
	$EmailSuccess = Send-Email -RELAYSERVER $NotificationsServer -RELAYPORT $NotificationsServerPort `
		-FROM $NotificationsSource -TO $NotificationsAddress -SUBJECT $NotificationsSubject -BODY $NotificationsBodyOnNoChange
	if($EmailSuccess -ne $True) {
		Write-Host "~~~~ Dispatching email notification to '$NotificationsAddress' (BCC: '$BCC') has failed!"
	}
}




####################################################################################
# FINAL CLEANUP & MISC TASKS

# Generate a text file to track differences. This is optional based on whether the parameter to do so is given.
if($DeltasReport -eq $True -And $deltas.Count -gt 0) {
	$currentTime = (Get-Date -UFormat %Y-%m-%d-%H_%M).toString()
	Write-Debug -Message "Generating deltas report with timestamp of $currentTime" -Threshold 1 -Prefix '>>'
	Write-Output $deltas | ConvertTo-Json -Depth 6 | Out-File "$ReportsDirectory\DELTAS-$currentTime.txt"
} elseif($deltas.Count -eq 0) {
	Write-Host "`n`n`nNo changes were detected across the targeted clients." -ForegroundColor Yellow
}

# Notification that the script is finished.
Write-Host "`n`n*****" -NoNewLine
Write-Host " JOB COMPLETE " -NoNewLine -ForegroundColor Green
Write-Host "*****`n"

# Return $deltas in case the person running the script would like to manipulate the given differences.
return $deltas